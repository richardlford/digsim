#+TITLE: Formal Methods Summary
#+OPTIONS: H:5
#+STARTUP: showeverything

This document briefly summarizes current formal method groups, proof
systems, projects and researchers. For each it gives pointers for
further information. It is a work-in-progress and is necessarily
incomplete.

* Formal Methods Research Groups
** DeepSpec Project
- Home Page :: https://deepspec.org

** Galois Inc
- Home Page :: https://galois.com/
- Sources :: https://github.com/GaloisInc

** Yale FLINT Group
- Home Page :: http://flint.cs.yale.edu/flint/
- Publications:
  - https://www.cs.purdue.edu/homes/suresh/590s-Fall2002/papers/Flintoverview.pdf

"The FLINT group at Yale aims to develop a novel and practical
programming infrastructure for constructing large-scale certified
systems software. By combining recent new advances in programming
languages, formal semantics, certified operating systems, program
verification, proof assistants and automation, language-based
secrurity, and certifying compilers, we hope to attack the following
research questions:

- what system software structures can offer the best support for extensibility, security, and resilience?
- what program logics and semantic models can best capture these abstractions?
- what are the right programming languages and environments for developing such certified system software?
- how to build new automation facilities to make certified software really scale?"

** Everest Expedition
- Home Page :: https://project-everest.github.io/
- Source :: https://github.com/project-everest

"We are a team of researchers and engineers from several
organizations, including Microsoft Research, Carnegie Mellon
University, INRIA, and the MSR-INRIA joint center.

Everest is a recursive acronym: It stands for the “Everest VERified
End-to-end Secure Transport”."

* Formal Methods Proof Systems
** Coq
- Home Page :: https://coq.inria.fr/
- Source :: https://github.com/coq/coq.git

Coq is a formal proof management system. It provides a formal language
to write mathematical definitions, executable algorithms and theorems
together with an environment for semi-interactive development of
machine-checked proofs. Typical applications include the certification
of properties of programming languages (e.g. the CompCert compiler
certification project, or the Bedrock verified low-level programming
library), the formalization of mathematics (e.g. the full
formalization of the Feit-Thompson theorem or homotopy type theory)
and teaching.

** KeYmaeraX
- Home Page :: http://www.ls.cs.cmu.edu/KeYmaeraX/
- Source :: https://github.com/LS-Lab/KeYmaeraX-release

** Isabelle
** HOL
- Home Page :: https://hol-theorem-prover.org/
- Source :: https://github.com/HOL-Theorem-Prover

** HOL-Light
- Home Page :: https://www.cl.cam.ac.uk/~jrh13/hol-light/
- Source :: https://github.com/jrh13/hol-light/

** Daphny
** Boogie
** Why3
** Frama-C
** F*
** LEAN

* Formal Methods Projects

** DeepSpec Projects

*** CompCert
- Home Page :: http://compcert.inria.fr
- Source :: https://github.com/AbsInt/CompCert.git

The CompCert C verified compiler is a compiler for a large subset of
the C programming language that generates code for the PowerPC, ARM,
x86 and RISC-V processors.

The distinguishing feature of CompCert is that it has been formally
verified using the Coq proof assistant: the generated assembly code is
formally guaranteed to behave as prescribed by the semantics of the
source C code.

*** Verified Software Toolchain
- Home Page :: http://vst.cs.princeton.edu/
- Source :: https://github.com/PrincetonUniversity/VST.git

The software toolchain includes static analyzers to check assertions
about your program; optimizing compilers to translate your program to
machine language; operating systems and libraries to supply context
for your program. The Verified Software Toolchain project assures with
machine-checked proofs that the assertions claimed at the top of the
toolchain really hold in the machine-language program, running in the
operating-system context.

In some application domains it is not enough to build reliable
software systems, one wants proved-correct software. This is the case
for safety-critical systems (where software bugs can cause injury or
death) and for security-critical applications (where an attacker is
deliberately searching for, and exploiting, software bugs). Since
proofs are large and complex, the proof-checking must be
mechanized. Machine-checked proofs of real software systems are
difficult, but now should be possible, given the recent advances in
the theory and engineering of mechanized proof systems applied to
software verification. But there are several challenges:

- Real software systems are usually built from components in different
  programming languages.

- Some parts of the program need full correctness proofs, which must
  be constructed with great effort; other parts need only safety
  proofs, which can be constructed automatically.

- One reasons about correctness at the source-code level, but one runs
  a machine-code program translated by a compiler; the compiler must
  be proved correct.

- These proofs about different properties, with respect to different
  programming languages, must be integrated together end-to-end in a
  way that is also proved correct and machine-checked.

We address these challenges by defining Verifiable C, a program logic
for the C programming language. Verifiable C is proved sound with
respect to the operational semantics of CompCert C; in turn, the
CompCert verified optimizing C compiler is proved correct with respect
to the assembly-language semantics of the PowerPC, ARM, and x86
processors.

*** CertiKOS - Certified Kit Operating System
- Home Page :: http://flint.cs.yale.edu/certikos/
- Source :: https://github.com/npe9/certikos.git

Developed by the FLINT group.

*** VeriML
- Home Page :: http://flint.cs.yale.edu/shao/papers/veriml.html
- Source :: http://flint.cs.yale.edu/flint/publications/veriml-0.1.tar.gz
- Paper :: http://flint.cs.yale.edu/flint/publications/verimltr.pdf

Developed by the FLINT group.

Modern proof assistants such as Coq and Isabelle provide high degrees
of expressiveness and assurance because they support formal reasoning
in higher-order logic and supply explicit machine-checkable proof
objects. Unfortunately, large scale proof development in these proof
assistants is still an extremely difficult and time-consuming
task. One major weakness of these proof assistants is the lack of a
single language where users can develop complex tactics and decision
procedures using a rich programming model and in a typeful
manner. This limits the scalability of the proof development process,
as users avoid developing domain-specific tactics and decision
procedures.

In this paper, we present VeriML---a novel language design that
couples a type-safe effectful computational language with first-class
support for manipulating logical terms such as propositions and
proofs. The main idea behind our design is to integrate a rich logical
framework---similar to the one supported by Coq---inside a
computational language inspired by ML. The language design is such
that the added features are orthogonal to the rest of the
computational language, and also do not require significant additions
to the logic language, so soundness is guaranteed. We have built a
prototype implementation of VeriML including both its type-checker and
an interpreter. We demonstrate the effectiveness of our design by
showing a number of type-safe tactics and decision procedures written
in VeriML.

*** Certifying Low-Level Programs with Hardware Interrupts and Preemptive Threads
- Home Page :: http://flint.cs.yale.edu/shao/papers/aimjar.html
- Source :: http://flint.cs.yale.edu/flint/publications/aim.coq.tar.gz
- Local repo :: e/certhwint

Developed by the FLINT group.

*** Kami
- Home Page :: http://plv.csail.mit.edu/kami/
- Source :: https://github.com/mit-plv/kami

Kami is a library that turns Coq into an IDE for digital hardware
development, based on a clean-slate reimplementation of a core of the
[[http://www.bluespec.com/][Bluespec]] language. We span the gap from mathematical specifications to
hardware circuit descriptions (RTL netlists). We support specifying,
implementing, verifying, and compiling hardware, reasoning at a high
level about particular hardware components but in the end deriving
first-principles Coq theorems about circuits. No part of Kami need be
trusted beside the formalization of low-level (Verilog-style) circuit
descriptions; all other aspects have end-to-end correctness proofs
checked by Coq. Hardware designs are broken into separately verified
modules, reasoned about with a novel take on labeled transition
systems. Furthermore, Coq provides a natural and expressive platform
for metaprogramming, or building verified circuit generators, as for a
memory caching system autogenerated for a particular shape of cache
hierarchy, or a CPU generated given a number of concurrent cores as
input.

*** Haskell Core Spec
- Home Page :: https://deepspec.org/entry/Project/Haskell+CoreSpec
- Source :: https://github.com/sweirich/corespec.git

The Haskell CoreSpec Project aims to develop formal specifications for
a high-level, industrially-relevant functional programming
language. In particular, this project targets the core language of the
Glasgow Haskell Compiler, the primary compiler for the Haskell
programming language. GHC has long been used as both an industrial
strength compiler and a platform for language research. The compiler
itself is open source, and has primarily been developed and is
currently maintained by researchers at Microsoft Research,
Cambridge. The CoreSpec project will develop a formal Coq
specification of the GHC Core language, including the syntax, type
system, and semantics, and connect that specification to other
components of the DeepSpec project.

*** Deep Spec Server
- Home Page :: https://deepspec.org/entry/Project/DeepSpec+Web+Server
- Source :: Not available but see Libmicrohttpd below. 


"For a final demo, unifying many of the Expedition threads, we aim to
build a verified web server."

Status: "A team at Penn has begun exploring the design space and
building a first-draft prototype (for now, running on Linux) of a web
server library loosely based on the popular libmicrohttpd.  The goal
of this short-term effort is to understand the integration issues that
will be involved in putting together a fully functional server from
components under development within DeepSpec.  In particular, we want
to understand what demands it will place on CertiKOS in terms of OS
features (IPC, network support, shared-memory processes,
interoperation between native clients and Linux VMs), what
verification challenges it raises for VST, what integration challenges
it poses for using VST and CertiKOS together."

**** GNU Libmicrohttpd
- Home Page :: https://www.gnu.org/software/libmicrohttpd/
- Source :: https://gnunet.org/git/libmicrohttpd.git

*** Kami
- Home Page :: http://plv.csail.mit.edu/kami/
- Source :: https://github.com/mit-plv/kami.git

A Coq framework to support implementing, specifying, verifying, and
compiling Bluespec-style hardware components with high developer
productivity.

*** Verdi
- Home Page :: http://verdi.uwplse.org/
- Source :: https://github.com/uwplse/verdi
- Example :: https://github.com/uwplse/verdi-raft

Verification of distributed systems.

*** Vellvm
- Home Page :: http://www.cis.upenn.edu/~stevez/vellvm/
- Source :: https://github.com/vellvm/vellvm
- Old Source :: https://github.com/vellvm/vellvm-legacy

"The Vellvm project is building a (verified LLVM), a framework for
reasoning about programs expressed in LLVM's intermediate
representation and transformations that operate on it. Vellvm provides
a mechanized formal semantics of LLVM's intermediate representation,
its type system, and properties of its SSA form. The framework is
built using the Coq interactive theorem prover. It includes multiple
operational semantics and proves relations among them to facilitate
different reasoning styles and proof techniques.

Latest Results

During the first year of DeepSpec we

1. worked on developing a new modular semantics for Vellvm, factoring out the memory model

2. made progress on connecting LLVM-IR like SSA semantics with higher-level structural operational semantics 

3. applied low-level language verification techniques to the problem of race detectection instrumentation"

*** Deep Spec Crypto
+ Home Page :: https://deepspec.org/entry/Project/Cryptography
+ Source :: https://github.com/mit-plv/fiat-crypto
+ Papers :: http://adam.chlipala.net/papers/FiatCryptoSP19/FiatCryptoSP19.pdf
            http://www.cs.princeton.edu/~appel/papers/verified-hmac-drbg.pdf

"We are pursuing end-to-end proofs of cryptographic functionality, via
verification of C code at Princeton and synthesis of assembly code at
MIT.  We are considering both cryptographic primitives
(e.g. pseudorandom number generation with VST at Princeton and
elliptic curve operations with fiat-crypto at MIT) and protocols
(verified with the Foundational Cryptography Framework and connected
to results about C and assembly programs)."

*Latest Results*:

Fiat Cryptography is now used in Google's BoringSSL library for
elliptic-curve arithmetic.  As a result, Chrome HTTPS connections now
run our Coq-generated code.  Our upcoming S&P 2019 paper goes into
more detail.

VST verification has recently focused on the primitives HMAC-DGBG and
HKDF -- both clients of HMAC/SHA256, AES, and parts of the TweetNaCl
library. In addition to verifying (families of) primitives, we hope to
soon turn to integration in larger contexts like verified TLS
libraries.

*** DeepSpecDb
- Home Page :: ?
- Source :: https://github.com/PrincetonUniversity/DeepSpecDB
- Papers:
  - VST Verification of B+Trees with Cursors
    http://perso.eleves.ens-rennes.fr/people/Aurele.Barriere/papers/vstbtrees.pdf
  - Implementing a high-performance key-value store using a trie of
    B+-Trees with cursors.
    https://github.com/PrincetonUniversity/DeepSpecDB/blob/master/papers/adewale/Masters_Thesis.pdf
  - Project Report on DeepSpecDB
    https://github.com/PrincetonUniversity/DeepSpecDB/blob/master/papers/luke/report.pdf
  - The Theory and Verification of B+Tree Cursor Relations
    https://github.com/PrincetonUniversity/DeepSpecDB/blob/master/papers/mcswiggen/McSwiggen-Thesis.pdf

*** Fiat
- Home Page :: http://plv.csail.mit.edu/fiat/
- Source :: https://github.com/mit-plv/fiat.git

"Fiat is a library for the Coq proof assistant for synthesizing
efficient correct-by-construction programs from declarative
specifications. Programming by Fiat starts with a high-level
description of a program, which can be written using libraries of
specification languages for describing common programming tasks like
querying a relational database. These specifications are then
iteratively refined into efficient implementations via automated
tactics. Each derivation in Fiat produces a formal proof trail
certifying that the synthesized program meets the original
specification. Code synthesized by Fiat can be extracted to an
equivalent OCaml program that can be compiled and run as normal."

*** Narcissus
- Home Page :: https://www.cs.purdue.edu/homes/bendy/Narcissus/
- Source :: https://github.com/mit-plv/fiat/tree/master/src/Narcissus
- Papers :: NARCISSUS: Deriving Correct-By-Construction Decoders and Encoders from Binary Formats
            https://www.cs.purdue.edu/homes/bendy/Narcissus/narcissus.pdf
- Video :: https://deepspec.org/event/dsss18/videos.html Scroll to video

Narcissus is part of the fiat project to derive
Correct-By-Construction Decoders and Encoders from Binary Formats.

*** CertiCoq
- Home Page :: https://www.cs.princeton.edu/~appel/certicoq/
- Source :: https://github.com/PrincetonUniversity/certicoq
- Paper :: http://www.cs.princeton.edu/~appel/papers/certicoq-coqpl.pdf

"The CertiCoq project aims to build a proven-correct compiler for
dependently-typed, functional languages, such as Gallinathe core
language of the Coq proof assistant. A proved-correct compiler
consists of a high-level functional specification, machine-verified
proofs of important properties, such as safety and correctness, and a
mechanism to transport those proofs to the generated machine code. The
project exposes both engineering challenges and foundational questions
about compilers for dependently-typed languages."

*** Template-Coq
- Home Page :: https://template-coq.github.io/template-coq/
- Source :: https://github.com/Template-Coq/template-coq
- Papeers :: https://popl18.sigplan.org/event/coqpl-2018-typed-template-coq

Template Coq is a quoting library for [Coq](http://coq.inria.fr). It
takes `Coq` terms and constructs a representation of their syntax tree as
a `Coq` inductive data type. The representation is based on the kernel's
term representation.

This is used as the first stage of CertiCoq.

*** QuickChick
- Home Page :: https://deepspec.org/entry/Project/QuickChick
- Source :: https://github.com/QuickChick
- Book :: [[https://softwarefoundations.cis.upenn.edu/qc-current/][QuickChick: Property-Based Testing in Coq]]

- Randomized property-based testing plugin for Coq; a clone of Haskell QuickCheck
- Includes a foundational verification framework for testing code
- Includes a mechanism for automatically deriving generators for inductive relations

*** Galois Voting System
- Home Page :: https://galois.com/blog/2009/03/trustworthy-voting-systems/


** Non-DeepSpec Projects
*** CakeML
- Home page :: https://cakeml.org/
- Source :: https://github.com/CakeML/cakeml

"CakeML is a functional programming language and an ecosystem of proofs
and tools built around the language. The ecosystem includes a
proven-correct compiler that can bootstrap itself."

*** VCC - A verifier for Concurrent C
- Home Page :: https://www.microsoft.com/en-us/research/project/vcc-a-verifier-for-concurrent-c/
- Source :: https://github.com/Microsoft/vcc.git

*** Compositional CompCert
- Source :: https://github.com/PrincetonUniversity/compcomp

Compcert supporting separate compilation. Last modified in 2015.

*** GaloisInc Projects
- Home Page :: https://galois.com/
- Source :: https://github.com/GaloisInc
    "Galois develops technology to guarantee the trustworthiness of
    systems where failure is unacceptable.

    We apply cutting edge computer science and mathematics to advance the
    state of the art in software and hardware trustworthiness."

*** Bedrock
- Home Page :: http://plv.csail.mit.edu/bedrock/

*** FSCQ
- Home Page :: http://css.csail.mit.edu/fscq/

A file system verified in Coq using a separation logic for reasoning about crash safety

*** Ur/Web
- Home Page :: http://plv.csail.mit.edu/ur/

* Formal Methods Researchers
Alphabetically by last name, then first.

** Andrew W Appel
- Home Page :: http://www.cs.princeton.edu/~appel/index.html

** Adam Chlipala
- Home Page :: http://adam.chlipala.net/

** Robert Harper
- Home Page :: http://www.cs.cmu.edu/~rwh/

** Benjamin Pierce
- Home Page :: http://www.cis.upenn.edu/~bcpierce/
- LinkedIn :: https://github.com/bcpierce00
Professor Department of Computer and Information Science University of Pennsylvania.
Author of [[http://www.cis.upenn.edu/~bcpierce/sf][Software Foundations]].

** Zhong Shao
- Home Page :: http://cs-www.cs.yale.edu/homes/shao/
