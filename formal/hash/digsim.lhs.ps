%!PS-Adobe-3.0
%%Title: Verif_hash.v
%%Creator: ps-print v7.3.5
%%For: SS-FORDR-LAP
%%CreationDate: 10:26:16 Mar 04 2019
%%Orientation: Portrait
%%DocumentNeededResources: font Times-Roman Times-Italic
%%+ font Courier
%%+ font Courier-Bold
%%+ font Courier-Oblique
%%+ font Courier-BoldOblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%DocumentSuppliedResources: procset PSPrintUserDefinedPrologue-fordrl 0 0
%%DocumentMedia: Letter 612 792 0 () ()
%%PageOrder: Ascend
%%Pages: (atend)
%%Requirements:
%%EndComments
%%BeginDefaults
%%PageMedia: Letter
%%EndDefaults

%%BeginProlog

/languagelevel where{pop}{/languagelevel 1 def}ifelse
/ErrorMessage  1 def

% === BEGIN ps-print prologue 0
% version: 6.0

% Copyright (C) 2000-2018 Free Software Foundation, Inc.

% This file is part of GNU Emacs.

% GNU Emacs is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.

% GNU Emacs is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.

% You should have received a copy of the GNU General Public License
% along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

% As a special exception, the copyright holders of this module give
% you permission to include the module in a Postscript file generated
% by Emacs or other free software together with the result of
% converting text to be printed, regardless of the license terms of
% that text, and to use under terms of your choice the page images
% resulting from formatting said combination.  If you modify this
% module, you may extend this exception to your version of the module
% but you are not obligated to do so.  If you do not wish to do so,
% delete this exception statement from your version.


%%BeginProcSet: ErrorHandler
% Downloaded Error Break-page handler
% Adapted from:
%     PostScript Language Program Design,
%     Adobe Systems Incorporated.
%     Appendix A, pages 217-219

/ps$brkpage where{pop}
{
 /ps$brkpage 64 dict def
 ps$brkpage begin
  /tx 0 def/ty 0 def/toy 0 def/tox 0 def
  /prnt{
   dup type/stringtype ne{=string cvs}if
   dup length 6 mul
   /tx exch def/ty 10 def
   currentpoint/toy exch def/tox exch def
   1 setgray newpath
   tox toy 2 sub moveto
   0 ty rlineto tx 0 rlineto
   0 ty neg rlineto
   closepath fill
   tox toy moveto 0 setgray show
  }bind def
  /nl{currentpoint exch pop lmargin exch moveto 0 -10 rmoveto}def
  /=={/cp 0 def typeprint nl}def
  /typeprint{dup type dup currentdict exch known{exec}{unknowntype}ifelse}readonly def
  /lmargin 72 def
  /rmargin 72 def
  /tprint{
   dup length cp add rmargin gt{nl/cp 0 def}if
   dup length cp add/cp exch def
   prnt
  }readonly def
  /cvsprint{=string cvs tprint( )tprint}readonly def
  /unknowntype{exch pop cvlit(??)tprint cvsprint}readonly def
  /integertype{cvsprint}readonly def
  /realtype{cvsprint}readonly def
  /booleantype{cvsprint}readonly def
  /operatortype{(//)tprint cvsprint}readonly def
  /marktype{pop(-mark-)tprint}readonly def
  /dicttype{pop(-dictionary-)tprint}readonly def
  /nulltype{pop(-null-)tprint}readonly def
  /filetype{pop(-filestream-)tprint}readonly def
  /savetype{pop(-savelevel-)tprint}readonly def
  /fonttype{pop(-fontid-)tprint}readonly def
  /nametype{dup xcheck not{(/)tprint}if cvsprint}readonly def
  /stringtype{
   dup rcheck
   {(\()tprint tprint(\))tprint}
   {pop(-string-)tprint}ifelse}readonly def
  /arraytype{
   dup rcheck
   {dup xcheck
    {({)tprint{typeprint}forall(})tprint}
    {([)tprint{typeprint}forall(])tprint}ifelse}
   {pop(-array-)tprint}ifelse}readonly def
  /packedarraytype{
   dup rcheck
   {dup xcheck
    {({)tprint{typeprint}forall(})tprint}
    {([)tprint{typeprint}forall(])tprint}ifelse}
   {pop(-packedarray-)tprint}ifelse}readonly def
  /courier/Courier findfont 10 scalefont def
  /OLDhandleerror errordict/handleerror get def
 end %ps$brkpage

 /handleerror{
  systemdict begin $error begin ps$brkpage begin
  newerror
  {/newerror false store vmstatus pop pop 0 ne{grestoreall}if
   initgraphics
   ErrorMessage 1 and 0 ne{ % print on paper
    courier setfont lmargin 720 moveto
    (# ERROR: )prnt errorname prnt nl
    (# OFFENDING COMMAND: )prnt/command load prnt
    $error/ostack known
    {nl nl(# STACK:)prnt nl nl $error/ostack get aload length{==}repeat}if
    $error/errorinfo known
    {nl nl(# ERRORINFO:)prnt nl nl $error/errorinfo get aload length{==}repeat}if
    systemdict/showpage get exec}if
   ErrorMessage 2 and 0 ne{ % send back to printing system
    (\%\%[ Error: )print errorname =print
    (; OffendingCommand: )print/command load =print
    $error/errorinfo known
    {(; ErrorInfo:)print $error/errorinfo get aload length{( )=print =print}repeat}if
    ( ]\%\%)= flush
    (\%\%[ Rest of job is ignored ]\%\%)= flush}if
   /newerror true store}if
  end end end
  stop
 } % handleerror
 dup 0 systemdict put % replace name by actual dict object
 dup 4 ps$brkpage put % replace name by dict object
 bind readonly

 errordict 3 1 roll put % put proc in errordict as /handleerror
}ifelse
%%EndProcSet


% operators for language level 2 only

(<<)cvn where			% << operator
{pop/BMark(<<)cvn load def}
{/BMark{mark}bind def}ifelse
(>>)cvn where			% >> operator
{pop/EMark(>>)cvn load def}
{/EMark{counttomark 2 idiv dup dict begin{def}repeat pop currentdict end}bind def}ifelse
/setpagedevice where		% setpagedevice
{pop}
{/setpagedevice{pop}bind def}ifelse
/packedarray where		% packedarray
{pop}
{/packedarray{array astore readonly}bind def}ifelse


% device dependent operators

/DefOp{
 dup where{pop pop pop}
 {exch dup where{pop}{pop/pop}ifelse load def}ifelse}def

/duplexmode/setduplexmode DefOp
/tumble/settumble DefOp

% === END ps-print prologue 0

%%BeginResource: procset PSPrintUserDefinedPrologue-fordrl 0 0


%%EndResource

/LandscapeMode       false def
/UpsideDown          false def
/NumberOfColumns     1 def
/LandscapePageHeight 792.0 def
/PrintPageWidth      498.6141732283465 def
/PrintWidth   498.6141732283465 def
/PrintHeight  643.7029732283465 def
/LeftMargin   56.69291338582677 def
/RightMargin  56.69291338582677 def
/InterColumn  56.69291338582677 def
/BottomMargin 42.51968503937008 def
/TopMargin    42.51968503937008 def
/HeaderOffset 28.346456692913385 def
/HeaderPad    2.4276 def
/FooterOffset 28.346456692913385 def
/FooterPad    0 def
/FooterLines  2 def
/ShowNofN           true def
/SwitchHeader       false def
/PrintOnlyOneHeader false def
/PrintHeader        true def
/PrintHeaderFrame   true def
/HeaderFrameProperties [0.000 0.900 0.400 0.000 0.000 ]def
/PrintFooter        false def
/PrintFooterFrame   true def
/FooterFrameProperties [0.000 0.900 0.400 0.000 0.000 ]def
/LineSpacing      0 def
/ParagraphSpacing 0 def
/LineHeight       8.967500000000001 def
/LinesPerColumn   72 def
/WarnPaperSize    true def
/Zebra            false def
/PrintLineNumber  false def
/SyncLineZebra    false def
/ZebraFollow      0 def
/PrintLineStep    1 def
/PrintLineStart   1 def
/LineNumberColor  [0.000 0.000 0.000] def
/ZebraHeight      3 def
/ZebraColor       0.950 def
/BackgroundColor  [1.000 1.000 1.000] def
/UseSetpagedevice false def

/PageWidth PrintPageWidth LeftMargin add RightMargin add def

/N-Up           1 def
/N-Up-Landscape false def
/N-Up-Border    true def
/N-Up-Lines     1 def
/N-Up-Columns   1 def
/N-Up-Missing   0 def
/N-Up-Margin    28.346456692913385 def
/N-Up-Repeat    N-Up-Lines def
/N-Up-End       N-Up-Columns def
/N-Up-XColumn   PageWidth def
/N-Up-YColumn   0 def
/N-Up-XLine     N-Up-End 1 sub PageWidth mul neg def
/N-Up-YLine     LandscapePageHeight neg def
/N-Up-XStart    0 def
/N-Up-YStart    0 def

% === BEGIN ps-print prologue 1
% version: 6.1

% Copyright (C) 2000-2018 Free Software Foundation, Inc.

% This file is part of GNU Emacs.

% GNU Emacs is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.

% GNU Emacs is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.

% You should have received a copy of the GNU General Public License
% along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

% As a special exception, the copyright holders of this module give
% you permission to include the module in a Postscript file generated
% by Emacs or other free software together with the result of
% converting text to be printed, regardless of the license terms of
% that text, and to use under terms of your choice the page images
% resulting from formatting said combination.  If you modify this
% module, you may extend this exception to your version of the module
% but you are not obligated to do so.  If you do not wish to do so,
% delete this exception statement from your version.


% ISOLatin1Encoding stolen from ps_init.ps in GhostScript 2.6.1.4:
/ISOLatin1Encoding where{pop}{
% -- The ISO Latin-1 encoding vector isn't known, so define it.
% -- The first half is the same as the standard encoding,
% -- except for minus instead of hyphen at code 055.
/ISOLatin1Encoding
StandardEncoding 0 45 getinterval aload pop
    /minus
StandardEncoding 46 82 getinterval aload pop
%*** NOTE: the following are missing in the Adobe documentation,
%*** but appear in the displayed table:
%*** macron at 0225, dieresis at 0230, cedilla at 0233, space at 0240.
% 0200 (128)
    /.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
    /.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
    /dotlessi/grave/acute/circumflex/tilde/macron/breve/dotaccent
    /dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut/ogonek/caron
% 0240 (160)
    /space/exclamdown/cent/sterling
	/currency/yen/brokenbar/section
    /dieresis/copyright/ordfeminine/guillemotleft
	/logicalnot/hyphen/registered/macron
    /degree/plusminus/twosuperior/threesuperior
	/acute/mu/paragraph/periodcentered
    /cedilla/onesuperior/ordmasculine/guillemotright
	/onequarter/onehalf/threequarters/questiondown
% 0300 (192)
    /Agrave/Aacute/Acircumflex/Atilde
	/Adieresis/Aring/AE/Ccedilla
    /Egrave/Eacute/Ecircumflex/Edieresis
	/Igrave/Iacute/Icircumflex/Idieresis
    /Eth/Ntilde/Ograve/Oacute
	/Ocircumflex/Otilde/Odieresis/multiply
    /Oslash/Ugrave/Uacute/Ucircumflex
	/Udieresis/Yacute/Thorn/germandbls
% 0340 (224)
    /agrave/aacute/acircumflex/atilde
	/adieresis/aring/ae/ccedilla
    /egrave/eacute/ecircumflex/edieresis
	/igrave/iacute/icircumflex/idieresis
    /eth/ntilde/ograve/oacute
	/ocircumflex/otilde/odieresis/divide
    /oslash/ugrave/uacute/ucircumflex
	/udieresis/yacute/thorn/ydieresis
256 packedarray def
}ifelse

/reencodeFontISO{ %def
  dup
  length 12 add dict	% Make a new font (a new dict the same size
			% as the old one) with room for our new symbols.

  begin			% Make the new font the current dictionary.

    % Copy each of the symbols from the old dictionary
    % to the new one except for the font ID.
    {1 index/FID ne{def}{pop pop}ifelse}forall

    % Override the encoding with the ISOLatin1 encoding.
    currentdict/FontType get 0 ne{/Encoding ISOLatin1Encoding def}if

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.

%          ^    (x2 y2)
%          |       |
%          |       v
%          |  +----+ - -
%          |  |    |   ^
%          |  |    |   | Ascent (usually > 0)
%          |  |    |   |
% (0 0) -> +--+----+-------->
%             |    |   |
%             |    |   v Descent (usually < 0)
% (x1 y1) --> +----+ - -

    currentdict/FontType get 0 ne
    {/FontBBox load aload pop			% -- x1 y1 x2 y2
     FontMatrix transform/Ascent  exch def pop
     FontMatrix transform/Descent exch def pop}
    {/PrimaryFont FDepVector 0 get def
     PrimaryFont/FontBBox get aload pop
     PrimaryFont/FontMatrix get transform/Ascent exch def pop
     PrimaryFont/FontMatrix get transform/Descent exch def pop}ifelse

    /FontHeight Ascent Descent sub def	% use `sub' because descent < 0

    % Define these in case they're not in the FontInfo
    % (also, here they're easier to get to).
    /UnderlinePosition  Descent 0.70 mul def
    /OverlinePosition   Descent UnderlinePosition sub Ascent add def
    /StrikeoutPosition  Ascent 0.30 mul def
    /LineThickness      FontHeight 0.05 mul def
    /Xshadow            FontHeight  0.08 mul def
    /Yshadow            FontHeight -0.09 mul def
    /SpaceBackground    Descent neg UnderlinePosition add def
    /XBox               Descent neg def
    /YBox               LineThickness 0.7 mul def

    currentdict		% Leave the new font on the stack
    end			% Stop using the font as the current dictionary.
    definefont		% Put the font into the font dictionary
    pop			% Discard the returned font.
}bind def

% Font definition
/DefFont{findfont exch scalefont reencodeFontISO}def

% Font selection
/F{
  findfont
  dup/Ascent            get/Ascent            exch def
  dup/Descent           get/Descent           exch def
  dup/FontHeight        get/FontHeight        exch def
  dup/UnderlinePosition get/UnderlinePosition exch def
  dup/OverlinePosition  get/OverlinePosition  exch def
  dup/StrikeoutPosition get/StrikeoutPosition exch def
  dup/LineThickness     get/LineThickness     exch def
  dup/Xshadow           get/Xshadow           exch def
  dup/Yshadow           get/Yshadow           exch def
  dup/SpaceBackground   get/SpaceBackground   exch def
  dup/XBox              get/XBox              exch def
  dup/YBox              get/YBox              exch def
  setfont
}def

/FG/setrgbcolor load def

/bg false def
/BG{
  dup/bg exch def
  {[4 1 roll]}
  {[1.0 1.0 1.0]}
  ifelse
  /bgcolor exch def
}def

%  B    width    C
%   +-----------+
%               | Ascent  (usually > 0)
% A +           +
%               | Descent (usually < 0)
%   +-----------+
%  E    width    D

/dobackground{				% width --
  currentpoint				% -- width x y
  gsave
    newpath
    moveto				% A (x y)
    0 Ascent rmoveto			% B
    dup 0 rlineto			% C
    0 Descent Ascent sub rlineto	% D
    neg 0 rlineto			% E
    closepath
    FillBgColor
  grestore
}def

/eolbg{					% dobackground until right margin
  PrintWidth				% -- x-eol
  currentpoint pop			% -- cur-x
  sub					% -- width until eol
  dobackground
}def

/LineHS LineHeight LineSpacing add def
/ParagraphHS LineHeight ParagraphSpacing add def
/PSL{/h exch def bg{eolbg}if  0  currentpoint exch pop h sub  moveto}def
/PLN{PrintLineNumber{doLineNumber}if}def

/SL{LineHS PSL isLineStep pop}def	% Soft Linefeed

/PHL{ParagraphHS PSL PLN}def		% Paragraph Hard Linefeed
/LHL{LineHS PSL PLN}def			% Hard Linefeed

% Some debug
/dcp{currentpoint exch 40 string cvs print(, )print =}def
/dp{print 2 copy  exch 40 string cvs print(, )print =}def

/W{
  ( )stringwidth	% Get the width of a space in the current font.
  pop			% Discard the Y component.
  mul			% Multiply the width of a space
			% by the number of spaces to plot
  bg{dup dobackground}if
  0 rmoveto
}def

/Effect          0 def
/EffectUnderline false def
/EffectStrikeout false def
/EffectOverline  false def
/EffectShadow    false def
/EffectBox       false def
/EffectOutline   false def

% effect: 1  - underline  2   - strikeout  4  - overline
%         8  - shadow     16  - box        32 - outline
/EF{
  /Effect exch def
  /EffectUnderline Effect 1  and 0 ne def
  /EffectStrikeout Effect 2  and 0 ne def
  /EffectOverline  Effect 4  and 0 ne def
  /EffectShadow    Effect 8  and 0 ne def
  /EffectBox       Effect 16 and 0 ne def
  /EffectOutline   Effect 32 and 0 ne def
}def

% stack:  string  |-  --
/S{
  /xx currentpoint dup Descent add/yy exch def
  Ascent add/YY exch def def
  dup stringwidth pop xx add/XX exch def
  EffectShadow{
    /yy yy Yshadow add def
    /XX XX Xshadow add def
  }if
  bg{
    true
    EffectBox
      {SpaceBackground doBox}
      {xx yy XX YY doRect}
    ifelse
  }if						% background
  EffectBox      {false 0 doBox}if		% box
  EffectShadow   {dup doShadow}if		% shadow
  EffectOutline
    {true doOutline}				% outline
    {show}					% normal text
  ifelse
  EffectUnderline{UnderlinePosition Hline}if	% underline
  EffectStrikeout{StrikeoutPosition Hline}if	% strikeout
  EffectOverline {OverlinePosition  Hline}if	% overline
}bind def

% stack:  position  |-  --
/Hline{
  currentpoint exch pop add dup
  gsave
  newpath
  xx exch moveto
  XX exch lineto
  closepath
  LineThickness setlinewidth stroke
  grestore
}bind def

% stack:  fill-or-not delta  |-  --
/doBox{
  /dd exch def
  xx XBox sub dd sub yy YBox sub dd sub
  XX XBox add dd add YY YBox add dd add
  doRect
}bind def

% stack:  fill-or-not lower-x lower-y upper-x upper-y  |-  --
/doRect{
  /rYY exch def
  /rXX exch def
  /ryy exch def
  /rxx exch def
  gsave
  newpath
  rXX rYY moveto
  rxx rYY lineto
  rxx ryy lineto
  rXX ryy lineto
  closepath
  % top of stack: fill-or-not
  {FillBgColor}
  {LineThickness setlinewidth stroke}ifelse
  grestore
}bind def

% stack:  string  |-  --
/doShadow{
  gsave
  Xshadow Yshadow rmoveto
  false doOutline
  grestore
}bind def

/st 1 string def

% stack:  string fill-or-not  |-  --
/doOutline{
  /-fillp- exch def
  /-ox- currentpoint/-oy- exch def def
  gsave
  LineThickness setlinewidth
  {st 0 3 -1 roll put
   st dup true charpath
   -fillp- {gsave FillBgColor grestore}if
   stroke stringwidth
   -oy- add/-oy- exch def
   -ox- add/-ox- exch def
   -ox- -oy- moveto
  }forall
  grestore
  -ox- -oy- moveto
}bind def

% stack:  --
/FillBgColor{bgcolor aload pop setrgbcolor fill}bind def

% stack:  -- |- boolean
/isLineStep{
  SyncLineZebra
  {PLScounter 0 gt						% or zebra
   {/PLScounter PLScounter 1 sub def PLScounter 0 eq}
   {false}ifelse
   PrintLineStep 1 gt
   {/PrintLineStep PrintLineStep 1 sub def}
   {/PrintLineStep ZebraHeight def
    /PLScounter PrintLineStart def}ifelse}
  {LineNumber PrintLineStart sub PrintLineStep mod 0 eq}ifelse	% or line step
}def

% stack:  --
/doLineNumber{
  /LineNumber where
  {pop
   isLineStep			% or line step
   LineNumber Lines ge or	% or last line
   {currentfont
    gsave
    LineNumberColor SetColor
    /L0 findfont setfont
    LineNumber Lines ge
    {(end      )}
    {LineNumber 6 string cvs(      )strcat}ifelse
    dup stringwidth pop neg 0 rmoveto
    show
    grestore
    setfont}if
    /LineNumber LineNumber 1 add def
  }if
}def

% stack: color-specifier |- --
/SetColor{dup type/realtype eq{setgray}{aload pop setrgbcolor}ifelse}def

% stack: --
/printZebra{
  gsave
  ZebraColor SetColor
  /double-zebra ZebraHeight ZebraHeight add def
  /yiter double-zebra LineHS mul neg def
  /xiter PrintWidth InterColumn add def
  /zebra-line LinesPrinted def
  NumberOfColumns{LinesPerColumn doColumnZebra xiter 0 rmoveto}repeat
  grestore
}def

% stack:  lines-per-column |- --
/doColumnZebra{
  /lpc exch def
  gsave
  ZebraFollow 1 and 0 ne{
    /H ZebraHeight zebra-line ZebraHeight mod sub def
    /lpc lpc H sub def
    zebra-line double-zebra mod ZebraHeight lt
    {H doZebra	% "black" stripe followed by a "white" stripe
     /lpc lpc ZebraHeight sub def
     H ZebraHeight add}
    {H}ifelse	% "white" stripe
    LineHS mul neg 0 exch rmoveto
    /zebra-line zebra-line LinesPerColumn add def
  }if
  /zspacing 0 def
  lpc dup double-zebra idiv{ZebraHeight doZebra 0 yiter rmoveto}repeat
  double-zebra mod dup 0 le{pop}
  {dup ZebraHeight gt
   {pop ZebraHeight}
   {/zspacing LineSpacing def
    ZebraFollow 2 and 0 ne{pop ZebraHeight}if}ifelse
   doZebra}ifelse
  grestore
}def

% stack:  zebra-height (in lines) |- --
/doZebra{
  /zh exch 0.05 sub LineHS mul zspacing sub def
  gsave
  0 LineHeight 0.65 mul rmoveto
  PrintWidth 0 rlineto
  0 zh neg rlineto
  PrintWidth neg 0 rlineto
  0 zh rlineto
  fill
  grestore
}def

% stack: --
/printBackground{
  /BackgroundColor where{
    /LHg LineHeight 0.65 mul def
    /PHg PrintHeight LHg add def
    pop gsave BackgroundColor SetColor
    NumberOfColumns{
     gsave
     0 LHg rmoveto
     PrintWidth 0 rlineto
     0 PHg neg rlineto
     PrintWidth neg 0 rlineto
     0 PHg rlineto
     fill
     grestore
     PrintWidth InterColumn add 0 rmoveto
    }repeat
    grestore
  }if
}def

% tx ty rotation xscale yscale xpos ypos BeginBackImage
/BeginBackImage{
  /-save-image- save def
  /showpage{}def
  translate
  scale
  rotate
  translate
}def

/EndBackImage{-save-image- restore}def

% string fontsize fontname rotation gray xpos ypos ShowBackText
/ShowBackText{
  gsave
  translate
  setgray
  rotate
  findfont exch dup/-offset- exch -0.25 mul def scalefont setfont
  0 -offset- moveto
  /-saveLineThickness- LineThickness def
  /LineThickness 1 def
  false doOutline
  /LineThickness -saveLineThickness- def
  grestore
}def

/SetPageSize{
  BMark/PageSize[PageWidth LandscapePageHeight LandscapeMode{exch}if]EMark setpagedevice
}def

/BeginDoc{
  % ---- Remember space width of the normal text font `f0'.
  /SpaceWidth/f0 findfont setfont( )stringwidth pop def
  % ---- save the state of the document (useful for ghostscript!)
  /docState save def
  % ---- [andrewi] set PageSize based on chosen dimensions
  UseSetpagedevice{
   WarnPaperSize{SetPageSize}{mark{SetPageSize}stopped cleartomark}ifelse
  }if
  /ColumnWidth PrintWidth InterColumn add def
  % ---- define where  printing will start
  /f0 F					% this installs Ascent
  /PrintStartY PrintHeight Ascent sub def
  /ColumnIndex 1 def
  /N-Up-Counter N-Up-End 1 sub def
  /PLScounter PrintLineStart def
}def

/EndDoc{
  % ---- restore the state of the document (useful for ghostscript!)
  docState restore
}def

/BeginDSCPage{
  % ---- when 1st column, save the state of the page
  ColumnIndex 1 eq{/pageState save def}if
  % ---- save the state of the column
  /columnState save def
}def

/PrintHeaderWidth PrintOnlyOneHeader{PrintPageWidth}{PrintWidth}ifelse def

/BeginPage{
  /LinesPrinted exch def
  % ---- when 1st column, print all background effects
  ColumnIndex 1 eq{
    0 PrintStartY moveto		% move to where printing will start
    printBackground
    Zebra{printZebra}if
    printGlobalBackground
    printLocalBackground
  }if
  PrintOnlyOneHeader{ColumnIndex 1 eq}{true}ifelse
  dup PrintHeader and{
    PrintHeaderFrame{HeaderFrame}if
    HeaderText
  }if
  PrintFooter and{
    PrintFooterFrame{FooterFrame}if
    FooterText
  }if
  0 PrintStartY moveto			% move to where printing will start
  /LineNumber where
  {pop
   SyncLineZebra
   {/H PageNumber 1 sub NumberOfColumns mul ColumnIndex 1 sub add
       LinesPerColumn mul ZebraHeight mod def
    /PLScounter H PrintLineStart ge{0}{PrintLineStart H sub}ifelse def
    /PrintLineStep ZebraHeight H sub def}if}if
  PLN
}def

/EndPage{bg{eolbg}if}def

/EndDSCPage{
  ColumnIndex NumberOfColumns eq{
    % ---- restore the state of the page
    pageState restore
    /ColumnIndex 1 def
    % ---- N-up printing
    N-Up 1 gt{
      N-Up-Counter 0 gt
      {% ---- Next page on same row
	/N-Up-Counter N-Up-Counter 1 sub def
	N-Up-XColumn N-Up-YColumn}
      {% ---- Next page on next line
	/N-Up-Counter N-Up-End 1 sub def
	N-Up-XLine N-Up-YLine}ifelse
      translate
    }if
  }{ % else
    % ---- restore the state of the current column
    columnState restore
    % ---- and translate to the next column
    ColumnWidth 0 translate
    /ColumnIndex ColumnIndex 1 add def
  }ifelse
}def

/TextStart{
  LeftMargin BottomMargin
  PrintFooter{
    FooterPad add
    FooterLines FooterLineHeight mul add
    FooterPad add
    FooterOffset add}if
}def

% stack: number-of-pages-per-sheet |- --
/BeginSheet{
  /sheetState save def
  /pages-per-sheet exch def

  % ---- translate to bottom-right corner of Portrait page
  LandscapeMode{
    LandscapePageHeight 0 translate
    90 rotate
  }if
  % ---- [jack] Kludge: my ghostscript window is 21x27.7 instead of 21x29.7
  /JackGhostscript where{pop 1 27.7 29.7 div scale}if
  UpsideDown{PageWidth LandscapePageHeight translate 180 rotate}if
  % ---- N-Up printing
  N-Up 1 gt{
    % ---- landscape
    N-Up-Landscape{
      PageWidth 0 translate
      90 rotate
    }if
    N-Up-Margin dup translate
    % ---- scale
    LandscapeMode{
      /HH PageWidth def
      /WW LandscapePageHeight def
    }{
      /HH LandscapePageHeight def
      /WW PageWidth def
    }ifelse
    /xx 0 def
    N-Up-Landscape{
      /ww WW WW mul N-Up-Lines HH mul div def
      /cc HH N-Up-Columns N-Up-Missing add div def
      ww cc gt{/xx WW def/WW cc ww div WW mul def/xx xx WW sub def}if
    }{
      /hh HH N-Up-Columns N-Up-Missing add div def
      /cc HH N-Up-Lines div def
      hh cc gt{/xx WW def/WW cc hh div WW mul def/xx xx WW sub def}if
    }ifelse
    WW N-Up-Margin sub N-Up-Margin sub
    N-Up-Landscape
    {N-Up-Lines div HH}
    {N-Up-Columns N-Up-Missing add div WW}ifelse
    div dup scale
    LandscapeMode{/yy 0 def}{/yy xx def/xx 0 def}ifelse
    xx N-Up-Repeat 1 sub LandscapePageHeight mul yy add translate
    % ---- go to start position in page matrix
    N-Up-XStart N-Up-Missing 0.5 mul
    LandscapeMode
    {LandscapePageHeight mul N-Up-YStart add}
    {PageWidth mul add N-Up-YStart}ifelse
    translate
  }if
  % ---- translate to lower left corner of TEXT
  TextStart translate

  % ---- N-up printing
  N-Up 1 gt N-Up-Border and pages-per-sheet 0 gt and{
    % ---- page border
    gsave
    0 setgray
    TextStart exch neg exch neg moveto
    N-Up-Repeat
    {N-Up-End
     {gsave
      PageWidth 0 rlineto
      0 LandscapePageHeight rlineto
      PageWidth neg 0 rlineto
      closepath stroke
      grestore
      /pages-per-sheet pages-per-sheet 1 sub def
      pages-per-sheet 0 le{exit}if
      N-Up-XColumn N-Up-YColumn rmoveto
     }repeat
     pages-per-sheet 0 le{exit}if
     N-Up-XLine N-Up-XColumn sub N-Up-YLine rmoveto
    }repeat
    grestore
  }if
}def

/EndSheet{
  showpage
  sheetState restore
}def

/SetHeaderLines{			% nb-lines --
  /HeaderLines exch def
  % ---- bottom up
  HeaderPad
  HeaderLines 1 sub HeaderLineHeight mul add
  HeaderTitleLineHeight add
  HeaderPad add
  /HeaderHeight exch def
}def

/SetFooterLines{			% nb-lines --
  /FooterLines exch def
  % ---- bottom up
  FooterPad
  FooterLines FooterLineHeight mul add
  FooterPad add
  /FooterHeight exch def
}def

% |---------|
% |  tm     |
% |---------|
% |  header |
% |-+-------| <-- (x y)
% |  ho     |
% |---------|
% |  text   |
% |---------|
% |  fo     |
% |---------|
% |  footer |
% |-+-------| <-- (0 0)
% |  bm     |
% |---------|

% -- |- x y
/HeaderFrameStart{0  PrintHeight HeaderOffset add}def
/FooterFrameStart{0  FooterHeight FooterOffset add neg}def

/doFramePath{
  /h exch def
  PrintHeaderWidth	0	rlineto
  0			h	rlineto
  PrintHeaderWidth neg	0	rlineto
  0			h neg	rlineto
}def

/HeaderFramePath{HeaderHeight doFramePath}def
/FooterFramePath{FooterHeight doFramePath}def

% /path-fun /start-fun vector-property doFrame
/doFrame{
  /vecFrame exch def
  /startFrame exch load def
  /pathFrame exch load def
  gsave
    vecFrame 2 get setlinewidth				% frame border width
    % ---- do the shadow of the next rectangle
    startFrame moveto
    1 -1 rmoveto
    pathFrame
    vecFrame 4 get SetColor fill			% frame shadow color
    % ---- do the next rectangle ...
    startFrame moveto
    pathFrame
    gsave vecFrame 1 get SetColor fill grestore		% frame background
    gsave vecFrame 3 get SetColor stroke grestore	% frame border color
  grestore
}def

/HeaderFrame{/HeaderFramePath /HeaderFrameStart HeaderFrameProperties doFrame}def
/FooterFrame{/FooterFramePath /FooterFrameStart FooterFrameProperties doFrame}def

/HeaderStart{
  HeaderFrameStart
  exch HeaderPad add exch	% horizontal pad
  % ---- bottom up
  HeaderPad add			% vertical   pad
  HeaderDescent sub
  HeaderLineHeight HeaderLines 1 sub mul add
}def

/FooterStart{
  FooterFrameStart
  exch FooterPad add exch	% horizontal pad
  % ---- bottom up
  FooterPad add			% vertical   pad
  FooterDescent sub
  FooterLineHeight FooterLines 1 sub mul add
}def

/HeaderClip{HeaderFrameStart moveto HeaderFramePath clip}def
/FooterClip{FooterFrameStart moveto FooterFramePath clip}def

/strcat{
  dup length 3 -1 roll dup length dup 4 -1 roll add string dup
  0 5 -1 roll putinterval
  dup 4 2 roll exch putinterval
}def

/pagenumberstring{
  PageNumber 32 string cvs
  ShowNofN{(/)strcat PageCount 32 string cvs strcat}if
}def

% lines is-right HeaderOrFooterTextLines
/HeaderOrFooterTextLines{
  /is_right exch def
  HFStart moveto
  { % ---- process the lines
   aload pop
   exch F
   gsave
    dup xcheck{exec}if
    is_right{
     dup stringwidth pop
     PrintHeaderWidth exch sub HFPad HFPad add sub 0 rmoveto
    }if
    HFColor SetColor
    show
   grestore
   0 HFLineHeight neg rmoveto
  }forall
}def

% right-lines left-lines /start lineheight pad fore-color HeaderOrFooterText
/HeaderOrFooterText{
  /HFColor exch def
  /HFPad exch def
  /HFLineHeight exch def
  /HFStart exch load def

  % -- rightLines leftLines -- at stack

  % ---- hack: `PN 1 and'  ==  `PN 2 modulo'
  % ---- if even page number and duplex, then exchange left and right
  PageNumber 1 and 0 eq SwitchHeader and{exch}if

  % ---- process the left lines
  false HeaderOrFooterTextLines

  % ---- process the right lines
  true HeaderOrFooterTextLines
}def

/HeaderText{
  gsave HeaderClip
  HeaderLinesRight HeaderLinesLeft
  /HeaderStart HeaderLineHeight HeaderPad
  HeaderFrameProperties 0 get
  HeaderOrFooterText
  grestore
}def

/FooterText{
  gsave FooterClip
  FooterLinesRight FooterLinesLeft
  /FooterStart FooterLineHeight FooterPad
  FooterFrameProperties 0 get
  HeaderOrFooterText
  grestore
}def

/ReportFontInfo{
  2 copy
  /t0 3 1 roll DefFont
  /t0 F
  /lh FontHeight def
  /sw( )stringwidth pop def
  /aw(01234567890abcdefghijklmnopqrstuvwxyz)dup length exch
  stringwidth pop exch div def
  /t1 12/Helvetica-Oblique DefFont
  /t1 F
  gsave
    (languagelevel = )show
    languagelevel 32 string cvs show
  grestore
  0 FontHeight neg rmoveto
  gsave
    (For )show
    128 string cvs show
    ( )show
    32 string cvs show
    ( point, the line height is )show
    lh 32 string cvs show
    (, the space width is )show
    sw 32 string cvs show
    (,)show
  grestore
  0 FontHeight neg rmoveto
  gsave
    (and a crude estimate of average character width is )show
    aw 32 string cvs show
    (.)show
  grestore
  0 FontHeight neg rmoveto
}def

% cm to point
/cm{72 mul 2.54 div}def

/ReportAllFontInfo{
  % key = font name   value = font dictionary
  FontDirectory{pop 10 exch ReportFontInfo}forall
}def

% 3 cm 20 cm moveto  10/Courier ReportFontInfo  showpage
% 3 cm 20 cm moveto  ReportAllFontInfo          showpage

% === END ps-print prologue 1

/printGlobalBackground{
}def
/printLocalBackground{
}def

%%EndProlog

%%BeginSetup

%%IncludeResource: font Times-Roman
%%IncludeResource: font Times-Italic
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-BoldOblique
%%IncludeResource: font Helvetica
%%IncludeResource: font Helvetica-Bold
/h0 14(Helvetica-Bold)cvn DefFont
/h1 12(Helvetica)cvn DefFont
/L0 6(Times-Italic)cvn DefFont
/H0 12(Helvetica)cvn DefFont


% ---- These lines must be kept together because...

/h0 F
/HeaderTitleLineHeight FontHeight def

/h1 F
/HeaderLineHeight FontHeight def
/HeaderDescent    Descent def

/H0 F
/FooterLineHeight FontHeight def
/FooterDescent    Descent def

% ---- ...because `F' has a side-effect on `FontHeight' and `Descent'

/f0 8.5(Courier)cvn DefFont
/f1 8.5(Courier-Bold)cvn DefFont
/f2 8.5(Courier-Oblique)cvn DefFont
/f3 8.5(Courier-BoldOblique)cvn DefFont
/SpaceWidthRatio 0.600000 def

%%BeginFeature: *ManualFeed False
BMark /ManualFeed false EMark setpagedevice
%%EndFeature

%%%% Start of Mule Section

/Latin1Encoding {	% newname fontname  |  font
    findfont dup length dict begin
	{ 1 index /FID ne { def } { pop pop } ifelse } forall
        /Encoding ISOLatin1Encoding def
	currentdict
    end
    definefont
} bind def

%% Redefine fonts for multiple charsets.
/ReDefFont {		     % fontname encoding fdepvector size  |  -
  20 dict begin
  3 index findfont {
    1 index /FID ne 2 index /UniqueID ne and {def} {pop pop} ifelse
  } forall
  /FontType 0 def
  /FMapType 3 def
  /EscChar 0 def
  % FontMatrix ::= [ size 0 0 size 0 0 ]
  /FontMatrix exch [ exch dup 0 exch 0 exch 0 0 ] def
  /FDepVector exch def
  /Encoding exch def
  currentdict
  end			% fontname dic
  definefont pop
} bind def

/EscChar 0 def

%% End of Mule Section

%%%% Procedures for character composition.
/RelativeCompositionSkip 0.4 def

%% Get a bounding box (relative to currentpoint) of STR.
/GetPathBox {			% [ str cname ]  |  -
    dup 1 get dup false ne {
	BitmapDict exch get /bmp exch def
	%% bmp ::= [ DWIDTH WIDTH HEIGHT XOFF YOFF BITMAP RELATIVE-COMPOSE]
	/LLY bmp 4 get def
	/URY LLY bmp 2 get add def
	/RelativeCompose bmp 6 get dup false ne {
	    dup LLY le { pop 1 } { URY ge { -1 } { 0 } ifelse } ifelse
	} {
	    pop 0
	} ifelse def
	dup 0 get stringwidth pop dup /WIDTH exch def bmp 0 get div
	dup LLY mul /LLY exch def
	URY mul /URY exch def
    } {
	pop
	dup 0 get stringwidth pop /WIDTH exch def
	gsave 0 0 moveto
	dup 0 get false charpath flattenpath pathbbox
	/URY exch def pop /LLY exch def pop
	grestore
	/RelativeCompose 0 def
    } ifelse
} bind def

%% Apply effects except for shadow and outline to the rectangle
%% specified by TOP BOTTOM LEFT RIGHT.
/SpecialEffect {		% --  |  --
    currentpoint dup TOP add /yy exch def BOTTOM add /YY exch def
    dup LEFT add /xx exch def RIGHT add /XX exch def
    %% Adjust positions for future shadowing.
    Effect 8 and 0 ne {
	/yy yy Yshadow add def
	/XX XX Xshadow add def
    } if
    Effect 1 and 0 ne { UnderlinePosition Hline } if	% underline
    Effect 2 and 0 ne { StrikeoutPosition Hline } if	% strikeout
    Effect 4 and 0 ne { OverlinePosition  Hline } if	% overline
    bg {						% background
	true
	Effect 16 and 0 ne {SpaceBackground doBox} { xx yy XX YY doRect} ifelse
    } if
    Effect 16 and 0 ne { false 0 doBox } if		% box
} def

%% Draw COMPONENTS which has the form [ [str0 xoff0 yoff0] ... ] with
%% effects shadow and outline.
/ShowComponents {		% components  |  -
    gsave
    { 	gsave aload pop rmoveto
	Effect 8 and 0 ne { dup doShadow } if
	Effect 32 and 0 ne { true doOutline } { show } ifelse
	grestore
    } forall
    grestore
    RIGHT 0 rmoveto
} def

%% Show relative composition.
/RLC {	       % [[str0 cname0] [str1 cname1] ... [strN cnameN]]  |  -
    /components exch def
    [ 				% push [str xoff yoff] one by one
    [ components 0 get GetPathBox aload pop pop 0 0 ]
    %% Bounding box of overall glyphs.
    /LEFT 0 def
    /RIGHT WIDTH def
    /TOP URY def
    /BOTTOM LLY def

    1 1 components length 1 sub {
	components exch get
	[ exch
	    GetPathBox
	    aload pop pop				% str
	    0						% xoff
	    RelativeCompose 1 eq {	    % compose on TOP
		TOP LLY sub RelativeCompositionSkip add	% yoff
		/TOP TOP URY LLY sub add RelativeCompositionSkip add def
	    } { RelativeCompose -1 eq {	% compose under BOTTOM
		BOTTOM URY sub RelativeCompositionSkip sub % yoff
		/BOTTOM BOTTOM URY LLY sub sub
		RelativeCompositionSkip sub def
	    } {
		0					% yoff
		URY TOP gt { /TOP URY def } if
		LLY BOTTOM lt { /BOTTOM LLY def } if
	    } ifelse } ifelse
	]
    } for
    ]
    SpecialEffect		% Reflect special effects.
    ShowComponents		% Draw components.
} def

%% Show rule-base composition.
/RBC { % [[str0 cname0] rule1 [str1 cname0] rule2 ... [strN cnameN]]  |  -
    /components exch def
    [ 				% push [str xoff yoff] one by one
    [ components 0 get GetPathBox aload pop pop 0 0 ]
    %% Bounding box of overall glyphs.
    /LEFT 0 def
    /RIGHT WIDTH def
    /TOP URY def
    /BOTTOM LLY def
    1 1 components length 1 sub {
	components exch get /elt exch def
	elt type /integertype eq {			% rule
	    %% Do the same RULE decoding as the macro
	    %% COMPOSITION_DECODE_RULE in emacs/src/composite.h.
	    elt 12 idiv dup 3 mod /grefx exch def 3 idiv /grefy exch def
	    elt 12 mod dup 3 mod /nrefx exch def 3 idiv /nrefy exch def
	} {						% other strings
	    [
	    elt GetPathBox
	    aload pop pop
	    /height URY LLY sub def
	    /left LEFT [ 0 RIGHT LEFT sub dup 2 div exch ] grefx get add
		[ 0 WIDTH 2 div WIDTH ] nrefx get sub def
	    /bottom [ TOP 0 BOTTOM TOP BOTTOM add 2 div ] grefy get
		[ height LLY neg 0 height 2 div ] nrefy get sub def
	    %% Update bounding box
	    left LEFT lt { /LEFT left def } if
	    left WIDTH add RIGHT gt { /RIGHT left WIDTH add def } if
	    bottom BOTTOM lt { /BOTTOM bottom def } if
	    bottom height add TOP gt { /TOP bottom height add def } if
	    left bottom LLY sub ]
	} ifelse
    } for
    ]

    LEFT 0 lt {			% Adjust xoff to the right.
	dup { dup 1 get LEFT sub 1 exch put } forall
	/RIGHT RIGHT LEFT sub def
    } if

    SpecialEffect		% Reflect special effects.
    ShowComponents		% Draw components.
} def

%%%% End of procedures for character composition
/F00 /Courier findfont def
/ETOP0 256 array def
0 1 255 { ETOP0 exch 0 put } for
ETOP0 0 0 put
/VTOP0 [F00] def
/ETOP1 256 array def
0 1 255 { ETOP1 exch 0 put } for
ETOP1 0 0 put
/VTOP1 [F00] def
/ETOP2 256 array def
0 1 255 { ETOP2 exch 0 put } for
ETOP2 0 0 put
/VTOP2 [F00] def
/ETOP3 256 array def
0 1 255 { ETOP3 exch 0 put } for
ETOP3 0 0 put
/VTOP3 [F00] def
/Vh0 [ VTOP1 aload pop ] def

Vh0 0 /Helvetica-Bold-latin1 /Helvetica-Bold Latin1Encoding put
/h0 ETOP1 Vh0 14.000000 ReDefFont
/Vh1 [ VTOP0 aload pop ] def

Vh1 0 /Helvetica-latin1 /Helvetica Latin1Encoding put
/h1 ETOP0 Vh1 12.000000 ReDefFont
/VH0 [ VTOP0 aload pop ] def

VH0 0 /Helvetica-latin1 /Helvetica Latin1Encoding put
/H0 ETOP0 VH0 12.000000 ReDefFont
/Vf0 [ VTOP0 aload pop ] def

Vf0 0 /Courier-latin1 /Courier Latin1Encoding put
/f0 ETOP0 Vf0 8.500000 ReDefFont
/Vf1 [ VTOP1 aload pop ] def

Vf1 0 /Courier-Bold-latin1 /Courier-Bold Latin1Encoding put
/f1 ETOP1 Vf1 8.500000 ReDefFont
/Vf2 [ VTOP2 aload pop ] def

Vf2 0 /Courier-Oblique-latin1 /Courier-Oblique Latin1Encoding put
/f2 ETOP2 Vf2 8.500000 ReDefFont
/Vf3 [ VTOP3 aload pop ] def

Vf3 0 /Courier-BoldOblique-latin1 /Courier-BoldOblique Latin1Encoding put
/f3 ETOP3 Vf3 8.500000 ReDefFont
/F00 /Courier findfont def
/ETOP0 256 array def
0 1 255 { ETOP0 exch 0 put } for
ETOP0 0 0 put
/VTOP0 [F00] def
/ETOP1 256 array def
0 1 255 { ETOP1 exch 0 put } for
ETOP1 0 0 put
/VTOP1 [F00] def
/ETOP2 256 array def
0 1 255 { ETOP2 exch 0 put } for
ETOP2 0 0 put
/VTOP2 [F00] def
/ETOP3 256 array def
0 1 255 { ETOP3 exch 0 put } for
ETOP3 0 0 put
/VTOP3 [F00] def
/Vh0 [ VTOP1 aload pop ] def

Vh0 0 /Helvetica-Bold-latin1 /Helvetica-Bold Latin1Encoding put
/h0 ETOP1 Vh0 14.000000 ReDefFont
/Vh1 [ VTOP0 aload pop ] def

Vh1 0 /Helvetica-latin1 /Helvetica Latin1Encoding put
/h1 ETOP0 Vh1 12.000000 ReDefFont
/VH0 [ VTOP0 aload pop ] def

VH0 0 /Helvetica-latin1 /Helvetica Latin1Encoding put
/H0 ETOP0 VH0 12.000000 ReDefFont
/Vf0 [ VTOP0 aload pop ] def

Vf0 0 /Courier-latin1 /Courier Latin1Encoding put
/f0 ETOP0 Vf0 8.500000 ReDefFont
/Vf1 [ VTOP1 aload pop ] def

Vf1 0 /Courier-Bold-latin1 /Courier-Bold Latin1Encoding put
/f1 ETOP1 Vf1 8.500000 ReDefFont
/Vf2 [ VTOP2 aload pop ] def

Vf2 0 /Courier-Oblique-latin1 /Courier-Oblique Latin1Encoding put
/f2 ETOP2 Vf2 8.500000 ReDefFont
/Vf3 [ VTOP3 aload pop ] def

Vf3 0 /Courier-BoldOblique-latin1 /Courier-BoldOblique Latin1Encoding put
/f3 ETOP3 Vf3 8.500000 ReDefFont
/F00 /Courier findfont def
/ETOP0 256 array def
0 1 255 { ETOP0 exch 0 put } for
ETOP0 0 0 put
/VTOP0 [F00] def
/ETOP1 256 array def
0 1 255 { ETOP1 exch 0 put } for
ETOP1 0 0 put
/VTOP1 [F00] def
/ETOP2 256 array def
0 1 255 { ETOP2 exch 0 put } for
ETOP2 0 0 put
/VTOP2 [F00] def
/ETOP3 256 array def
0 1 255 { ETOP3 exch 0 put } for
ETOP3 0 0 put
/VTOP3 [F00] def
/Vh0 [ VTOP1 aload pop ] def

Vh0 0 /Helvetica-Bold-latin1 /Helvetica-Bold Latin1Encoding put
/h0 ETOP1 Vh0 14.000000 ReDefFont
/Vh1 [ VTOP0 aload pop ] def

Vh1 0 /Helvetica-latin1 /Helvetica Latin1Encoding put
/h1 ETOP0 Vh1 12.000000 ReDefFont
/VH0 [ VTOP0 aload pop ] def

VH0 0 /Helvetica-latin1 /Helvetica Latin1Encoding put
/H0 ETOP0 VH0 12.000000 ReDefFont
/Vf0 [ VTOP0 aload pop ] def

Vf0 0 /Courier-latin1 /Courier Latin1Encoding put
/f0 ETOP0 Vf0 8.500000 ReDefFont
/Vf1 [ VTOP1 aload pop ] def

Vf1 0 /Courier-Bold-latin1 /Courier-Bold Latin1Encoding put
/f1 ETOP1 Vf1 8.500000 ReDefFont
/Vf2 [ VTOP2 aload pop ] def

Vf2 0 /Courier-Oblique-latin1 /Courier-Oblique Latin1Encoding put
/f2 ETOP2 Vf2 8.500000 ReDefFont
/Vf3 [ VTOP3 aload pop ] def

Vf3 0 /Courier-BoldOblique-latin1 /Courier-BoldOblique Latin1Encoding put
/f3 ETOP3 Vf3 8.500000 ReDefFont
/F00 /Courier findfont def
/ETOP0 256 array def
0 1 255 { ETOP0 exch 0 put } for
ETOP0 0 0 put
/VTOP0 [F00] def
/ETOP1 256 array def
0 1 255 { ETOP1 exch 0 put } for
ETOP1 0 0 put
/VTOP1 [F00] def
/ETOP2 256 array def
0 1 255 { ETOP2 exch 0 put } for
ETOP2 0 0 put
/VTOP2 [F00] def
/ETOP3 256 array def
0 1 255 { ETOP3 exch 0 put } for
ETOP3 0 0 put
/VTOP3 [F00] def
/Vh0 [ VTOP1 aload pop ] def

Vh0 0 /Helvetica-Bold-latin1 /Helvetica-Bold Latin1Encoding put
/h0 ETOP1 Vh0 14.000000 ReDefFont
/Vh1 [ VTOP0 aload pop ] def

Vh1 0 /Helvetica-latin1 /Helvetica Latin1Encoding put
/h1 ETOP0 Vh1 12.000000 ReDefFont
/VH0 [ VTOP0 aload pop ] def

VH0 0 /Helvetica-latin1 /Helvetica Latin1Encoding put
/H0 ETOP0 VH0 12.000000 ReDefFont
/Vf0 [ VTOP0 aload pop ] def

Vf0 0 /Courier-latin1 /Courier Latin1Encoding put
/f0 ETOP0 Vf0 8.500000 ReDefFont
/Vf1 [ VTOP1 aload pop ] def

Vf1 0 /Courier-Bold-latin1 /Courier-Bold Latin1Encoding put
/f1 ETOP1 Vf1 8.500000 ReDefFont
/Vf2 [ VTOP2 aload pop ] def

Vf2 0 /Courier-Oblique-latin1 /Courier-Oblique Latin1Encoding put
/f2 ETOP2 Vf2 8.500000 ReDefFont
/Vf3 [ VTOP3 aload pop ] def

Vf3 0 /Courier-BoldOblique-latin1 /Courier-BoldOblique Latin1Encoding put
/f3 ETOP3 Vf3 8.500000 ReDefFont
/F00 /Courier findfont def
/ETOP0 256 array def
0 1 255 { ETOP0 exch 0 put } for
ETOP0 0 0 put
/VTOP0 [F00] def
/ETOP1 256 array def
0 1 255 { ETOP1 exch 0 put } for
ETOP1 0 0 put
/VTOP1 [F00] def
/ETOP2 256 array def
0 1 255 { ETOP2 exch 0 put } for
ETOP2 0 0 put
/VTOP2 [F00] def
/ETOP3 256 array def
0 1 255 { ETOP3 exch 0 put } for
ETOP3 0 0 put
/VTOP3 [F00] def
/Vh0 [ VTOP1 aload pop ] def

Vh0 0 /Helvetica-Bold-latin1 /Helvetica-Bold Latin1Encoding put
/h0 ETOP1 Vh0 14.000000 ReDefFont
/Vh1 [ VTOP0 aload pop ] def

Vh1 0 /Helvetica-latin1 /Helvetica Latin1Encoding put
/h1 ETOP0 Vh1 12.000000 ReDefFont
/VH0 [ VTOP0 aload pop ] def

VH0 0 /Helvetica-latin1 /Helvetica Latin1Encoding put
/H0 ETOP0 VH0 12.000000 ReDefFont
/Vf0 [ VTOP0 aload pop ] def

Vf0 0 /Courier-latin1 /Courier Latin1Encoding put
/f0 ETOP0 Vf0 8.500000 ReDefFont
/Vf1 [ VTOP1 aload pop ] def

Vf1 0 /Courier-Bold-latin1 /Courier-Bold Latin1Encoding put
/f1 ETOP1 Vf1 8.500000 ReDefFont
/Vf2 [ VTOP2 aload pop ] def

Vf2 0 /Courier-Oblique-latin1 /Courier-Oblique Latin1Encoding put
/f2 ETOP2 Vf2 8.500000 ReDefFont
/Vf3 [ VTOP3 aload pop ] def

Vf3 0 /Courier-BoldOblique-latin1 /Courier-BoldOblique Latin1Encoding put
/f3 ETOP3 Vf3 8.500000 ReDefFont
BeginDoc
%%EndSetup

%%Page: 1 1
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1 def
/PageNumber 1 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
0 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(\(**) S
( ) S
(* ) S
(Verif_hash: Correctness proof of hash.c) S
( *\)) S
PHL
LHL
(Require Import) S
( VST.floyd.proofauto.) S
LHL
(Require Import) S
( VST.floyd.library.) S
LHL
(Require Import) S
(  Hash.hash.) S
LHL
(Instance) S
( ) S
(CompSpecs) S
( : compspecs.) S
( ) S
(make_compspecs prog.) S
( ) S
(Defined) S
(.) S
LHL
(Definition) S
( ) S
(Vprog) S
( : varspecs.) S
(  ) S
(mk_varspecs prog.) S
( ) S
(Defined) S
(.) S
PHL
LHL
(Require Import) S
( VST.msl.wand_frame.) S
LHL
(Require Import) S
( VST.msl.iter_sepcon.) S
LHL
(Require Import) S
( VST.floyd.reassoc_seq.) S
LHL
(Require Import) S
( VST.floyd.field_at_wand.) S
LHL
(Require Import) S
( Hash.Hashfun.) S
PHL
LHL
(\() S
(* ) S
(=================================================================) S
( ) S
(*\)) S
LHL
(\(*) S
(* ** ) S
(Function specifications) S
( *\)) S
LHL
(\(*) S
( ) S
(-----------------------------------------------------------------) S
( ) S
(*\)) S
LHL
(\(*) S
(* *** ) S
(Imports from the C string library) S
( *\)) S
PHL
LHL
(Require Import) S
( DigUty.strlib_specs.) S
LHL
(Definition) S
( ) S
(strcmp_spec) S
( := strcmp_spec' _strcmp 1 2.) S
LHL
(Definition) S
( ) S
(strcpy_spec) S
( := strcpy_spec' _strcpy 1 2.) S
LHL
(Definition) S
( ) S
(strlen_spec) S
( := strlen_spec' _strlen 1.) S
PHL
LHL
(\() S
(* ) S
(-----------------------------------------------------------------) S
( ) S
(*\)) S
LHL
(\(*) S
(* ***  ) S
(String functions:  copy, hash) S
( *\)) S
PHL
LHL
(Definition) S
( ) S
(copy_string_spec) S
( : ident * funspec :=) S
LHL
( DECLARE _copy_string) S
LHL
( WITH sh: share, s: val, sigma : string, gv: globals) S
LHL
( PRE [ _s OF tptr tschar ]) S
LHL
(    PROP \(readable_share sh; Zlength sigma < Int.max_signed\)) S
LHL
(    LOCAL \(temp _s s; gvars gv\)) S
LHL
(    SEP \(cstring sh sigma s\)) S
LHL
( POST [ tptr tschar ]) S
LHL
(    EX p: val, PROP \( \) LOCAL \(temp ret_temp p\)) S
LHL
(               SEP \(cstring sh sigma s; cstring Ews sigma p;) S
LHL
(                      mem_mgr gv;) S
LHL
(                      malloc_token Ews \(tarray tschar \(Zlength sigma + 1\)\) p\).) S
PHL
LHL
(Definition) S
( ) S
(hash_spec) S
( : ident * funspec :=) S
LHL
(  DECLARE _hash) S
LHL
(  WITH sh: share, s: val, contents : string) S
LHL
(  PRE [ _s OF \(tptr tschar\) ]) S
LHL
(          PROP  \(readable_share sh; Zlength contents < Int.max_signed\)) S
LHL
(          LOCAL \(temp _s s\)) S
LHL
(          SEP   \(cstring sh contents s\)) S
LHL
(  POST [ tuint ]) S
LHL
(        PROP \(\)) S
LHL
8 W
(LOCAL\(temp ret_temp  \(Vint \(Int.repr \(hashfun contents\)\)\)\)) S
LHL
(        SEP \(cstring sh contents s\).) S
PHL
LHL
(\() S
(* ) S
(-----------------------------------------------------------------) S
( ) S
(*\)) S
LHL
(\(*) S
(* *** ) S
(Data structures for hash table) S
( *\)) S
PHL
LHL
(Definition) S
( ) S
(tcell) S
( := Tstruct _cell noattr.) S
LHL
(Definition) S
( ) S
(thashtable) S
( := Tstruct _hashtable noattr.) S
PHL
LHL
(Definition) S
( ) S
(list_cell) S
( \() S
(key) S
(: string\) \() S
(count) S
(: Z\) \() S
(next) S
(: val\) \() S
(p) S
(: val\): mpred :=) S
LHL
( EX kp: val, cstring Ews key kp * data_at Ews tcell \(kp,\(Vint \(Int.repr count\), next\)\) p) S
LHL
(                     ) S
(*) S
( malloc_token Ews tcell p.) S
PHL
LHL
(Definition) S
( ) S
(list_cell_local_facts) S
(:) S
LHL
(  ) S
[[(?)false] ] RLC
( ) S
(key count next p) S
(, list_cell key count next p |-- !! isptr p.) S
LHL
(Proof) S
(.) S
( ) S
(intros) S
(.) S
( ) S
(unfold) S
( list_cell.) S
( ) S
(Intros kp.) S
( ) S
(entailer!.) S
( ) S
(Qed) S
(.) S
LHL
(Hint Resolve) S
( ) S
(list_cell_local_facts) S
(: saturate_local.) S
PHL
LHL
(Definition) S
( ) S
(list_cell_valid_pointer) S
(:) S
LHL
(  ) S
[[(?)false] ] RLC
( ) S
(key count next p) S
(, list_cell key count next p |-- valid_pointer p.) S
LHL
(Proof) S
(.) S
( ) S
(intros) S
(.) S
( ) S
(unfold) S
( list_cell.) S
( ) S
(Intros kp.) S
( ) S
(entailer!.) S
( ) S
(Qed) S
(.) S
LHL
(Hint Resolve) S
( ) S
(list_cell_valid_pointer) S
(: valid_pointer.) S
PHL
EndPage
EndDSCPage
EndSheet

%%Page: 2 2
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 73 def
/PageNumber 2 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
72 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(\() S
(** **** ) S
(Exercise: 1 star \(listcell_fold\)) S
( ) S
( *\)) S
LHL
(Lemma) S
( ) S
(listcell_fold) S
(: ) S
[[(?)false] ] RLC
( ) S
(key kp count p' p) S
(,) S
LHL
(  cstring Tsh key kp * data_at Tsh tcell \(kp, \(Vint \(Int.repr count\), p'\)\) p * malloc_token Tsh t) S
SL
(cell p) S
LHL
(         |-- list_cell key count p' p.) S
LHL
(Proof) S
(.) S
LHL
(  ) S
(intros) S
(.) S
LHL
(  ) S
(unfold) S
( list_cell.) S
LHL
(  ) S
(Exists kp.) S
LHL
(  ) S
(entailer!.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.545 0.133 0.322 FG
(\(** [] *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.627 0.125 0.941 FG
(Fixpoint) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(listrep) S
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(sigma) S
0.000 0.000 0.000 FG
(: list \(string * Z\)\) \() S
0.627 0.322 0.176 FG
(x) S
0.000 0.000 0.000 FG
(: val\) : mpred :=) S
LHL
( ) S
0.133 0.545 0.133 FG
(match) S
0.000 0.000 0.000 FG
( sigma ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
LHL
( | \(s,c\)::hs ) S
[[(?)false] ] RLC
( EX y: val, list_cell s c y x * listrep hs y) S
LHL
( | nil ) S
[[(?)false] ] RLC
LHL
(    !! \(x = nullval\) && emp) S
LHL
( ) S
0.133 0.545 0.133 FG
(end) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.545 0.133 0.322 FG
(\(** **** ) S
(Exercise: 2 stars \(listrep_hints\)) S
(  *\)) S
0.000 0.000 0.000 FG
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(listrep_local_prop) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(sigma p) S
0.000 0.000 0.000 FG
(, listrep sigma p |--) S
LHL
(        !! \(is_pointer_or_null p  ) S
[[(?)false] ] RLC
( \(p=nullval ) S
[[(?)false] ] RLC
( sigma=nil\)\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
( sigma.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(induction) S
0.000 0.000 0.000 FG
( sigma ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [| [hkey hcount] tl].) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(sigma is nil ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    entailer!.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(split) S
0.000 0.000 0.000 FG
(; ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(sigma is \(hkey, hcount\) :: tl ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
( p'.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    entailer.) S
LHL
(    saturate_local.) S
LHL
(    entailer!.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(split) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(subst) S
0.000 0.000 0.000 FG
( p'.) S
LHL
(      ) S
1.000 0.000 0.000 FG
(contradiction) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(inversion) S
0.000 0.000 0.000 FG
( H) S
(0) S
(.) S
LHL
(    }) S
LHL
(  }) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Hint Resolve) S
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(listrep_local_prop) S
0.000 0.000 0.000 FG
( : saturate_local.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(listrep_valid_pointer) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(sigma p) S
0.000 0.000 0.000 FG
(,) S
LHL
(   listrep sigma p |-- valid_pointer p.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
( sigma.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(induction) S
0.000 0.000 0.000 FG
( sigma ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [| [hkey hcount] tl].) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(sigma is nil ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    entailer!.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(sigma is \(hkey, hcount\) :: tl ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
( p'.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    entailer.) S
LHL
(  }) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Hint Resolve) S
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(listrep_valid_pointer) S
0.000 0.000 0.000 FG
( : valid_pointer.) S
LHL
0.545 0.133 0.322 FG
(\(** [] *\)) S
0.000 0.000 0.000 FG
EndPage
EndDSCPage
EndSheet

%%Page: 3 3
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 144 def
/PageNumber 3 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
144 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(listrep_fold) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(key count p' p al) S
0.000 0.000 0.000 FG
(,) S
LHL
(  list_cell key count p' p * listrep al p' |-- listrep \(\(key,count\)::al\) p.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(. ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(. ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(. Exists p'. cancel. ) S
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(listrep_fold_nil) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( key count \() S
0.627 0.322 0.176 FG
(p) S
0.000 0.000 0.000 FG
(: val\),) S
LHL
(  list_cell key count nullval p |-- listrep \(\(key,count\)::nil\) p.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(. ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(  Exists nullval.) S
LHL
(  entailer!.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Definition) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(listboxrep) S
0.000 0.000 0.000 FG
( al r :=) S
LHL
( EX p:val, data_at Tsh \(tptr tcell\) p r * listrep al p.) S
PHL
LHL
0.627 0.125 0.941 FG
(Definition) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(uncurry) S
0.000 0.000 0.000 FG
( {A B C} \() S
0.627 0.322 0.176 FG
(f) S
0.000 0.000 0.000 FG
(: A ) S
[[(?)false] ] RLC
( B ) S
[[(?)false] ] RLC
( C\) \() S
0.627 0.322 0.176 FG
(xy) S
0.000 0.000 0.000 FG
(: A*B\) : C :=) S
LHL
(  f \(fst xy\) \(snd xy\).) S
PHL
LHL
0.627 0.125 0.941 FG
(Definition) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(hashtable_rep) S
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(contents) S
0.000 0.000 0.000 FG
(: hashtable_contents\) \() S
0.627 0.322 0.176 FG
(p) S
0.000 0.000 0.000 FG
(: val\) : mpred :=) S
LHL
(  EX bl: list \(list \(string * Z\) * val\),) S
LHL
(    !! \(contents = map fst bl\) &&) S
LHL
(    malloc_token Tsh thashtable p *) S
LHL
(    field_at Tsh thashtable [StructField _buckets] \(map snd bl\) p) S
LHL
(    ) S
0.227 0.373 0.804 FG
(*) S
0.000 0.000 0.000 FG
( iter_sepcon \(uncurry listrep\) bl.) S
PHL
PHL
LHL
0.545 0.133 0.322 FG
(\(** **** ) S
(Exercise: 2 stars \(hashtable_rep_hints\)) S
(  *\)) S
0.000 0.000 0.000 FG
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(hashtable_rep_local_facts) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(contents p) S
0.000 0.000 0.000 FG
(,) S
LHL
( hashtable_rep contents p |-- !! \(isptr p ) S
[[(?)false] ] RLC
( Zlength contents = N\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_rep.) S
LHL
(  entailer.) S
LHL
(  saturate_local.) S
LHL
(  hint.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(autorewrite) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
( sublist.) S
LHL
(  entailer!.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( N_eq.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(inversion) S
0.000 0.000 0.000 FG
( H) S
(1) S
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( unfold_reptype ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(2) S
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(2) S
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_map ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(2) S
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Hint Resolve) S
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(hashtable_rep_local_facts) S
0.000 0.000 0.000 FG
( : saturate_local.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(hashtable_rep_valid_pointer) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(contents p) S
0.000 0.000 0.000 FG
(,) S
LHL
( hashtable_rep contents p |-- valid_pointer p.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_rep.) S
LHL
(  entailer.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
PHL
LHL
0.627 0.125 0.941 FG
(Hint Resolve) S
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(hashtable_rep_valid_pointer) S
0.000 0.000 0.000 FG
( : valid_pointer.) S
LHL
0.545 0.133 0.322 FG
(\(** [] *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.698 0.133 0.133 FG
(\(* ) S
(----------------------------------------------------------------- ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
0.545 0.133 0.322 FG
(\(** *** ) S
/f2 F
(Function specifications for hash table) S
/f0 F
( *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.627 0.125 0.941 FG
(Definition) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(new_table_spec) S
0.000 0.000 0.000 FG
( : ident * funspec :=) S
LHL
( DECLARE _new_table) S
LHL
( WITH u: unit, gv: globals) S
LHL
( PRE [ ]) S
LHL
(   PROP\(\)) S
LHL
(   LOCAL\(gvars gv\)) S
LHL
(   SEP\(mem_mgr gv\)) S
LHL
( POST [ tptr thashtable ]) S
EndPage
EndDSCPage
EndSheet

%%Page: 4 4
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 216 def
/PageNumber 4 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
216 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(   EX p:val, PROP\(\)) S
LHL
(      LOCAL\(temp ret_temp p\)) S
LHL
(      SEP\(hashtable_rep empty_table p\).) S
PHL
LHL
0.627 0.125 0.941 FG
(Definition) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(new_cell_spec) S
0.000 0.000 0.000 FG
( : ident * funspec :=) S
LHL
( DECLARE _new_cell) S
LHL
( WITH sh: share, s: val, key: string, count: Z, next: val, gv: globals) S
LHL
( PRE [ _key OF tptr tschar, _count OF tint, _next OF tptr tcell ]) S
LHL
(   PROP\(readable_share sh; Zlength key < Int.max_signed\)) S
LHL
(   LOCAL\(temp _key s; temp _count \(Vint \(Int.repr count\)\); temp _next next; gvars gv\)) S
LHL
(   SEP\(mem_mgr gv; cstring sh key s\)) S
LHL
( POST [ tptr tcell ]) S
LHL
(   EX p:val, PROP\(\)) S
LHL
(      LOCAL\(temp ret_temp p\)) S
LHL
(      SEP\(list_cell key count next p; cstring sh key s\).) S
PHL
LHL
0.627 0.125 0.941 FG
(Definition) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(get_spec) S
0.000 0.000 0.000 FG
( : ident * funspec :=) S
LHL
( DECLARE _get) S
LHL
( WITH sh: share, p: val, contents: hashtable_contents, s: val, sigma : string) S
LHL
( PRE [ _table OF tptr \(Tstruct _hashtable noattr\), _s OF tptr tschar ]) S
LHL
(    PROP \(readable_share sh; Zlength sigma < Int.max_signed\)) S
LHL
(    LOCAL \(temp _table p; temp _s s\)) S
LHL
(    SEP \(hashtable_rep contents p; cstring sh sigma s\)) S
LHL
( POST [ tuint ]) S
LHL
(      PROP \( \) LOCAL \(temp ret_temp \(Vint \(Int.repr \(hashtable_get sigma contents\)\)\)\)) S
LHL
(      SEP \(hashtable_rep contents p; cstring sh sigma s\).) S
PHL
LHL
0.627 0.125 0.941 FG
(Definition) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(incr_list_spec) S
0.000 0.000 0.000 FG
( : ident * funspec :=) S
LHL
( DECLARE _incr_list) S
LHL
( WITH sh: share, r) S
(0) S
(: val, al: list \(string * Z\), s: val, sigma : string) S
LHL
( PRE [ _r) S
(0) S
( OF tptr \(tptr tcell\), _s OF tptr tschar ]) S
LHL
(    PROP \(readable_share sh; Zlength sigma < Int.max_signed; list_get sigma al < Int.max_unsigned) S
SL
(\)) S
LHL
(    LOCAL \(temp _r) S
(0) S
( r) S
(0) S
(; temp _s s\)) S
LHL
(    SEP \(listboxrep al r) S
(0) S
(; cstring sh sigma s\)) S
LHL
( POST [ tvoid ]) S
LHL
(      PROP \( \) LOCAL \(\)) S
LHL
(      SEP \(listboxrep \(list_incr sigma al\) r) S
(0) S
(; cstring sh sigma s\).) S
PHL
LHL
0.627 0.125 0.941 FG
(Definition) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(incr_spec) S
0.000 0.000 0.000 FG
( : ident * funspec :=) S
LHL
( DECLARE _incr) S
LHL
( WITH sh: share, p: val, contents: hashtable_contents, s: val, sigma : string) S
LHL
( PRE [ _table OF tptr \(Tstruct _hashtable noattr\), _s OF tptr tschar ]) S
LHL
(    PROP \(readable_share sh; Zlength sigma < Int.max_signed;) S
/f1 F
1.000 1.000 0.000 FG
( ) S
/f0 F
0.000 0.000 0.000 FG
LHL
(          hashtable_get sigma contents < Int.max_unsigned\)) S
LHL
(    LOCAL \(temp _table p; temp _s s\)) S
LHL
(    SEP \(hashtable_rep contents p; cstring sh sigma s\)) S
LHL
( POST [ tvoid ]) S
LHL
(      PROP \( \) LOCAL \(\)) S
LHL
(      SEP \(hashtable_rep \(hashtable_incr sigma  contents\) p; cstring sh sigma s\).) S
PHL
LHL
0.545 0.133 0.322 FG
(\(**  Putting all the funspecs together *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.627 0.125 0.941 FG
(Definition) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(Gprog) S
0.000 0.000 0.000 FG
( : funspecs :=) S
LHL
(        ) S
/f1 F
0.282 0.239 0.545 FG
(ltac) S
/f0 F
0.000 0.000 0.000 FG
(:\(with_library prog [) S
LHL
(                   strcmp_spec; strcpy_spec; strlen_spec; hash_spec;) S
LHL
(                   new_cell_spec; copy_string_spec; get_spec; incr_spec;) S
LHL
(                   incr_list_spec) S
LHL
( ]\).) S
PHL
LHL
0.698 0.133 0.133 FG
(\(* ) S
(================================================================= ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
0.545 0.133 0.322 FG
(\(** ** ) S
/f1 F
(Proofs of the function bodies) S
/f0 F
( *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.545 0.133 0.322 FG
(\(** This lemma demonstrates how to handle "strings", that is,) S
LHL
(   null-terminated arrays of characters. *\)) S
0.000 0.000 0.000 FG
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(demonstrate_cstring) S
(1) S
0.000 0.000 0.000 FG
(:) S
LHL
( ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(i contents) S
0.000 0.000 0.000 FG
(,) S
LHL
(   ~ In Byte.zero contents ) S
[[(?)false] ] RLC
LHL
(   Znth i \(contents ++ [Byte.zero]\) ) S
[[(?)false] ] RLC
( Byte.zero  ) S
[[(?)false] ] RLC
LHL
(   0 ) S
[[(?)false] ] RLC
( i ) S
[[(?)false] ] RLC
( Zlength contents ) S
[[(?)false] ] RLC
LHL
(   0 ) S
[[(?)false] ] RLC
( i + 1 < Zlength \(contents ++ [Byte.zero]\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
EndPage
EndDSCPage
EndSheet

%%Page: 5 5
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 287 def
/PageNumber 5 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
288 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
0.545 0.133 0.322 FG
(\(** When processing a C null-terminated string, you will want to) S
LHL
(   maintain the three kinds of assumptions above the line.) S
LHL
(   A string is an array of characters with three parts:) S
LHL
(   - The "contents" of the string, none of which is the '\\0' character;) S
LHL
(   - The null termination character, equal to Byte.zero;) S
LHL
(   - the remaining garbage in the array, after the null.) S
LHL
(  The first assumption above the line says that none of the) S
LHL
(  contents is the null character.) S
LHL
(  Now suppose we are in a loop where variable [_i] \(with value [i]\)) S
LHL
(  is traversing the array.  We expect that loop to go up to but) S
LHL
(  no farther than the null character, that is, one past the contents.) S
LHL
(  Therefore [0 ) S
[[(?)false] ] RLC
( i ) S
[[(?)false] ] RLC
( Zlength contents].) S
LHL
(  Furthermore, suppose we have determined \(by an if-test\) that) S
LHL
(  s[i] is not zero, then we have the hypothesis H0 above.) S
PHL
LHL
(  The [cstring] tactic processes all three of them to conclude) S
LHL
(  that [i < Zlength contents]. *\)) S
0.000 0.000 0.000 FG
LHL
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(H) S
(7) S
0.000 0.000 0.000 FG
(: i < Zlength contents\) ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( cstring.) S
PHL
LHL
0.545 0.133 0.322 FG
(\(** But actually, [cstring] tactic will prove any rep_omega consequence) S
LHL
(   of that fact.  For example: *\)) S
0.000 0.000 0.000 FG
LHL
0.000 0.000 0.545 FG
(clear) S
0.000 0.000 0.000 FG
( H) S
(7) S
(.) S
LHL
0.000 0.000 0.545 FG
(autorewrite) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
( sublist.) S
LHL
(cstring.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
LHL
0.545 0.133 0.322 FG
(\(** Don't apply [demonstrate_cstring) S
(1) S
(] in the body_hash proof,) S
LHL
(    instead, use [autorewrite with sublist] and [cstring] directly,) S
LHL
(    where appropriate. *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(demonstrate_cstring) S
(2) S
0.000 0.000 0.000 FG
(:) S
LHL
( ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(i contents) S
0.000 0.000 0.000 FG
(,) S
LHL
(   ~ In Byte.zero contents ) S
[[(?)false] ] RLC
LHL
(   Znth i \(contents ++ [Byte.zero]\) = Byte.zero  ) S
[[(?)false] ] RLC
LHL
(   0 ) S
[[(?)false] ] RLC
( i ) S
[[(?)false] ] RLC
( Zlength contents ) S
[[(?)false] ] RLC
LHL
(   i = Zlength contents.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
0.545 0.133 0.322 FG
(\(** Here is another demonstration.  When your loop on the) S
LHL
(   string contents reaches the end, so that s[i] is the zero byte,) S
LHL
(   you'll have the an assumption like [H) S
(0) S
(] above the line.) S
LHL
(   The [cstring] tactic handles this case too, to prove) S
LHL
(   [i = Zlength contents].   *\)) S
0.000 0.000 0.000 FG
LHL
(cstring.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.545 0.133 0.322 FG
(\(** **** ) S
(Exercise: 3 stars \(body_hash\)) S
(  *\)) S
0.000 0.000 0.000 FG
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(body_hash) S
0.000 0.000 0.000 FG
(: semax_body Vprog Gprog f_hash hash_spec.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(start_function.) S
LHL
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( cstring,hashfun ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
0.545 0.133 0.322 FG
(\(** Before doing this proof, study some of the proofs in VST/progs/verif_strlib.v.) S
LHL
(  In the PROP part of your loop invariant, you'll want to maintain [0 ) S
[[(?)false] ] RLC
( i ) S
[[(?)false] ] RLC
( Zlength contents].) S
PHL
LHL
(  In the LOCAL part of your loop invariant, try to use something like) S
PHL
LHL
(    temp _c \(Vbyte \(Znth i \(contents ++ [Byte.zero]\)\)) S
PHL
LHL
(  instead of) S
PHL
LHL
(    temp _c \(Znth 0 \(map Vbyte \(...\)\)\)) S
PHL
LHL
(  The reason is that [temp _c \(Vint x\)] or [temp _c \(Vbyte y\)] is much easier) S
LHL
(  for Floyd to handle than [temp _c X]) S
LHL
(  where X is a general formula of type [val].) S
PHL
LHL
(  Late in the proof of the loop body, the lemma [hashfun_snoc] will be useful. *\)) S
0.000 0.000 0.000 FG
LHL
(forward.) S
LHL
(forward.) S
LHL
(forward.) S
LHL
(entailer!.) S
LHL
(forward_while) S
EndPage
EndDSCPage
EndSheet

%%Page: 6 6
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 359 def
/PageNumber 6 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
360 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  \() S
0.627 0.322 0.176 FG
(EX i) S
0.000 0.000 0.000 FG
(:Z,) S
LHL
(    PROP \(0 ) S
[[(?)false] ] RLC
( i < \(Zlength contents + 1\)\)) S
LHL
(    LOCAL \(temp _c \(Vbyte \(Znth i \(contents ++ [Byte.zero]\)\)\);) S
LHL
(           temp _i \(Vint \(Int.repr i\)\);) S
LHL
(           temp _n \(Vint \(Int.repr \(hashfun_aux 0 \(sublist 0 i contents\)\)\)\);) S
LHL
(           temp _s s\)) S
LHL
(    SEP \(!! \(~ In Byte.zero contents\) &&) S
LHL
(                 data_at sh \(tarray tschar \(Zlength contents + 1\)\) \(map Vbyte \(contents ++ [Byte.) S
SL
(zero]\)\) s\)\).) S
LHL
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(Current pre implies invariant. ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(  Exists 0.) S
LHL
(  entailer!.) S
LHL
(}) S
LHL
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(Type Check ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(  entailer!.) S
LHL
(}) S
LHL
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(Now in the loop body. ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(  forward.) S
LHL
(  forward.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(i ) S
[[(?)false] ] RLC
( Zlength contents\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(subst) S
0.000 0.000 0.000 FG
( i.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( HRE.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( app_Znth) S
(2) S
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( HRE.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Z.sub_diag ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( HRE.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( Znth ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( HRE.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( HRE.) S
LHL
(    ) S
1.000 0.000 0.000 FG
(contradiction) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.698 0.133 0.133 FG
(\(* ) S
(Now must prove Zlength contents >= Zlength contents ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(0 ) S
[[(?)false] ] RLC
( i < Zlength contents\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  forward.) S
LHL
(  Exists \(i + 1\).) S
LHL
(  entailer!.) S
LHL
(  f_equal.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( app_Znth) S
(1) S
( ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( \(hashfun_snoc contents 0 0 i\);) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(}) S
LHL
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(At the return ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(  forward.) S
LHL
(  entailer!.) S
LHL
(  f_equal.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(i = Zlength contents\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(~ \(0 ) S
[[(?)false] ] RLC
( i < Zlength contents\)\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( app_Znth) S
(1) S
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( HRE ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(In \(Znth i contents\) contents\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(        ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( Znth_In; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(      }) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( HRE ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(6) S
(.) S
LHL
(      ) S
1.000 0.000 0.000 FG
(contradiction) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  ) S
0.000 0.000 0.545 FG
(subst) S
0.000 0.000 0.000 FG
( i.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sublist_same ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(}) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.545 0.133 0.322 FG
(\(** [] *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.545 0.133 0.322 FG
(\(** **** ) S
(Exercise: 3 stars \(body_new_cell\)) S
(  *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(body_copy_string) S
0.000 0.000 0.000 FG
(: semax_body Vprog Gprog f_copy_string copy_string_spec.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  start_function.) S
LHL
(  forward_call \(sh, sigma, s\). ) S
0.698 0.133 0.133 FG
(\(* ) S
(strlen ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(  forward.) S
EndPage
EndDSCPage
EndSheet

%%Page: 7 7
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 430 def
/PageNumber 7 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
432 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  forward_call \(\(tarray tschar \(Zlength sigma + 1\)\), gv\). ) S
0.698 0.133 0.133 FG
(\(* ) S
(to malloc ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.698 0.133 0.133 FG
(\(* ) S
(Prove Zlength size + 1 in two forms are equal. ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    entailer!.) S
LHL
(    ) S
0.706 0.322 0.804 FG
(repeat) S
0.000 0.000 0.000 FG
( f_equal.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(Int.signed \(Int.repr 1\) = 1\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.698 0.133 0.133 FG
(\(* ) S
(Search \(Int.signed \(Int.repr _\)\).) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( Int.signed_repr.) S
LHL
(      rep_omega.) S
LHL
(    }) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(1) S
(.) S
LHL
(    ) S
0.698 0.133 0.133 FG
(\(* ) S
(Search \(Int64.unsigned \(Int64.repr _\)\). ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(\(Int) S
(64) S
(.unsigned \(Int) S
(64) S
(.repr \(Zlength sigma + 1\)\)\) = \(Zlength sigma + 1\)\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( Int) S
(64) S
(.unsigned_repr.) S
LHL
(      rep_omega.) S
LHL
(    }) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(2) S
(.) S
LHL
(    ) S
0.627 0.125 0.941 FG
(Search) S
0.000 0.000 0.000 FG
( \(Int.signed \(Int.repr _\)\).) S
LHL
(    ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( Int.signed_repr.) S
LHL
(    rep_omega.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.698 0.133 0.133 FG
(\(* ) S
(cstring sh sigma s |-- mem_mgr gv * fold_right_sepcon Frame ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    sep_apply \(create_mem_mgr gv\).) S
LHL
(    entailer!.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    split) S
(3) S
(; ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Z.max_r; rep_omega.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    Intros p.) S
LHL
(    forward_if) S
LHL
(      \(PROP \( \)) S
LHL
(       LOCAL \(temp _p p; temp _s s;gvars gv\)) S
LHL
(       SEP \(mem_mgr gv;) S
LHL
(            malloc_token Ews \(tarray tschar \(Zlength sigma + 1\)\) p;) S
LHL
(            cstring sh sigma s;) S
LHL
(            data_at_ Ews \(tarray tschar \(Zlength sigma + 1\)\) p\)\).) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(change) S
0.000 0.000 0.000 FG
( \(Memory.EqDec_val p nullval\) ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
( \(eq_dec p nullval\).) S
LHL
(      if_tac; entailer!.) S
LHL
(    }) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      forward_call tt. ) S
0.698 0.133 0.133 FG
(\(* ) S
(Call to exit ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      ) S
1.000 0.000 0.000 FG
(contradiction) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( if_false ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(      Intros.) S
LHL
(      forward.  ) S
0.698 0.133 0.133 FG
(\(*  ) S
(/*skip*/;  ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      entailer.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( cstring.) S
LHL
(      entailer!.) S
LHL
(    }) S
LHL
(    ) S
0.698 0.133 0.133 FG
(\(* ) S
(Call to strcpy ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    forward_call \(Ews, sh, p, \(Zlength sigma + 1\), s, sigma\).) S
LHL
(    split) S
(3) S
(; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    forward.) S
LHL
(    Exists p.) S
LHL
(    entailer!.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( cstringn, cstring.) S
LHL
(    entailer!.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(\(Zlength sigma + 1 - \(Zlength sigma + 1\)\) = 0\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      rep_omega.) S
LHL
(    }) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(7) S
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(Z.to_nat 0 = 0%) S
[[(?)false] ] RLC
(\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(8) S
(.) S
EndPage
EndDSCPage
EndSheet

%%Page: 8 8
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 502 def
/PageNumber 8 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
504 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    entailer!.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( app_nil_r.) S
LHL
(    entailer!.) S
LHL
(  }) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(body_new_cell) S
0.000 0.000 0.000 FG
(: semax_body Vprog Gprog f_new_cell new_cell_spec.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  start_function.) S
LHL
(  forward_call \(tcell, gv\). ) S
0.698 0.133 0.133 FG
(\(* ) S
(malloc ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.698 0.133 0.133 FG
(\(* ) S
(preconditions of malloc ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    split) S
(3) S
(; ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(; ) S
0.706 0.322 0.804 FG
(try) S
0.000 0.000 0.000 FG
( rep_omega;) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  Intros p.) S
LHL
(  forward_if) S
LHL
(    \(PROP \( \)) S
LHL
(     LOCAL \(temp _p p; temp _key s; temp _count \(Vint \(Int.repr count\)\); temp _next next; gvars g) S
SL
(v\)) S
LHL
(     SEP \(mem_mgr gv;) S
LHL
(          malloc_token Ews tcell p;) S
LHL
(          data_at_ Ews tcell p;) S
LHL
(          cstring sh key s\)\).) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* *\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
(  \(Memory.EqDec_val p nullval\);) S
LHL
(    if_tac;entailer!.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    forward_call tt.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(inversion) S
0.000 0.000 0.000 FG
( H) S
(1) S
(.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( if_false ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    forward.) S
LHL
(    entailer!.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(Call copy_string ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    forward_call \(sh, s, key, gv\).) S
LHL
(    Intros key_copy.) S
LHL
(    forward.) S
LHL
(    forward.) S
LHL
(    forward.) S
LHL
(    forward.) S
LHL
(    Exists p.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( list_cell.) S
LHL
(    Exists key_copy.) S
LHL
(    entailer!.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( tcell.) S
LHL
(    entailer!.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
PHL
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.545 0.133 0.322 FG
(\(** [] *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.698 0.133 0.133 FG
(\(* ) S
(================================================================= ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
0.545 0.133 0.322 FG
(\(** ** ) S
/f1 F
(Auxiliary lemmas about data-structure predicates) S
/f0 F
( *\)) S
0.000 0.000 0.000 FG
PHL
PHL
LHL
0.545 0.133 0.322 FG
(\(** **** ) S
(Exercise: 2 stars \(iter_sepcon_hints\)) S
(  *\)) S
0.000 0.000 0.000 FG
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(iter_sepcon_listrep_local_facts) S
0.000 0.000 0.000 FG
(:) S
LHL
( ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(bl) S
0.000 0.000 0.000 FG
(, iter_sepcon \(uncurry listrep\) bl) S
LHL
(                    |-- !! Forall is_pointer_or_null \(map snd bl\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
0.698 0.133 0.133 FG
(\(* ) S
(Hint: use [induction] and [sep_apply]. ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(induction) S
0.000 0.000 0.000 FG
( bl ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [| h t].) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(bl is nil ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    entailer!.) S
EndPage
EndDSCPage
EndSheet

%%Page: 9 9
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 573 def
/PageNumber 9 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
576 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(bl is h :: t ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( h ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [hc hp].) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    sep_apply IHt.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( uncurry ) S
0.133 0.545 0.133 FG
(at) S
0.000 0.000 0.000 FG
( 2.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    entailer!.) S
LHL
(  }) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
PHL
LHL
0.627 0.125 0.941 FG
(Hint Resolve) S
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(iter_sepcon_listrep_local_facts) S
0.000 0.000 0.000 FG
( : saturate_local.) S
LHL
0.545 0.133 0.322 FG
(\(** [] *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.545 0.133 0.322 FG
(\(** **** ) S
(Exercise: 2 stars \(iter_sepcon_split3\)) S
(  *\)) S
0.000 0.000 0.000 FG
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(iter_sepcon_split) S
(3) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( {A}{) S
0.627 0.322 0.176 FG
(d) S
0.000 0.000 0.000 FG
(: Inhabitant A} \() S
0.627 0.322 0.176 FG
(i) S
0.000 0.000 0.000 FG
(: Z\) \() S
0.627 0.322 0.176 FG
(al) S
0.000 0.000 0.000 FG
(: list A\) \() S
0.627 0.322 0.176 FG
(f) S
0.000 0.000 0.000 FG
(: A ) S
[[(?)false] ] RLC
( mpred\),) S
LHL
(   0 ) S
[[(?)false] ] RLC
( i < Zlength al   ) S
[[(?)false] ] RLC
LHL
(  iter_sepcon f al =) S
LHL
(  iter_sepcon f \(sublist 0 i al\) * f \(Znth i al\) * iter_sepcon f \(sublist \(i+1\) \(Zlength al\) al\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( \(sublist_same 0 \(Zlength al\) al\) ) S
0.133 0.545 0.133 FG
(at) S
0.000 0.000 0.000 FG
( 1 ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
0.698 0.133 0.133 FG
(\(* ) S
(Hint: [rewrite \(sublist_split LO MID HI\) by omega], where you choose values for LO MID HI.) S
LHL
(  Also useful:  [rewrite sublist_len) S
(_1) S
(]    and    [iter_sepcon_app].) S
LHL
(*\)) S
0.000 0.000 0.000 FG
LHL
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(sublist_split 0 i \(Zlength al\)\) ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(sublist_split i \(i+1\) \(Zlength al\)\) ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(sublist_len) S
(_1) S
( i\); ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( iter_sepcon_app.) S
LHL
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( iter_sepcon_app.) S
LHL
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(remember \(iter_sepcon f \(sublist 0 i al\)\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( P) S
(1) S
(.) S
LHL
(remember \(iter_sepcon f \(sublist \(i + 1\) \(Zlength al\) al\)\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( P) S
(3) S
(.) S
LHL
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sepcon_emp.) S
LHL
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sepcon_assoc.) S
LHL
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.545 0.133 0.322 FG
(\(** [] *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.545 0.133 0.322 FG
(\(** **** ) S
(Exercise: 3 stars \(body_new_table\)) S
(  *\)) S
0.000 0.000 0.000 FG
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(body_new_table_helper) S
0.000 0.000 0.000 FG
(:) S
LHL
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(This lemma is useful as the very last thing to do in body_new_table ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
( ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(p) S
0.000 0.000 0.000 FG
(,) S
LHL
(  data_at Tsh thashtable \(list_repeat \(Z.to_nat N\) nullval\) p) S
LHL
(  |-- field_at Tsh thashtable [StructField _buckets]) S
LHL
(       \(list_repeat \(Z.to_nat N\) nullval\) p *) S
LHL
(         iter_sepcon \(uncurry listrep\) \(list_repeat \(Z.to_nat N\) \([], nullval\)\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(unfold_data_at 1%) S
[[(?)false] ] RLC
(.) S
LHL
(entailer!.) S
LHL
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(n) S
0.000 0.000 0.000 FG
(: ) S
[[(?)false] ] RLC
(, iter_sepcon \(uncurry listrep\) \(list_repeat n \([], nullval\)\) = emp\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(  ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
( n.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(induction) S
0.000 0.000 0.000 FG
( n ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [|n'].) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(n is 0 ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(n is S n' ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(\() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(nn) S
0.000 0.000 0.000 FG
(: ) S
[[(?)false] ] RLC
(, S nn = 1 + nn\)%) S
[[(?)false] ] RLC
(\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(;) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(1) S
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( list_repeat_app.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( IHn'.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sepcon_emp.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( uncurry.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(autorewrite) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
( norm.) S
EndPage
EndDSCPage
EndSheet

%%Page: 10 10
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 645 def
/PageNumber 10 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
648 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(}) S
LHL
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(H) S
(1) S
( \(Z.to_nat N\)\).) S
LHL
(entailer.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(upd_single_repeat) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(A) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
(Type) S
0.000 0.000 0.000 FG
(\) \() S
0.627 0.322 0.176 FG
(old new) S
0.000 0.000 0.000 FG
(: A\),) S
LHL
(    upd_Znth 0 \(list_repeat \(Z.to_nat 1\) old\) new =) S
LHL
(    \(list_repeat \(Z.to_nat 1\) new\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( upd_Znth.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( Zlength.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sublist_nil.) S
LHL
(  ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(body_new_table) S
0.000 0.000 0.000 FG
(: semax_body Vprog Gprog f_new_table new_table_spec.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
0.545 0.133 0.322 FG
(\(** The loop invariant in this function describes a partially initialized array.) S
LHL
(   The best way to do that is with something like,) S
PHL
LHL
(  data_at Tsh thashtable) S
LHL
(      \(list_repeat \(Z.to_nat i\) nullval ++) S
LHL
(       list_repeat \(Z.to_nat \(N-i\)\) Vundef\)   p.) S
PHL
LHL
(  Then at some point you'll have to prove something about,) S
PHL
LHL
(   data_at Tsh thashtable) S
LHL
(      \(list_repeat \(Z.to_nat \(i + 1\)\) nullval ++) S
LHL
(       list_repeat \(Z.to_nat \(N - \(i + 1\)\)\) Vundef\)   p) S
PHL
LHL
(  In particular, you'll have to split up [list_repeat \(Z.to_nat \(i + 1\)\) nullval]) S
LHL
(   into [list_repeat \(Z.to_nat i\) nullval ++ list_repeat \(Z.to_nat 1\) nullval].) S
LHL
(  The best way to do that is [rewrite ) S
[[(?)false] ] RLC
( list_repeat_app'.]) S
LHL
(*\)) S
0.000 0.000 0.000 FG
LHL
(  start_function.) S
LHL
(  forward_call \(Tstruct _hashtable noattr\).) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(preconditions of malloc ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    split) S
(3) S
(; ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(; ) S
0.706 0.322 0.804 FG
(try) S
0.000 0.000 0.000 FG
( rep_omega;) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  Intros vret.) S
LHL
(  forward_if \(vret ) S
[[(?)false] ] RLC
( nullval\).) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* *\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
(  \(Memory.EqDec_val vret nullval\); entailer!.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    forward_call tt.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(inversion) S
0.000 0.000 0.000 FG
( H) S
(0) S
(.) S
LHL
(  }) S
LHL
(  forward.) S
LHL
(  entailer!.) S
LHL
(  assert_PROP\(vret ) S
[[(?)false] ] RLC
( nullval\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    entailer!.) S
LHL
(  }) S
LHL
(  forward_for_simple_bound) S
LHL
(    109) S
LHL
(    \() S
0.627 0.322 0.176 FG
(EX i) S
0.000 0.000 0.000 FG
(:Z,) S
LHL
(          \(PROP \(vret ) S
[[(?)false] ] RLC
( nullval\)) S
LHL
(           LOCAL \(temp _p vret\)) S
LHL
(           SEP \(malloc_token Tsh \(Tstruct _hashtable noattr\) vret *) S
LHL
(                data_at Tsh thashtable) S
LHL
(                        \(list_repeat \(Z.to_nat i\) nullval ++) S
LHL
(                                     list_repeat \(Z.to_nat \(N-i\)\) Vundef\)) S
LHL
(                        vret\)\)\)%) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
EndPage
EndDSCPage
EndSheet

%%Page: 11 11
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 717 def
/PageNumber 11 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
720 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( pred_dec_false ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    entailer!.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    Intros.) S
LHL
(    forward.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Z2Nat.inj_add ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( list_repeat_app.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(\(N-i\) = 1 + \(N - \(i+1\)\)\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(1) S
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Z2Nat.inj_add; ) S
0.706 0.322 0.804 FG
(try) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( list_repeat_app.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( upd_Znth_app) S
(2) S
(.) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_list_repeat ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(i - i = 0\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(        ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(      }) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(2) S
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( upd_Znth_app) S
(1) S
(.) S
LHL
(      remember \(list_repeat \(Z.to_nat i\) nullval\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( part) S
(1) S
(.) S
LHL
(      remember \(list_repeat \(Z.to_nat \(N - \(i + 1\)\)\) Vundef\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( part) S
(3) S
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( upd_single_repeat.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(Vint \(Int.repr 0\) = nullval\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(        ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( nullval.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( Archi.ptr) S
(64) S
(.) S
LHL
(        ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(      }) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(3) S
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( app_assoc.) S
LHL
(      entailer!.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_list_repeat; ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_list_repeat ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_app.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_list_repeat ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_list_repeat.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( N_eq ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(      ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( N_eq ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(      ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( N_eq ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(      ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(At return. ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( N_eq.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Z.sub_diag.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( app_nil_end.) S
LHL
(    forward.) S
LHL
(    Exists vret.) S
LHL
(    entailer!.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_rep.) S
LHL
(    simplify_value_fits ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(2) S
(.) S
LHL
(    Exists \(list_repeat \(Z.to_nat N\) \(\() S
0.000 0.545 0.545 FG
(@) S
0.000 0.000 0.000 FG
(nil \(string * Z\)\), nullval\)\).) S
LHL
(    entailer!.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( thashtable.) S
LHL
(    cancel.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(\(map snd \(list_repeat \(Z.to_nat N\) \(\() S
0.000 0.545 0.545 FG
(@) S
0.000 0.000 0.000 FG
(nil \(string * Z\), nullval\)\)\)\) = \(list_repeat \(Z.) S
SL
(to_nat N\) nullval\)\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( map_list_repeat.) S
LHL
(      ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(4) S
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( body_new_table_helper.) S
EndPage
EndDSCPage
EndSheet

%%Page: 12 12
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 788 def
/PageNumber 12 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
792 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  }) S
PHL
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.545 0.133 0.322 FG
(\(** [] *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.545 0.133 0.322 FG
(\(** **** ) S
(Exercise: 3 stars \(body_get\)) S
(  *\)) S
0.000 0.000 0.000 FG
LHL
0.545 0.133 0.322 FG
(\(** The [get] function traverses a linked list.  We will reason about linked-list traversal) S
LHL
(   in separation logic using "Magic Wand as Frame" http://www.cs.princeton.edu/~appel/papers/wand) S
SL
(-frame.pdf) S
LHL
(   When the loop is partway down the linked list, we can view the original list) S
LHL
(   up to the current position as a "linked-list data structure with a hole";) S
LHL
(   and the current position points to a linked-list data structure that fills the hole.) S
LHL
(   The "data-structure-with-a-hole" we reason about with separating implication,) S
LHL
(    called "magic wand":   \(hole -* data-structure\)) S
LHL
(    which says, if you can conjoin this data-structure-with-a-hole) S
LHL
(    with something-to-fill-the-hole, then you get the original data structure:) S
LHL
(     hole * \(hole -* data-structure\) |--   data-structure.) S
LHL
(    The lemma [listrep_traverse] is useful in moving one linked-list cell) S
LHL
(    out of the hole and into the data-structure-with-a-\(smaller\)-hole.) S
LHL
(*\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(listrep_traverse) S
0.000 0.000 0.000 FG
(:  ) S
0.698 0.133 0.133 FG
(\(* ) S
(useful in body_get lemma) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(key count p' p) S
0.000 0.000 0.000 FG
(,) S
LHL
(  list_cell key count p' p |--) S
LHL
(  ALL al:list \(string * Z\), listrep al p' -* \() S
0.627 0.322 0.176 FG
(EX y) S
0.000 0.000 0.000 FG
( : val, list_cell key count y p * listrep al y\)) S
SL
(.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( allp_right. ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
( al.) S
LHL
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( wand_sepcon_adjoint.) S
LHL
(Exists p'.) S
LHL
(entailer!.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(is_pointer_or_null_expand) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(p) S
0.000 0.000 0.000 FG
(: val, is_pointer_or_null p ) S
[[(?)false] ] RLC
( isptr p ) S
[[(?)false] ] RLC
( p = nullval.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( p.) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(Vundef ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *; ) S
0.000 0.000 0.545 FG
(inversion) S
0.000 0.000 0.000 FG
( H.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(Vint ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(right) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(subst) S
0.000 0.000 0.000 FG
( i.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( nullval.) S
LHL
(    ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(Vlong ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *; ) S
0.000 0.000 0.545 FG
(inversion) S
0.000 0.000 0.000 FG
( H.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(Vfloat ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *; ) S
0.000 0.000 0.545 FG
(inversion) S
0.000 0.000 0.000 FG
( H.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(Vsingle ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *; ) S
0.000 0.000 0.545 FG
(inversion) S
0.000 0.000 0.000 FG
( H.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(Vptr ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(left) S
0.000 0.000 0.000 FG
(;) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Print) S
0.000 0.000 0.000 FG
( val.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(isptr_expand) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(p) S
0.000 0.000 0.000 FG
(: val, isptr p ) S
[[(?)false] ] RLC
( ) S
0.000 0.000 0.545 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(b) S
0.000 0.000 0.000 FG
( : block\) \() S
0.627 0.322 0.176 FG
(o) S
0.000 0.000 0.000 FG
(: ptrofs\), p = Vptr b o.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( p eqn: ?; ) S
0.706 0.322 0.804 FG
(try) S
0.000 0.000 0.000 FG
( \() S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H; ) S
0.000 0.000 0.545 FG
(inversion) S
0.000 0.000 0.000 FG
( H\).) S
LHL
(  ) S
0.000 0.000 0.545 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( b.) S
EndPage
EndDSCPage
EndSheet

%%Page: 13 13
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 858 def
/PageNumber 13 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
864 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  ) S
0.000 0.000 0.545 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( i.) S
LHL
(  ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(wand_cancel) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(P Q R) S
0.000 0.000 0.000 FG
(,) S
LHL
(    P * \(P * Q -* R\) |-- Q -* R.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( wand_sepcon_adjoint.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sepcon_assoc.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(sepcon_comm \(P * Q -* R\) Q\).) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( sepcon_assoc.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( modus_ponens_wand.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(wand_cancel') S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(P Q R) S
0.000 0.000 0.000 FG
(,) S
LHL
(    Q * P * \(P * Q -* R\) |-- Q * \(Q -* R\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  sep_apply \(wand_cancel P Q R\).) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sepcon_comm.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(emp_wand) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(P) S
0.000 0.000 0.000 FG
(,) S
LHL
(    \(emp -* P\) = P.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( pred_ext.) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(emp -* P |-- P ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( \(sepcon_emp \(emp -* P\)\).) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sepcon_comm.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( modus_ponens_wand.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(P |-- emp -* P ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( wand_sepcon_adjoint.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sepcon_emp.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(exp_eq) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(A) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
(Type) S
0.000 0.000 0.000 FG
(\) \() S
0.627 0.322 0.176 FG
(P) S
0.000 0.000 0.000 FG
(: A ) S
[[(?)false] ] RLC
( mpred\),) S
LHL
(    \() S
0.627 0.322 0.176 FG
(EX y) S
0.000 0.000 0.000 FG
(: A, P y\) = \() S
0.627 0.322 0.176 FG
(EX y') S
0.000 0.000 0.000 FG
(:A, P y'\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(sepcon_exp) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(A) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
(Type) S
0.000 0.000 0.000 FG
(\) \() S
0.627 0.322 0.176 FG
(y) S
0.000 0.000 0.000 FG
(: A\) \() S
0.627 0.322 0.176 FG
(P Q) S
0.000 0.000 0.000 FG
(: A ) S
[[(?)false] ] RLC
( mpred\),) S
LHL
(    \(P y\) * \(Q y\) |--  \() S
0.627 0.322 0.176 FG
(EX y') S
0.000 0.000 0.000 FG
(:A, \(P y'\) * \(Q y'\)\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( \(exp_right y\).) S
LHL
(  ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(sepcon_exp') S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(A) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
(Type) S
0.000 0.000 0.000 FG
(\) \() S
0.627 0.322 0.176 FG
(y) S
0.000 0.000 0.000 FG
(: A\) \() S
0.627 0.322 0.176 FG
(P) S
0.000 0.000 0.000 FG
(: A ) S
[[(?)false] ] RLC
( mpred\),) S
LHL
(    \(P y\) |--  \() S
0.627 0.322 0.176 FG
(EX y') S
0.000 0.000 0.000 FG
(:A, \(P y'\)\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( \(exp_right y\).) S
LHL
(  ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.698 0.133 0.133 FG
(\(*) S
LHL
(Lemma wand_ex_intro:) S
LHL
(  forall \(A: Type\) \(y: A\) \(P: A -> mpred\) \(Q: mpred\),) S
EndPage
EndDSCPage
EndSheet

%%Page: 14 14
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 930 def
/PageNumber 14 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
936 BeginPage
/f0 F
false BG
0.698 0.133 0.133 FG
(    \(EX y':A, \(P y'\)\) -* Q |--  \(\(P y\) -* Q\).) S
LHL
(Proof.) S
LHL
(  intros.) S
LHL
(  remember \(EX y' : A, P y'\) as x'.) S
LHL
(  rewrite <- \(wand_sepcon_adjoint) S
LHL
(Qed.) S
LHL
(*\)) S
0.000 0.000 0.000 FG
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(wand_cancel_ex) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(A) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
(Type) S
0.000 0.000 0.000 FG
(\) \() S
0.627 0.322 0.176 FG
(y) S
0.000 0.000 0.000 FG
(: A\) \() S
0.627 0.322 0.176 FG
(P Q) S
0.000 0.000 0.000 FG
(: A ) S
[[(?)false] ] RLC
( mpred\) \() S
0.627 0.322 0.176 FG
(R) S
0.000 0.000 0.000 FG
(: mpred\),) S
LHL
(    \(P y\) * \(\() S
0.627 0.322 0.176 FG
(EX y') S
0.000 0.000 0.000 FG
(:A, \(\(P y'\) * \(Q y'\)\)\) -* R\) |-- \(Q y\) -* R.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( wand_sepcon_adjoint.) S
LHL
(  sep_apply \(sepcon_exp A y P Q\).) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( wand_frame_elim.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(wand_cancel_ex') S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(A) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
(Type) S
0.000 0.000 0.000 FG
(\) \() S
0.627 0.322 0.176 FG
(y) S
0.000 0.000 0.000 FG
(: A\) \() S
0.627 0.322 0.176 FG
(P Q) S
0.000 0.000 0.000 FG
(: A ) S
[[(?)false] ] RLC
( mpred\) \() S
0.627 0.322 0.176 FG
(R) S
0.000 0.000 0.000 FG
(: mpred\),) S
LHL
(    \(Q y\) * \(P y\) * \(\() S
0.627 0.322 0.176 FG
(EX y') S
0.000 0.000 0.000 FG
(:A, \(\(P y'\) * \(Q y'\)\)\) -* R\) |-- R.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sepcon_assoc.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sepcon_comm.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( wand_sepcon_adjoint.) S
LHL
(  sep_apply \(wand_cancel_ex A y P Q R\).) S
LHL
(  ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(body_get) S
0.000 0.000 0.000 FG
(: semax_body Vprog Gprog f_get get_spec.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(start_function.) S
LHL
0.000 0.000 0.545 FG
(rename) S
0.000 0.000 0.000 FG
( p ) S
0.133 0.545 0.133 FG
(into) S
0.000 0.000 0.000 FG
( table.) S
LHL
0.000 0.000 0.545 FG
(pose) S
( proof) S
0.000 0.000 0.000 FG
( \(hashfun_inrange sigma\).) S
LHL
(forward_call \(s, sigma\). ) S
0.698 0.133 0.133 FG
(\(* ) S
(h = hash\(s\) ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(forward.) S
LHL
(remember \(\(hashfun sigma\) mod 109\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( bk.) S
LHL
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_rep.) S
LHL
(Intros bl.) S
LHL
(remember \(map snd bl\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( buckets.) S
LHL
(forward.) S
PHL
LHL
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(0 ) S
[[(?)false] ] RLC
( bk < 109\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Heqbk.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( \(Z.mod_pos_bound \(hashfun sigma\) 109\); ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(}) S
LHL
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(  entailer!.) S
LHL
(}) S
LHL
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(  entailer!.) S
LHL
(  simplify_value_fits ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(3) S
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( H) S
(3) S
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(autorewrite) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
( sublist ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *|-.) S
LHL
(  remember \(\(hashfun sigma\) mod 109\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( bk.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(0 ) S
[[(?)false] ] RLC
( bk < Zlength bl\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(0) S
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Heqbk.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( \(Z.mod_pos_bound \(hashfun sigma\) 109\); ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Znth_map ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Forall_map ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(4) S
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( Forall_Znth; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(}) S
LHL
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( Heqbk.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(autorewrite) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
( norm.) S
LHL
(  deadvars!.) S
LHL
(  assert_PROP\(Zlength bl = 109\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    entailer!.) S
LHL
(    simplify_value_fits ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(4) S
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( H) S
(4) S
(.) S
EndPage
EndDSCPage
EndSheet

%%Page: 15 15
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1002 def
/PageNumber 15 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1008 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    ) S
0.000 0.000 0.545 FG
(autorewrite) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
( sublist ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *|-.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(0 ) S
[[(?)false] ] RLC
( bk < Zlength bl\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(1) S
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Heqbk.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( \(Z.mod_pos_bound \(hashfun sigma\) 109\); ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(iter_sepcon_split) S
(3) S
( bk bl \(uncurry listrep\) H) S
(2) S
(\).) S
PHL
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( uncurry ) S
0.133 0.545 0.133 FG
(at) S
0.000 0.000 0.000 FG
( 2.) S
LHL
(  remember \(Znth bk buckets\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( p) S
(0) S
(.) S
LHL
(  remember \(Znth bk contents\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( l) S
(0) S
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( \(Znth_map bk fst bl\) ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( \(Znth_map bk snd bl\) ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( Heqbuckets.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( H) S
(0) S
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(1) S
(.) S
LHL
(  ) S
0.698 0.133 0.133 FG
(\(* ) S
(So p0 is pointing to l0 the list we now traverse. ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(  forward_while \() S
0.627 0.322 0.176 FG
(EX p) S
0.000 0.000 0.000 FG
(: val, EX l: list \(string * Z\),) S
LHL
(     PROP \(l) S
(0) S
( = \(Znth bk contents\);) S
LHL
(           p) S
(0) S
( = \(Znth bk buckets\);) S
LHL
(           list_get sigma l = list_get sigma l) S
(0) S
(\)) S
LHL
(     LOCAL \(temp _p p;) S
LHL
(            temp _s s\)) S
LHL
(     SEP \(cstring Tsh sigma s;) S
LHL
(          malloc_token Tsh thashtable table;) S
LHL
(          field_at Tsh thashtable [StructField _buckets] \(map snd bl\) table;) S
LHL
(          iter_sepcon \(uncurry listrep\) \(sublist 0 bk bl\);) S
LHL
(          listrep l p;) S
LHL
(          listrep l p -* listrep l) S
(0) S
( p) S
(0) S
(;) S
LHL
(          iter_sepcon \(uncurry listrep\) \(sublist \(bk + 1\) \(Zlength bl\) bl\)\)\)%) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(subgoal 1 ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    Exists p) S
(0) S
( l) S
(0) S
(.) S
LHL
(    entailer!.) S
LHL
(    simplify_value_fits ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(5) S
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( H) S
(5) S
(.) S
LHL
(    remember \(listrep \(Znth \(hashfun sigma mod 109\) \(map fst bl\)\) \(Znth \(hashfun sigma mod 109\) \() S
SL
(map snd bl\)\)\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( P.) S
LHL
(    cancel.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(autorewrite) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
( sublist ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *|-.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(0) S
(.) S
LHL
(    remember \(iter_sepcon \(uncurry listrep\) \(sublist \(hashfun sigma mod 109 + 1\) 109 bl\)\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( Q.) S
LHL
(    cancel.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( wand_refl_cancel_right.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(subgoal 2 ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    entailer!.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(subgoal 3 ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( l ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [| lh lt].) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(l is nil ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listrep ) S
0.133 0.545 0.133 FG
(at) S
0.000 0.000 0.000 FG
( 2.) S
LHL
(      normalize.) S
LHL
(    }) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(l is lh :: lt ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listrep ) S
0.133 0.545 0.133 FG
(at) S
0.000 0.000 0.000 FG
( 2.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(fold) S
0.000 0.000 0.000 FG
( listrep.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( list_cell.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( lh ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [key count].) S
LHL
(      Intros y kp.) S
LHL
(      forward.) S
LHL
(      forward_call \(kp, key, s, sigma\).) S
LHL
(      Intros strcmp_ret.) S
LHL
(      forward_if.) S
LHL
(      ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(True branch ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( pred_dec_true ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(6) S
( ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(5) S
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( pred_dec_true ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(5) S
( ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(        forward.) S
LHL
(        sep_apply \(listcell_fold key kp count y p\).) S
LHL
(        sep_apply \(listrep_fold key count y p lt\).) S
EndPage
EndDSCPage
EndSheet

%%Page: 16 16
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1073 def
/PageNumber 16 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1080 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(        sep_apply \(wand_frame_elim \(listrep \(\(key, count\) :: lt\) p\) \(listrep l) S
(0) S
( p) S
(0) S
(\)\).) S
LHL
(        ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(\(listrep l) S
(0) S
( p) S
(0) S
(\) = \(uncurry listrep\) \(l) S
(0) S
(, p) S
(0) S
(\)\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(          ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( uncurry.) S
LHL
(          ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(        }) S
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(8) S
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(\(l) S
(0) S
(, p) S
(0) S
(\) = Znth bk bl\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(          ) S
0.000 0.000 0.545 FG
(subst) S
0.000 0.000 0.000 FG
( l) S
(0) S
( p) S
(0) S
(.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(subst) S
0.000 0.000 0.000 FG
( contents buckets.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Znth_map ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Znth_map ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(          remember \(Znth bk bl\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( bkbl.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( surjective_pairing; ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(        }) S
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(9) S
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(\(iter_sepcon \(uncurry listrep\) \(sublist 0 bk bl\) *) S
LHL
(                uncurry listrep \(Znth bk bl\) *) S
LHL
(                iter_sepcon \(uncurry listrep\) \(sublist \(bk + 1\) \(Zlength bl\) bl\)\)) S
LHL
(                 |--) S
LHL
(                 \(iter_sepcon \(uncurry listrep\) bl\)\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(          ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( derives_refl''.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( iter_sepcon_split) S
(3) S
(.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(        }) S
LHL
(        sep_apply H) S
(10) S
(.) S
LHL
(        forward.) S
LHL
(        entailer!.) S
LHL
(        ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(          ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_get.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_map.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(1) S
(.) S
LHL
(          ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(        }) S
LHL
(        ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(          ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_rep.) S
LHL
(          Exists bl.) S
LHL
(          entailer!.) S
LHL
(        }) S
LHL
(      }) S
LHL
(      ) S
0.698 0.133 0.133 FG
(\(* ) S
(After the if. Apparently the empty else clause does have any requirements. ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      forward. ) S
0.698 0.133 0.133 FG
(\(* ) S
(Over p=p->next; ) S
(*\)) S
0.000 0.000 0.000 FG
PHL
LHL
(      ) S
0.698 0.133 0.133 FG
(\(* ) S
(At end of loop. Show the invariant still holds. ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( if_false ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(6) S
( ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(      Exists \(y, lt\).) S
LHL
(      ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(5) S
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( if_false ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(5) S
(.) S
LHL
(      2: ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(      sep_apply \(listcell_fold key kp count y p\).) S
LHL
(      ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( \(listrep \(\(key, count\) :: lt\) p\).) S
LHL
(      ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
( \(list_cell key count y p *) S
LHL
(              \(\() S
0.627 0.322 0.176 FG
(EX y') S
0.000 0.000 0.000 FG
( : val, list_cell key count y' p * listrep lt y'\) -* listrep l) S
(0) S
( p) S
(0) S
(\)) S
LHL
(                |-- listrep lt y -* listrep l) S
(0) S
( p) S
(0) S
(\).) S
LHL
(      ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(        ) S
1.000 0.000 0.000 FG
(exact) S
0.000 0.000 0.000 FG
( \(wand_cancel_ex val y) S
LHL
(                                \() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(y') S
0.000 0.000 0.000 FG
(: val ) S
[[(?)false] ] RLC
( list_cell key count y' p\)) S
LHL
(                                \() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(y') S
0.000 0.000 0.000 FG
(: val ) S
[[(?)false] ] RLC
( listrep lt y'\)) S
LHL
(                                \(listrep l) S
(0) S
( p) S
(0) S
(\)\).) S
LHL
(      }) S
LHL
(      sep_apply H) S
(8) S
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( \(listrep \(snd \(y, lt\)\) \(fst \(y, lt\)\)\).) S
LHL
(      entailer!.) S
LHL
(    }) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    assert_PROP\(l = nil\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( l ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [| [lhs lhx] lt].) S
LHL
(      ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(l is nil ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(        entailer!.) S
LHL
(      }) S
LHL
(      ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(l id lh :: lt ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(        ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listrep ) S
0.133 0.545 0.133 FG
(at) S
0.000 0.000 0.000 FG
( 2.) S
EndPage
EndDSCPage
EndSheet

%%Page: 17 17
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1145 def
/PageNumber 17 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1152 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(        Intros y.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(fold) S
0.000 0.000 0.000 FG
( \(listrep lt y\).) S
LHL
(        assert_PROP\(isptr p\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(          entailer!.) S
LHL
(      }) S
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( HRE ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(6) S
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(6) S
(.) S
LHL
(        ) S
1.000 0.000 0.000 FG
(contradiction) S
0.000 0.000 0.000 FG
(.) S
LHL
(      }) S
LHL
(    }) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(6) S
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(5) S
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(5) S
(.) S
LHL
(    forward. ) S
0.698 0.133 0.133 FG
(\(* ) S
(Over return ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    entailer!.) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_get.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_map.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(1) S
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( H) S
(5) S
(.) S
LHL
(      ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_rep.) S
LHL
(    Exists bl.) S
LHL
(    entailer!.) S
LHL
(    remember \(hashfun sigma mod 109\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( bk.) S
LHL
(    remember \(listrep [] nullval\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( nl.) S
LHL
(    remember \(listrep \(Znth bk \(map fst bl\)\) \(Znth bk \(map snd bl\)\)\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( Q.) S
LHL
(    sep_apply \(modus_ponens_wand nl Q\).) S
LHL
(    ) S
0.000 0.000 0.545 FG
(subst) S
0.000 0.000 0.000 FG
( nl Q.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(iter_sepcon_split) S
(3) S
( bk bl \(uncurry listrep\)\) ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    cancel.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( uncurry.) S
LHL
(    ) S
0.706 0.322 0.804 FG
(repeat) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Znth_map ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
PHL
LHL
(}) S
PHL
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.545 0.133 0.322 FG
(\(** [] *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.545 0.133 0.322 FG
(\(** **** ) S
(Exercise: 3 stars \(listboxrep_traverse\)) S
(  *\)) S
0.000 0.000 0.000 FG
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(listboxrep_traverse) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(p kp key count r) S
0.000 0.000 0.000 FG
(,) S
LHL
(          field_compatible tcell [] p ) S
[[(?)false] ] RLC
LHL
(            cstring Tsh key kp *) S
LHL
(            field_at Tsh tcell [StructField _key] kp p *) S
LHL
(            field_at Tsh tcell [StructField _count] \(Vint \(Int.repr count\)\) p *) S
LHL
(            malloc_token Tsh tcell p *) S
LHL
(            data_at Tsh \(tptr tcell\) p r |--) S
LHL
(            ALL dl: list \(string * Z\),) S
LHL
(              listboxrep dl \(field_address tcell [StructField _next] p\)) S
LHL
(                ) S
0.227 0.373 0.804 FG
(-*) S
0.000 0.000 0.000 FG
( listboxrep \(\(key, count\) :: dl\) r.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( allp_right; ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
( dl.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( wand_sepcon_adjoint.) S
LHL
(   ) S
0.545 0.133 0.322 FG
(\(** Sometime during the proof below, you will have) S
LHL
(       [data_at Tsh tcell ... p]) S
LHL
(     that you want to expand into) S
PHL
LHL
(       field_at Tsh tcell [StructField _key] ... p) S
LHL
(     * field_at Tsh tcell [StructField _count] ... p) S
LHL
(     * field_at Tsh tcell [StructField _next] ... p].) S
PHL
LHL
(   You can do this with   [unfold_data_at x%) S
[[(?)false] ] RLC
(] where x is the number) S
LHL
(   indicating _which_ of the [data_at] or [field_at] conjucts you want to expand.) S
LHL
(*\)) S
0.000 0.000 0.000 FG
PHL
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listboxrep.) S
LHL
(  Intros p'.) S
EndPage
EndDSCPage
EndSheet

%%Page: 18 18
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1217 def
/PageNumber 18 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1224 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  remember \(field_address tcell [StructField _next] p\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( y.) S
LHL
(  Exists p.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( \(listrep \(\(key, count\) :: dl\) p\).) S
LHL
(  Exists p'.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( list_cell.) S
LHL
(  Exists kp.) S
LHL
(  unfold_data_at 4%) S
[[(?)false] ] RLC
(.) S
LHL
(  entailer!.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( field_at_data_at.) S
LHL
(  entailer!.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.545 0.133 0.322 FG
(\(** [] *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.545 0.133 0.322 FG
(\(** **** ) S
(Exercise: 2 stars \(body_incr_list\)) S
(  *\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(incr_list_no_key) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(key) S
0.000 0.000 0.000 FG
(: string\) \() S
0.627 0.322 0.176 FG
(al) S
0.000 0.000 0.000 FG
(: list \(string * Z\)\),) S
LHL
(    ~ \(In key \(map fst al\)\) ) S
[[(?)false] ] RLC
( \(list_incr key al\) = al ++ [\(key, 1\)].) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
( key al.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(induction) S
0.000 0.000 0.000 FG
( al ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [| [lhk lhc] lt]; ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(al is nil ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(al is \(lhk, lhc\) :: lt ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( \(EqDec_string key lhk\).) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(key = lhk ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(exfalso) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( H.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(left) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(key <> lhk ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      f_equal.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( IHlt.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( H.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(right) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(  }) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(incr_list_with_key) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(key) S
0.000 0.000 0.000 FG
(: string\) \() S
0.627 0.322 0.176 FG
(al post) S
0.000 0.000 0.000 FG
(: list \(string * Z\)\) \() S
0.627 0.322 0.176 FG
(count) S
0.000 0.000 0.000 FG
(: Z\),) S
LHL
(    ~ \(In key \(map fst al\)\) ) S
[[(?)false] ] RLC
LHL
(    \(list_incr key \(al ++ [\(key, count\)] ++ post\)\) = \(al ++ [\(key, count + 1\)] ++ post\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
( key al.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(induction) S
0.000 0.000 0.000 FG
( al ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [| [lhk lhc] lt]; ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(al is nil ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( pred_dec_true ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(al is \(lhk, lhc\) :: lt ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( \(EqDec_string key lhk\).) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(key = lhk ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(exfalso) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( H.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(left) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(key <> lhk ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      f_equal.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( IHlt.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
(.) S
EndPage
EndDSCPage
EndSheet

%%Page: 19 19
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1289 def
/PageNumber 19 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1296 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(      ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( H.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(right) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(  }) S
PHL
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Definition) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(partial_listbox_rep) S
0.000 0.000 0.000 FG
(\() S
0.627 0.322 0.176 FG
(P) S
0.000 0.000 0.000 FG
(: \(list \(string * Z\)\) ) S
[[(?)false] ] RLC
( \(list \(string * Z\)\)\)) S
LHL
(           \() S
0.627 0.322 0.176 FG
(r i) S
0.000 0.000 0.000 FG
(: val\) : mpred :=) S
LHL
(  ALL l: list \(string * Z\), \(\(listboxrep l i\) -* \(listboxrep \(P l\) r\)\).) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(ptbr3a) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(q p kp key count) S
0.000 0.000 0.000 FG
(,) S
LHL
(    \(\(data_at Tsh \(tptr tcell\) p q\) *) S
LHL
(     field_at Tsh tcell [StructField _key] kp p *) S
LHL
(     field_at Tsh tcell [StructField _count] \(Vint \(Int.repr count\)\) p *) S
LHL
(     cstring Tsh key kp *) S
LHL
(     malloc_token Tsh tcell p) S
LHL
(    \)) S
LHL
(      |-- \(partial_listbox_rep \() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(l) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( \(key, count\) :: l\) q) S
LHL
(                               \(field_address tcell [StructField _next] p\)\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( partial_listbox_rep.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( allp_right.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
( v.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( wand_sepcon_adjoint.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listboxrep ) S
0.133 0.545 0.133 FG
(at) S
0.000 0.000 0.000 FG
( 2.) S
LHL
(  Exists p.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listrep.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listboxrep.) S
LHL
(  Intros y.) S
LHL
(  Exists y.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(fold) S
0.000 0.000 0.000 FG
( \(listrep v y\).) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( list_cell.) S
LHL
(  Exists kp.) S
LHL
(  cancel.) S
LHL
(  unfold_data_at 2%) S
[[(?)false] ] RLC
(.) S
LHL
(  cancel.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( field_at_data_at.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( tcell.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(ptbr3c) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(p) S
0.000 0.000 0.000 FG
(,) S
LHL
(    emp |-- partial_listbox_rep \() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(l) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( l\) p p.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( partial_listbox_rep.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( allp_right.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
( v.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( wand_refl_cancel_right.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(ptbr3d) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(t i r P) S
0.000 0.000 0.000 FG
(,) S
LHL
(  \(\(listboxrep t i\) * \(partial_listbox_rep P r i\)\)) S
LHL
(    |-- \(listboxrep \(P t\) r\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( partial_listbox_rep.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sepcon_comm.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( wand_sepcon_adjoint.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( \(allp_instantiate) S
LHL
(           \() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(l) S
0.000 0.000 0.000 FG
( : list \(string * Z\) ) S
[[(?)false] ] RLC
( listboxrep l i -* listboxrep \(P l\) r\)) S
LHL
(           t\).) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(ptbr3e) S
0.000 0.000 0.000 FG
(:) S
EndPage
EndDSCPage
EndSheet

%%Page: 20 20
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1361 def
/PageNumber 20 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1368 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(P) S
(1) S
( P) S
(2) S
( p) S
(1) S
( p) S
(2) S
( p) S
(3) S
0.000 0.000 0.000 FG
(,) S
LHL
(    \(partial_listbox_rep P) S
(1) S
( p) S
(2) S
( p) S
(1) S
(\) *) S
LHL
(    \(partial_listbox_rep P) S
(2) S
( p) S
(3) S
( p) S
(2) S
(\)) S
LHL
(      |-- \(partial_listbox_rep) S
LHL
(             \() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(l) S
0.000 0.000 0.000 FG
(: list \(string * Z\) ) S
[[(?)false] ] RLC
( \(P) S
(2) S
( \(P) S
(1) S
( l\)\)\)) S
LHL
(             p) S
(3) S
( p) S
(1) S
(\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( partial_listbox_rep.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( allp_right.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
( v.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(\() S
0.627 0.322 0.176 FG
(ALL l) S
0.000 0.000 0.000 FG
( : list \(string * Z\) , listboxrep l p) S
(1) S
( -* listboxrep \(P) S
(1) S
( l\) p) S
(2) S
(\)) S
LHL
(           |-- \(listboxrep v p) S
(1) S
( -* listboxrep \(P) S
(1) S
( v\) p) S
(2) S
(\)\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( \(allp_instantiate) S
LHL
(             \() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(l) S
0.000 0.000 0.000 FG
( : list \(string * Z\) ) S
[[(?)false] ] RLC
( listboxrep l p) S
(1) S
( -* listboxrep \(P) S
(1) S
( l\) p) S
(2) S
(\)) S
LHL
(             v\).) S
LHL
(  }) S
LHL
(  sep_apply H; ) S
0.000 0.000 0.545 FG
(clear) S
0.000 0.000 0.000 FG
( H.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(\() S
0.627 0.322 0.176 FG
(ALL l) S
0.000 0.000 0.000 FG
( : list \(string * Z\) , listboxrep l p) S
(2) S
( -* listboxrep \(P) S
(2) S
( l\) p) S
(3) S
(\)) S
LHL
(           |-- listboxrep \(P) S
(1) S
( v\) p) S
(2) S
( -* listboxrep \(P) S
(2) S
( \(P) S
(1) S
( v\)\) p) S
(3) S
(\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( \(allp_instantiate) S
LHL
(             \() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(l) S
0.000 0.000 0.000 FG
( : list \(string * Z\) ) S
[[(?)false] ] RLC
( listboxrep l p) S
(2) S
( -* listboxrep \(P) S
(2) S
( l\) p) S
(3) S
(\)) S
LHL
(             \(P) S
(1) S
( v\)\).) S
LHL
(  }) S
LHL
(  sep_apply H; ) S
0.000 0.000 0.545 FG
(clear) S
0.000 0.000 0.000 FG
( H.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( wand_sepcon_adjoint.) S
LHL
(  sep_apply \(modus_ponens_wand \(listboxrep v p) S
(1) S
(\) \(listboxrep \(P) S
(1) S
( v\) p) S
(2) S
(\)\).) S
LHL
(  sep_apply \(modus_ponens_wand \(listboxrep \(P) S
(1) S
( v\) p) S
(2) S
(\) \(listboxrep \(P) S
(2) S
( \(P) S
(1) S
( v\)\) p) S
(3) S
(\)\).) S
LHL
(  ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(listboxrep_fold) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(p r al) S
0.000 0.000 0.000 FG
(,) S
LHL
(    data_at Tsh \(tptr tcell\) p r * listrep al p |-- listboxrep al r.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listboxrep.) S
LHL
(  Exists p.) S
LHL
(  cancel.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(hashtable_rep_fold) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(p) S
0.000 0.000 0.000 FG
(: val\) \() S
0.627 0.322 0.176 FG
(bl) S
0.000 0.000 0.000 FG
(: list \(list \(string * Z\) * val\)\),) S
LHL
(    malloc_token Tsh thashtable p *) S
LHL
(    field_at Tsh thashtable [StructField _buckets] \(map snd bl\) p *) S
LHL
(    iter_sepcon \(uncurry listrep\) bl) S
LHL
(                |-- hashtable_rep \(map fst bl\) p.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_rep.) S
LHL
(  Exists bl.) S
LHL
(  entailer!.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(field_at_data_at') S
0.000 0.000 0.000 FG
(:) S
LHL
(      ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( {) S
0.627 0.322 0.176 FG
(cs) S
0.000 0.000 0.000 FG
(: compspecs} \() S
0.627 0.322 0.176 FG
(sh) S
0.000 0.000 0.000 FG
( : Share.t\) \() S
0.627 0.322 0.176 FG
(t) S
0.000 0.000 0.000 FG
( : type\) \() S
0.627 0.322 0.176 FG
(gfs) S
0.000 0.000 0.000 FG
( : list gfield\)) S
LHL
(         \() S
0.627 0.322 0.176 FG
(v) S
0.000 0.000 0.000 FG
( : reptype \(nested_field_type t gfs\)\)) S
LHL
(         \() S
0.627 0.322 0.176 FG
(p) S
0.000 0.000 0.000 FG
( : val\),) S
LHL
(       field_at sh t gfs v p =) S
LHL
(       !! field_compatible t gfs p  && data_at sh \(nested_field_type t gfs\) v \(field_address t gf) S
SL
(s p\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( pred_ext.) S
LHL
(entailer!. ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( field_at_data_at; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(entailer!. ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( field_at_data_at; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(add1_rep) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(x) S
0.000 0.000 0.000 FG
(: Z,) S
LHL
(    \(Int.add \(Int.repr x\) \(Int.repr 1\)\) = Int.repr \(x + 1\).) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
EndPage
EndDSCPage
EndSheet

%%Page: 21 21
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1432 def
/PageNumber 21 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1440 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( Int.add.) S
LHL
(  ) S
0.627 0.125 0.941 FG
(Search) S
0.000 0.000 0.000 FG
( \(\(_ + _\) mod _\).) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( int_rep_helper.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( !Int.unsigned_repr_eq.) S
LHL
(  remember Int.modulus ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( m.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( Zplus_mod.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Definition) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(prepend_key_count) S
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(P) S
0.000 0.000 0.000 FG
(: \(list \(string * Z\)\) ) S
[[(?)false] ] RLC
( \(list \(string * Z\)\)\)) S
LHL
(           \() S
0.627 0.322 0.176 FG
(key) S
0.000 0.000 0.000 FG
(: string\) \() S
0.627 0.322 0.176 FG
(count) S
0.000 0.000 0.000 FG
( : Z\) \() S
0.627 0.322 0.176 FG
(l) S
0.000 0.000 0.000 FG
(: list \(string * Z\)\) :=) S
LHL
(    P\(\(key, count\) :: l\).) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(list_rep_listbox_rep) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(t) S
0.000 0.000 0.000 FG
(: list \(string * Z\)\) \() S
0.627 0.322 0.176 FG
(p) S
0.000 0.000 0.000 FG
( : val\),) S
LHL
(    listrep t p =) S
LHL
(    ) S
0.133 0.545 0.133 FG
(match) S
0.000 0.000 0.000 FG
( t ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
LHL
(    | [] ) S
[[(?)false] ] RLC
( !!\(p = nullval\) && emp) S
LHL
(    | \(s, c\) :: tl ) S
[[(?)false] ] RLC
( \() S
0.627 0.322 0.176 FG
(EX kp) S
0.000 0.000 0.000 FG
(: val,) S
LHL
(      malloc_token Tsh tcell p *) S
LHL
(      cstring Tsh s kp *) S
LHL
(      field_at Tsh tcell [StructField _key] kp p *) S
LHL
(      field_at Tsh tcell [StructField _count] \(Vint \(Int.repr c\)\) p *) S
LHL
(      listboxrep tl \(field_address tcell [StructField _next] p\)\)) S
LHL
(    ) S
0.133 0.545 0.133 FG
(end) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( t ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [| [s c] tl]; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listboxrep; ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( pred_ext.) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    Intros y.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( list_cell.) S
LHL
(    Intros kp.) S
LHL
(    Exists kp.) S
LHL
(    entailer!.) S
LHL
(    unfold_data_at 1%) S
[[(?)false] ] RLC
(.) S
LHL
(    Exists y.) S
LHL
(    cancel.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( !field_at_data_at.) S
LHL
(    cancel.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    Intros kp p) S
(0) S
(.) S
LHL
(    Exists p) S
(0) S
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( list_cell.) S
LHL
(    Exists kp.) S
LHL
(    entailer!.) S
LHL
(    unfold_data_at 2%) S
[[(?)false] ] RLC
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( !field_at_data_at.) S
LHL
(    cancel.) S
LHL
(  }) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(listboxrep_spec) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(t) S
0.000 0.000 0.000 FG
(: list \(string * Z\)\) \() S
0.627 0.322 0.176 FG
(b) S
0.000 0.000 0.000 FG
(: val\),) S
LHL
(  listboxrep t b =) S
LHL
(  EX p: val,) S
LHL
(  data_at Tsh \(tptr tcell\) p b *) S
LHL
(    ) S
0.133 0.545 0.133 FG
(match) S
0.000 0.000 0.000 FG
( t ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
LHL
(    | [] ) S
[[(?)false] ] RLC
( !!\(p = nullval\) && emp) S
LHL
(    | \(s, c\) :: tl ) S
[[(?)false] ] RLC
( \() S
0.627 0.322 0.176 FG
(EX kp) S
0.000 0.000 0.000 FG
(: val,) S
LHL
(      malloc_token Tsh tcell p *) S
LHL
(      cstring Tsh s kp *) S
LHL
(      field_at Tsh tcell [StructField _key] kp p *) S
LHL
(      field_at Tsh tcell [StructField _count] \(Vint \(Int.repr c\)\) p *) S
LHL
(      listboxrep tl \(field_address tcell [StructField _next] p\)\)) S
LHL
(    ) S
0.133 0.545 0.133 FG
(end) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listboxrep ) S
0.133 0.545 0.133 FG
(at) S
0.000 0.000 0.000 FG
( 1.) S
LHL
(  f_equal.) S
LHL
(  extensionality p.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( t ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [| [s c] tl]; ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
EndPage
EndDSCPage
EndSheet

%%Page: 22 22
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1504 def
/PageNumber 22 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1512 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  { ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( pred_ext; entailer!. }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(Non-nil case ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( pred_ext; entailer!.) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( list_cell.) S
LHL
(      Intros kp. Exists kp.) S
LHL
(      unfold_data_at 2%) S
[[(?)false] ] RLC
(.) S
LHL
(      cancel.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listboxrep.) S
LHL
(      Exists y.) S
LHL
(      cancel.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( field_at_data_at.) S
LHL
(      cancel.) S
LHL
(    }) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listboxrep.) S
LHL
(      Intros q.) S
LHL
(      Exists q.) S
LHL
(      cancel.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( list_cell.) S
LHL
(      Exists kp.) S
LHL
(      cancel.) S
LHL
(      unfold_data_at 2%) S
[[(?)false] ] RLC
(.) S
LHL
(      cancel.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( field_at_data_at.) S
LHL
(      cancel.) S
LHL
(    }) S
LHL
(  }) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(listboxrep_internal) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(b p kp s c tl) S
0.000 0.000 0.000 FG
(,) S
LHL
(  data_at Tsh \(tptr tcell\) p b *) S
LHL
(  malloc_token Tsh tcell p *) S
LHL
(  cstring Tsh s kp *) S
LHL
(  field_at Tsh tcell [StructField _key] kp p *) S
LHL
(  field_at Tsh tcell [StructField _count] \(Vint \(Int.repr c\)\) p *) S
LHL
(  listboxrep tl \(field_address tcell [StructField _next] p\) |--) S
LHL
(  listboxrep \(\(s, c\) :: tl\) b.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(listboxrep_spec \(cons _ _ \)\).) S
LHL
(  Exists p kp.) S
LHL
(  entailer!.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(body_incr_list) S
0.000 0.000 0.000 FG
(: semax_body Vprog Gprog f_incr_list incr_list_spec.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
0.545 0.133 0.322 FG
(\(** This proof uses "magic wand as frame" to traverse _and update_) S
LHL
(   a \(linked list\) data structure.   This pattern is a bit more complex than) S
LHL
(   the wand-as-frame pattern used in body_get, which did not update) S
LHL
(   the data structure.   You will still use "data-structure-with-a-hole") S
LHL
(   and "what-is-in-the-hole"; but now the "data-structure-with-a-hole") S
LHL
(   must be able to accept the _future_ hole-filler, not the one that is) S
LHL
(   in the hole right now.) S
PHL
LHL
(  The key lemmas to use are, [wand_refl_cancel_right], [wand_frame_elim'],) S
LHL
(   and [wand_frame_ver].   When using [wand_frame_ver], you will find) S
LHL
(   [listboxrep_traverse] to be useful.) S
LHL
(*\)) S
0.000 0.000 0.000 FG
LHL
(  start_function.) S
LHL
(  forward.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rename) S
0.000 0.000 0.000 FG
( al ) S
0.133 0.545 0.133 FG
(into) S
0.000 0.000 0.000 FG
( al) S
(0) S
(.) S
LHL
(  forward_loop) S
LHL
(    \() S
0.627 0.322 0.176 FG
(EX P) S
0.000 0.000 0.000 FG
(: \(list \(string * Z\)\) ) S
[[(?)false] ] RLC
( \(list \(string * Z\)\),) S
LHL
(           \() S
0.627 0.322 0.176 FG
(EX r) S
0.000 0.000 0.000 FG
(: val, \() S
0.627 0.322 0.176 FG
(EX al) S
0.000 0.000 0.000 FG
(: list \(string * Z\),) S
LHL
(       \(PROP \() S
LHL
(            P\(list_incr sigma al\) = list_incr sigma al) S
(0) S
(;) S
LHL
(            \(list_get sigma al) S
(0) S
(\) = \(list_get sigma al\)) S
LHL
(          \)) S
LHL
(        LOCAL \() S
LHL
(          temp _r r;) S
LHL
(          temp _s s) S
EndPage
EndDSCPage
EndSheet

%%Page: 23 23
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1576 def
/PageNumber 23 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1584 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(        \)) S
LHL
(        SEP \() S
LHL
(          listboxrep al r;) S
LHL
(          partial_listbox_rep P r) S
(0) S
( r;) S
LHL
(          cstring Tsh sigma s) S
LHL
(        \)) S
LHL
(    \)\)\)\).) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(Pre implies loop invariant ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    Exists \() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(l) S
0.000 0.000 0.000 FG
(: \(list \(string * Z\)\) ) S
[[(?)false] ] RLC
( l\).) S
LHL
(    Exists r) S
(0) S
(.) S
LHL
(    Exists al) S
(0) S
(.) S
LHL
(    entailer!.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( ptbr3c.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(In body of loop ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    Intros P r al.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listboxrep.) S
LHL
(    Intros p.) S
LHL
(    forward.) S
LHL
(    forward_if \(p ) S
[[(?)false] ] RLC
( nullval\).) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(True branch ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      assert_PROP\(al = []\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(        entailer!.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( H) S
(5) S
(;) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(      }) S
LHL
(      ) S
0.000 0.000 0.545 FG
(subst) S
0.000 0.000 0.000 FG
( al.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(0) S
(.) S
LHL
(      forward_call \(s, sigma, 1, nullval\).) S
LHL
(      Intros new_cell_ret.) S
LHL
(      forward.) S
LHL
(      sep_apply \(listrep_fold_nil sigma 1 new_cell_ret\).) S
LHL
(      sep_apply \(listboxrep_fold new_cell_ret r [\(sigma, 1\)]\).) S
LHL
(      sep_apply \(ptbr3d [\(sigma, 1\)] r r) S
(0) S
( P\).) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(0) S
(.) S
LHL
(      forward.) S
LHL
(    }) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(False branch ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      forward.) S
LHL
(      entailer!.) S
LHL
(    }) S
LHL
(    ) S
0.698 0.133 0.133 FG
(\(* ) S
(After first if. ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(    assert_PROP\(p ) S
[[(?)false] ] RLC
( nullval\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      entailer!.) S
LHL
(    }) S
LHL
(    ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( al ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [| [key' count'] lt]; ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( list_rep_listbox_rep.) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(al is nil, a contradiction ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      normalize.) S
LHL
(    }) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(al is \(key', count'\) :: lt ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      Intros kp. ) S
0.000 0.000 0.545 FG
(clear) S
0.000 0.000 0.000 FG
( H) S
(2) S
(.) S
LHL
(      forward. ) S
0.698 0.133 0.133 FG
(\(* ) S
(temp = p-> key ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      forward_call \(kp, key', s, sigma\).) S
LHL
(      Intros strcmp_ret.) S
LHL
(      forward_if.) S
LHL
(      ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(True branch ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(        ) S
0.000 0.000 0.545 FG
(subst) S
0.000 0.000 0.000 FG
( strcmp_ret.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( pred_dec_true ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(2) S
( ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(subst) S
0.000 0.000 0.000 FG
( key'.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(0) S
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( pred_dec_true ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(0) S
( ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(1) S
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( pred_dec_true ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(1) S
( ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(1) S
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H. ) S
0.000 0.000 0.545 FG
(clear) S
0.000 0.000 0.000 FG
( H) S
(1) S
(.) S
LHL
(        forward.) S
LHL
(        forward.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(add1_rep count'\).) S
LHL
(        sep_apply \(listboxrep_internal r p kp sigma \(count' + 1\) lt\).) S
LHL
(        forward.) S
LHL
(        cancel.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( H) S
(0) S
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( ptbr3d.) S
LHL
(      }) S
EndPage
EndDSCPage
EndSheet

%%Page: 24 24
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1648 def
/PageNumber 24 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1656 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(      ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(False branch, key did not compare ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(        forward.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( pred_dec_false ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(2) S
( ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(0) S
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( pred_dec_false ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(0) S
( ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(        Exists \() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(l) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( P\(\(key', count'\) :: l\)\).) S
LHL
(        Exists \(field_address tcell [StructField _next] p\).) S
LHL
(        Exists lt.) S
LHL
(        entailer!.) S
LHL
(        ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(          ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(1) S
(.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( pred_dec_false ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(1) S
( ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(        }) S
LHL
(        ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(          sep_apply \(ptbr3a r p kp key' count'\).) S
LHL
(          ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( ptbr3e.) S
LHL
(        }) S
LHL
(      }) S
LHL
(    }) S
LHL
(  }) S
PHL
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.545 0.133 0.322 FG
(\(** [] *\)) S
0.000 0.000 0.000 FG
PHL
PHL
PHL
LHL
0.545 0.133 0.322 FG
(\(** Examine this carefully: *\)) S
0.000 0.000 0.000 FG
LHL
0.627 0.125 0.941 FG
(Check) S
0.000 0.000 0.000 FG
( wand_slice_array.) S
LHL
0.698 0.133 0.133 FG
(\(*  ) S
(: forall \(lo hi n : Z\) \(t : type\) \(sh : Share.t\)) S
LHL
(             \(al' : list \(reptype t\)\) \(p : val\),) S
LHL
(       0 <= lo <= hi ->) S
LHL
(       hi <= n ->) S
LHL
(       Zlength al' = n ->) S
LHL
(       data_at sh \(tarray t n\) al' p =) S
LHL
(       !! field_compatible \(tarray \(tptr tcell\) n\) [] p &&) S
LHL
(       data_at sh \(tarray t \(hi - lo\)\)) S
LHL
(         \(sublist lo hi al'\)) S
LHL
(         \(field_address0 \(tarray t n\) [ArraySubsc lo] p\) *) S
LHL
(       array_with_hole sh t lo hi n al p.) S
LHL
(*\)) S
0.000 0.000 0.000 FG
LHL
0.545 0.133 0.322 FG
(\(** Here \(array_with_hole sh t lo hi n al p\) means *\)) S
0.000 0.000 0.000 FG
LHL
0.698 0.133 0.133 FG
(\(*  ) S
(:  \(ALL cl : list \(reptype t\) ,) S
LHL
(         data_at sh \(tarray t \(hi - lo\)\) cl) S
LHL
(           \(field_address0 \(tarray t n\) [ArraySubsc lo] p\) -*) S
LHL
(         data_at sh \(tarray t n\)) S
LHL
(           \(sublist 0 lo al' ++ cl ++ sublist hi n al'\) p\)) S
LHL
(*\)) S
0.000 0.000 0.000 FG
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(wand_slice_array_fold) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( {) S
0.627 0.322 0.176 FG
(cs) S
0.000 0.000 0.000 FG
(: compspecs} lo hi n sh t \() S
0.627 0.322 0.176 FG
(al) S
0.000 0.000 0.000 FG
(: list \(reptype t\)\) p,) S
LHL
(    0 ) S
[[(?)false] ] RLC
( lo ) S
[[(?)false] ] RLC
( hi ) S
[[(?)false] ] RLC
LHL
(    hi ) S
[[(?)false] ] RLC
( n ) S
[[(?)false] ] RLC
LHL
(    Zlength al = n ) S
[[(?)false] ] RLC
LHL
(    \(field_compatible \(tarray t n\) nil p\) ) S
[[(?)false] ] RLC
LHL
(  data_at sh \(tarray t \(hi-lo\)\) \(sublist lo hi al\) \(field_address) S
(0) S
( \(tarray t n\) \(ArraySubsc lo ::) S
SL
( nil\) p\) *) S
LHL
(  array_with_hole sh t lo hi n al p |--) S
LHL
(                  data_at sh \(tarray t n\) al p.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( array_with_hole.) S
LHL
(  entailer!.) S
LHL
(  allp_left \(sublist lo hi al\).) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sepcon_comm.) S
LHL
(  sep_apply \(wand_frame_elim \(data_at sh \(tarray t \(hi - lo\)\) \(sublist lo hi al\) \(field_address) S
(0) S
( ) S
SL
(\(tarray t \(Zlength al\)\) [ArraySubsc lo] p\)\)) S
LHL
(                             \(data_at sh \(tarray t \(Zlength al\)\) \(sublist 0 lo al ++ sublist lo h) S
SL
(i al ++ sublist hi \(Zlength al\) al\) p\)\).) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( app_assoc.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(sublist_rejoin 0 lo hi al\) ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
EndPage
EndDSCPage
EndSheet

%%Page: 25 25
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1717 def
/PageNumber 25 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1728 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(sublist_rejoin 0 hi \(Zlength al\) al\) ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sublist_same ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(wand_slice_array_fold) S
(1) S
0.000 0.000 0.000 FG
(:) S
LHL
(  ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( {) S
0.627 0.322 0.176 FG
(cs) S
0.000 0.000 0.000 FG
(: compspecs} h n sh t \() S
0.627 0.322 0.176 FG
(al) S
0.000 0.000 0.000 FG
(: list \(reptype t\)\) p,) S
LHL
(    0 ) S
[[(?)false] ] RLC
( h ) S
[[(?)false] ] RLC
LHL
(    \(h+1\) ) S
[[(?)false] ] RLC
( n ) S
[[(?)false] ] RLC
LHL
(    Zlength al = n ) S
[[(?)false] ] RLC
LHL
(    \(field_compatible \(tarray t n\) nil p\) ) S
[[(?)false] ] RLC
LHL
(  data_at sh \(tarray t \(\(h+1\) - h\)\) \(sublist h \(h+1\) al\) \(field_address) S
(0) S
( \(tarray t n\) \(ArraySubsc) S
SL
( h :: nil\) p\) *) S
LHL
(  array_with_hole sh t h \(h+1\) n al p |--) S
LHL
(                  data_at sh \(tarray t n\) al p.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(  sep_apply\(\(wand_slice_array_fold h \(h+1\) n sh t al p\)\).) S
LHL
(  all: ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
PHL
PHL
LHL
0.545 0.133 0.322 FG
(\(** **** ) S
(Exercise: 4 stars \(body_incr\)) S
(  *\)) S
0.000 0.000 0.000 FG
LHL
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(body_incr) S
0.000 0.000 0.000 FG
(: semax_body Vprog Gprog f_incr incr_spec.) S
LHL
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(start_function.) S
LHL
0.000 0.000 0.545 FG
(rename) S
0.000 0.000 0.000 FG
( p ) S
0.133 0.545 0.133 FG
(into) S
0.000 0.000 0.000 FG
( table.) S
LHL
0.000 0.000 0.545 FG
(rename) S
0.000 0.000 0.000 FG
( H ) S
0.133 0.545 0.133 FG
(into) S
0.000 0.000 0.000 FG
( Hmax.) S
LHL
(assert_PROP \(isptr table\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( Htable ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( entailer!.) S
PHL
LHL
0.545 0.133 0.322 FG
(\(** The next two lines would not be part of an ordinary Verifiable C proof,) S
LHL
(   they are here only to guide you through the bigger proof. *\)) S
0.000 0.000 0.000 FG
LHL
0.133 0.545 0.133 FG
(match) S
0.000 0.000 0.000 FG
( goal ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
LHL
(  ) S
[[(?)false] ] RLC
( semax _ _ \(Ssequence \(Ssequence ) S
0.627 0.322 0.176 FG
(?c) S
(1) S
0.000 0.000 0.000 FG
( \(Ssequence ) S
0.627 0.322 0.176 FG
(?c) S
(2) S
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(?c) S
(3) S
0.000 0.000 0.000 FG
(\)\) ) S
0.627 0.322 0.176 FG
(?c) S
(4) S
0.000 0.000 0.000 FG
(\) _ ) S
[[(?)false] ] RLC
LHL
(  ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( \(semax_unfold_seq \(Ssequence \(Ssequence c) S
(1) S
( c) S
(2) S
(\) \(Ssequence c) S
(3) S
( c) S
(4) S
(\)\)\); [ ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
( | ]) S
LHL
0.133 0.545 0.133 FG
(end) S
0.000 0.000 0.000 FG
(.) S
LHL
0.000 0.000 0.545 FG
(pose) S
0.000 0.000 0.000 FG
( \(j :=) S
LHL
(          EX cts: list \(list \(string * Z\) * val\),) S
LHL
(                  PROP \(contents = map fst cts;) S
LHL
(                        0 ) S
[[(?)false] ] RLC
( hashfun sigma mod N < N;) S
LHL
(                        Zlength cts = N\)) S
LHL
(                  LOCAL \(temp _b \(Vint \(Int.repr \(hashfun sigma mod N\)\)\);) S
LHL
(                         temp _h \(Vint \(Int.repr \(hashfun sigma\)\)\);) S
LHL
(                         temp _table table; temp _s s\)) S
LHL
(                  SEP \(cstring Tsh sigma s;) S
LHL
(                       malloc_token Tsh thashtable table;) S
LHL
(                       data_at Tsh \(tarray \(tptr tcell\) N\) \(map snd cts\) \(field_address thashtabl) S
SL
(e [StructField _buckets] table\);) S
LHL
(                       iter_sepcon \(uncurry listrep\) cts\)\).) S
LHL
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( semax_seq' ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
( j;) S
LHL
0.000 0.000 0.545 FG
(subst) S
0.000 0.000 0.000 FG
( j;) S
LHL
(abbreviate_semax. ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(  forward_call \(s, sigma\). ) S
0.698 0.133 0.133 FG
(\(* ) S
(h = hash\(s\) ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(  forward.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_contents ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_rep.) S
LHL
(  Intros bl.) S
LHL
(  Exists bl.) S
LHL
(  entailer!.) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(split) S
0.000 0.000 0.000 FG
(; [) S
0.000 0.000 0.545 FG
(split) S
0.000 0.000 0.000 FG
( |].) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( N_eq.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( Z.mod_pos_bound; ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      simplify_value_fits ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(2) S
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( H) S
(2) S
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_map ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( N_eq; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
EndPage
EndDSCPage
EndSheet

%%Page: 26 26
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1787 def
/PageNumber 26 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1800 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      f_equal.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( Int.modu.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( int_rep_helper.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( !Int.unsigned_repr; ) S
0.706 0.322 0.804 FG
(try) S
0.000 0.000 0.000 FG
( rep_omega.) S
LHL
(      ) S
0.627 0.125 0.941 FG
(Lemma) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 1.000 FG
(hashfun_limit) S
0.000 0.000 0.000 FG
(: ) S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(str) S
0.000 0.000 0.000 FG
(,) S
LHL
(          0 ) S
[[(?)false] ] RLC
( hashfun str ) S
[[(?)false] ] RLC
( Int.max_unsigned.) S
LHL
(      ) S
0.627 0.125 0.941 FG
(Proof) S
0.000 0.000 0.000 FG
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashfun.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( hashfun_aux_equiv''.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashfun_aux''.) S
LHL
(        remember \(rev str\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( rs.) S
LHL
(        ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( rs; ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(        ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(          rep_omega.) S
LHL
(        }) S
LHL
(        ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(          ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hash_step'; ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(generalize) S
0.000 0.000 0.000 FG
( \(fold_right \() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( \() S
0.627 0.322 0.176 FG
(c) S
0.000 0.000 0.000 FG
( : byte\) \() S
0.627 0.322 0.176 FG
(hin) S
0.000 0.000 0.000 FG
( : Z\) ) S
[[(?)false] ] RLC
( hash_step hin c\) 0 rs\).) S
LHL
(          ) S
0.000 0.000 0.545 FG
(intro) S
0.000 0.000 0.000 FG
( z.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hash_step.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( Int.max_unsigned.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(generalize) S
0.000 0.000 0.000 FG
( \(z * 65599 + Byte.signed i\); ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\() S
0.133 0.545 0.133 FG
[[(?)false] ] RLC
0.000 0.000 0.000 FG
( ) S
0.627 0.322 0.176 FG
(a b) S
0.000 0.000 0.000 FG
(: Z, 0 ) S
[[(?)false] ] RLC
( a < b ) S
[[(?)false] ] RLC
(  0 ) S
[[(?)false] ] RLC
( a ) S
[[(?)false] ] RLC
( b - 1\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(            ) S
0.000 0.000 0.545 FG
(intros) S
0.000 0.000 0.000 FG
(. ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(          }) S
LHL
(          ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( H; ) S
0.000 0.000 0.545 FG
(clear) S
0.000 0.000 0.000 FG
( H.) S
LHL
(          ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( Z.mod_pos_bound; rep_omega.) S
LHL
(        }) S
LHL
(      ) S
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( \(hashfun_limit sigma\).) S
LHL
(    }) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( field_at_data_at.) S
LHL
(    entailer!.) S
LHL
(  }) S
LHL
(}) S
LHL
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(  Intros cts.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( Hmax.) S
LHL
(  assert_PROP\(field_compatible thashtable [StructField _buckets] table\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    entailer!.) S
LHL
(  }) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rename) S
0.000 0.000 0.000 FG
( H) S
(2) S
( ) S
0.133 0.545 0.133 FG
(into) S
0.000 0.000 0.000 FG
( FCT.) S
PHL
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_get ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( Hmax.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_map, H) S
(1) S
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( Hmax.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(set) S
0.000 0.000 0.000 FG
( \(h := hashfun sigma mod N\) ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(  remember \(map snd cts\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( bkptrs.) S
LHL
(  remember \(field_address thashtable [StructField _buckets] table\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( bucketsAdr.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(wand_slice_array h \(h+1\) N Tsh \(tptr tcell\) bkptrs bucketsAdr\);) S
LHL
(    ) S
0.706 0.322 0.804 FG
(try) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Heqbkptrs; ) S
0.706 0.322 0.804 FG
(try) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_map; ) S
0.706 0.322 0.804 FG
(try) S
0.000 0.000 0.000 FG
( rep_omega.) S
PHL
LHL
0.545 0.133 0.322 FG
(\(** For the remainder of the proof, here are some useful lemmas:) S
LHL
(    [sublist_len) S
(_1) S
(] [sublist_same] [sublist_map]) S
LHL
(    [data_at_singleton_array_eq]) S
LHL
(    [iter_sepcon_split) S
(3) S
(]  [iter_sepcon_app] [sublist_split]) S
LHL
(    [field_at_data_at]) S
LHL
(    [wand_slice_array_tptr_tcell]) S
LHL
( *\)) S
0.000 0.000 0.000 FG
LHL
(  Intros.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\() S
0.627 0.322 0.176 FG
(K) S
0.000 0.000 0.000 FG
(: h + 1 - h = 1\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( K. ) S
0.000 0.000 0.545 FG
(clear) S
0.000 0.000 0.000 FG
( K.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sublist_len) S
(_1) S
(; ) S
0.706 0.322 0.804 FG
(try) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_map; ) S
0.706 0.322 0.804 FG
(try) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(1) S
(; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( Heqbkptrs.) S
LHL
(  remember \(field_address) S
(0) S
( \(tarray \(tptr tcell\) N\) [ArraySubsc h] bucketsAdr\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( bk.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(data_at_singleton_array_eq Tsh \(tptr tcell\) \(Znth h bkptrs\)\).) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(iter_sepcon_split) S
(3) S
( h cts \(uncurry listrep\)\);) S
0.706 0.322 0.804 FG
(repeat) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_map; ) S
0.706 0.322 0.804 FG
(repeat) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
EndPage
EndDSCPage
EndSheet

%%Page: 27 27
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1858 def
/PageNumber 27 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1872 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
( H) S
(1) S
(; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( uncurry ) S
0.133 0.545 0.133 FG
(at) S
0.000 0.000 0.000 FG
( 2.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( !\(Znth_map h fst\);) S
0.706 0.322 0.804 FG
(repeat) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_map; ) S
0.706 0.322 0.804 FG
(repeat) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(1) S
(; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( !\(Znth_map h snd\);) S
0.706 0.322 0.804 FG
(repeat) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_map; ) S
0.706 0.322 0.804 FG
(repeat) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(1) S
(; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( Heqbkptrs ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(  ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( H ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(  remember \(Znth h bkptrs\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( p.) S
LHL
(  remember \(Znth h contents\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( al.) S
LHL
(  sep_apply \(listboxrep_fold p bk al\).) S
LHL
(  forward_call \(bk, al, s, sigma\). ) S
0.698 0.133 0.133 FG
(\(* ) S
(incr_list \(& table->buckets[b], s\); ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(  3: ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    entailer!.) S
LHL
(    f_equal.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\() S
0.627 0.322 0.176 FG
(FAT) S
0.000 0.000 0.000 FG
(: \(field_address thashtable [StructField _buckets] table\) = table\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( field_address.) S
LHL
(      normalize.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( \(field_compatible_dec thashtable [StructField _buckets] table\).) S
LHL
(      ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(        ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(      }) S
LHL
(      ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(        ) S
1.000 0.000 0.000 FG
(contradiction) S
0.000 0.000 0.000 FG
(.) S
LHL
(      }) S
LHL
(    }) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( field_address) S
(0) S
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( \(field_compatible0_dec \(tarray \(tptr tcell\) N\) [ArraySubsc h] \(field_address thashta) S
SL
(ble [StructField _buckets] table\)\).) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
( ) S
0.698 0.133 0.133 FG
(\(* ) S
(field compatible ) S
(*\)) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(      normalize.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( FAT.) S
LHL
(      ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( field_compatible) S
(0) S
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( n.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(exfalso) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(apply) S
0.000 0.000 0.000 FG
( n.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(clear) S
0.000 0.000 0.000 FG
( n.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( FAT.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( FAT ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( H) S
(2) S
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( H) S
(2) S
( ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [? A].) S
LHL
(    ) S
0.706 0.322 0.804 FG
(repeat) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(destruct) S
0.000 0.000 0.000 FG
( A ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( [? A].) S
LHL
(    ) S
0.706 0.322 0.804 FG
(repeat) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(split) S
0.000 0.000 0.000 FG
(;) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(; ) S
0.706 0.322 0.804 FG
(try) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(  }) S
LHL
(  ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(    forward.) S
LHL
(    cancel.) S
PHL
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_rep.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( hashtable_incr.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_map ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(1) S
( ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( h ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(clear) S
0.000 0.000 0.000 FG
( h.) S
LHL
(    remember \(hashfun sigma mod N\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( h.) S
LHL
(    remember \(map fst cts\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( old_contents.) S
LHL
(    remember \(list_incr sigma \(Znth h old_contents\)\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( B.) S
LHL
(    remember \(field_address) S
(0) S
( \(tarray \(tptr tcell\) N\) [ArraySubsc h] \(field_address thashtable [St) S
SL
(ructField _buckets] table\)\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( Bp.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( listboxrep.) S
LHL
(    Intros p.) S
LHL
(    Exists \(upd_Znth h cts \(B, p\)\).) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( upd_Znth_map.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( Heqold_contents.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    normalize.) S
LHL
(    cancel.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(iter_sepcon_split) S
(3) S
( h \(upd_Znth h cts \(B, p\)\) \(uncurry listrep\)\).) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sublist_upd_Znth_l ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sublist_upd_Znth_r; ) S
0.706 0.322 0.804 FG
(try) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    cancel.) S
EndPage
EndDSCPage
EndSheet

%%Page: 28 28
/Lines 1987 def
/PageCount 28 def
1 BeginSheet
BeginDSCPage
/LineNumber 1928 def
/PageNumber 28 def
/HeaderLinesLeft[
 [/h0 (Verif_hash.v)]
 [/h1 (/mnt/c/Users/FordRL/e/digsim-jim/formal/hash/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1944 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    all: ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( upd_Znth_Zlength.) S
LHL
(    all: ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(1) S
(.) S
LHL
(    all: ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( N_eq ) S
0.133 0.545 0.133 FG
(in) S
0.000 0.000 0.000 FG
( *.) S
LHL
(    cancel.) S
LHL
(    2-6: ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( uncurry.) S
LHL
(    remember \(map snd cts\) ) S
0.133 0.545 0.133 FG
(as) S
0.000 0.000 0.000 FG
( old_bkps.) S
LHL
(    ) S
0.706 0.322 0.804 FG
(repeat) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( upd_Znth_same ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( \(upd_Znth_map snd\).) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( Heqold_bkps.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(unfold) S
0.000 0.000 0.000 FG
( array_with_hole.) S
LHL
(    normalize.) S
LHL
(    hint.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(autorewrite) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
( sublist.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( HeqBp.) S
LHL
(    ) S
0.706 0.322 0.804 FG
(repeat) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( upd_Znth_same ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(    allp_left [p].) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( sepcon_comm.) S
LHL
(    ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(data_at_singleton_array_eq Tsh \(tptr tcell\) p\) ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    sep_apply\(wand_frame_elim \(data_at Tsh \(tptr tcell\) p Bp\)) S
LHL
(                              \(data_at Tsh \(tarray \(tptr tcell\) 109\) \(sublist 0 h old_bkps ++ [p]) S
SL
( ++ sublist \(h + 1\) 109 old_bkps\)) S
LHL
(                                       \(field_address thashtable [StructField _buckets] table\)\)\).) S
LHL
(    ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(Zlength old_bkps = 109\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(subst) S
0.000 0.000 0.000 FG
( old_bkps.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_map; ) S
0.000 0.000 0.545 FG
(auto) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(\(sublist 0 h old_bkps ++ [p] ++ sublist \(h + 1\) 109 old_bkps\) =) S
LHL
(           \(upd_Znth h old_bkps p\)\). ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( ) S
[[(?)false] ] RLC
( \(sublist_same 0 109 old_bkps\) ) S
0.133 0.545 0.133 FG
(at) S
0.000 0.000 0.000 FG
( 3 ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(sublist_split 0 h 109 old_bkps\) ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(sublist_split h \(h+1\) 109 old_bkps\) ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( \(upd_Znth_app) S
(2) S
( \(sublist 0 h old_bkps\)\).) S
LHL
(      f_equal.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_sublist_correct.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(assert) S
0.000 0.000 0.000 FG
(\(h - \(h - 0\) = 0\). ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( H) S
(6) S
(; ) S
0.000 0.000 0.545 FG
(clear) S
0.000 0.000 0.000 FG
( H) S
(6) S
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( upd_Znth) S
(0) S
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(simpl) S
0.000 0.000 0.000 FG
(.) S
LHL
(      f_equal.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(autorewrite) S
0.000 0.000 0.000 FG
( ) S
0.133 0.545 0.133 FG
(with) S
0.000 0.000 0.000 FG
( sublist.) S
LHL
(      ) S
1.000 0.000 0.000 FG
(reflexivity) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_app.) S
LHL
(      ) S
0.706 0.322 0.804 FG
(repeat) S
0.000 0.000 0.000 FG
( ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( Zlength_sublist_correct ) S
1.000 0.000 0.000 FG
(by) S
0.000 0.000 0.000 FG
( ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(      ) S
1.000 0.000 0.000 FG
(omega) S
0.000 0.000 0.000 FG
(.) S
LHL
(    }) S
LHL
(    ) S
0.227 0.373 0.804 FG
({) S
0.000 0.000 0.000 FG
LHL
(      cancel.) S
LHL
(      ) S
0.000 0.000 0.545 FG
(rewrite) S
0.000 0.000 0.000 FG
( field_at_data_at.) S
LHL
(      entailer!.) S
LHL
(    }) S
LHL
(  }) S
LHL
(}) S
LHL
0.627 0.125 0.941 FG
(Qed) S
0.000 0.000 0.000 FG
(.) S
LHL
0.545 0.133 0.322 FG
(\(** [] *\)) S
0.000 0.000 0.000 FG
PHL
EndPage
EndDSCPage
EndSheet


%%Page: 1 29
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1 def
/PageNumber 1 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
0 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
0 EF
(;;; ps-print.el --- print text from the buffer as PostScript -*- lexical-binding: t -*-) S
PHL
LHL
(;; Copyright \(C\) 1993-2018 Free Software Foundation, Inc.) S
PHL
LHL
(;; Author: Jim Thompson \(was <thompson@wg2.waii.com>\)) S
LHL
(;;) S
6 W
(Jacques Duthen \(was <duthen@cegelec-red.fr>\)) S
LHL
(;;) S
6 W
(Vinicius Jose Latorre <viniciusjl@ig.com.br>) S
LHL
(;;) S
6 W
(Kenichi Handa <handa@m17n.org> \(multi-byte characters\)) S
LHL
(;; Maintainer: Kenichi Handa <handa@m17n.org> \(multi-byte characters\)) S
LHL
(;;) S
6 W
(Vinicius Jose Latorre <viniciusjl@ig.com.br>) S
LHL
(;; Keywords: wp, print, PostScript) S
LHL
(;; Version: 7.3.5) S
LHL
(;; X-URL: http://www.emacswiki.org/cgi-bin/wiki/ViniciusJoseLatorre) S
PHL
LHL
(\(defconst ps-print-version "7.3.5") S
LHL
(  "ps-print.el, v 7.3.5 <2009/12/23 vinicius>) S
PHL
LHL
(Vinicius's last change version -- this file may have been edited as part of) S
LHL
(Emacs without changes to the version number.  When reporting bugs, please also) S
LHL
(report the version of Emacs, if any, that ps-print was distributed with.) S
PHL
LHL
(Please send all bug fixes and enhancements to) S
LHL
8 W
(bug-gnu-emacs@gnu.org and Vinicius Jose Latorre <viniciusjl@ig.com.br>."\)) S
PHL
LHL
(;; This file is part of GNU Emacs.) S
PHL
LHL
(;; GNU Emacs is free software: you can redistribute it and/or modify) S
LHL
(;; it under the terms of the GNU General Public License as published by) S
LHL
(;; the Free Software Foundation, either version 3 of the License, or) S
LHL
(;; \(at your option\) any later version.) S
PHL
LHL
(;; GNU Emacs is distributed in the hope that it will be useful,) S
LHL
(;; but WITHOUT ANY WARRANTY; without even the implied warranty of) S
LHL
(;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the) S
LHL
(;; GNU General Public License for more details.) S
PHL
LHL
(;; You should have received a copy of the GNU General Public License) S
LHL
(;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.) S
PHL
LHL
(;;; Commentary:) S
PHL
LHL
(;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;) S
LHL
(;;) S
LHL
(;; About ps-print) S
LHL
(;; --------------) S
LHL
(;;) S
LHL
(;; This package provides printing of Emacs buffers on PostScript printers; the) S
LHL
(;; buffer's bold and italic text attributes are preserved in the printer) S
LHL
(;; output.  ps-print is intended for use with Emacs or XEmacs, together with a) S
LHL
(;; fontifying package such as font-lock or hilit.) S
LHL
(;;) S
LHL
(;; ps-print uses the same face attributes defined through font-lock or hilit to) S
LHL
(;; print a PostScript file, but some faces are better seeing on the screen than) S
LHL
(;; on paper, specially when you have a black/white PostScript printer.) S
LHL
(;;) S
LHL
(;; ps-print allows a remap of face to another one that it is better to print,) S
LHL
(;; for example, the face font-lock-comment-face \(if you are using font-lock\)) S
LHL
(;; could have bold or italic attribute when printing, besides foreground color.) S
LHL
(;; This remap improves printing look \(see How Ps-Print Maps Faces\).) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Using ps-print) S
LHL
(;; --------------) S
LHL
(;;) S
LHL
(;; ps-print provides eight commands for generating PostScript images of Emacs) S
LHL
(;; buffers:) S
LHL
(;;) S
LHL
(;;        ps-print-buffer) S
LHL
(;;        ps-print-buffer-with-faces) S
LHL
(;;        ps-print-region) S
LHL
(;;        ps-print-region-with-faces) S
LHL
(;;        ps-spool-buffer) S
EndPage
EndDSCPage
EndSheet

%%Page: 2 30
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 73 def
/PageNumber 2 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
72 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;        ps-spool-buffer-with-faces) S
LHL
(;;        ps-spool-region) S
LHL
(;;        ps-spool-region-with-faces) S
LHL
(;;) S
LHL
(;; These commands all perform essentially the same function: they generate) S
LHL
(;; PostScript images suitable for printing on a PostScript printer or) S
LHL
(;; displaying with GhostScript.  These commands are collectively referred to as) S
LHL
(;; "ps-print- commands".) S
LHL
(;;) S
LHL
(;; The word "print" or "spool" in the command name determines when the) S
LHL
(;; PostScript image is sent to the printer:) S
LHL
(;;) S
LHL
(;;        print      - The PostScript image is immediately sent to the printer;) S
LHL
(;;) S
LHL
(;;        spool      - The PostScript image is saved temporarily in an Emacs) S
LHL
(;;                     buffer.  Many images may be spooled locally before) S
LHL
(;;                     printing them.  To send the spooled images to the) S
LHL
(;;                     printer, use the command `ps-despool'.) S
LHL
(;;) S
LHL
(;; The spooling mechanism was designed for printing lots of small files \(mail) S
LHL
(;; messages or netnews articles\) to save paper that would otherwise be wasted) S
LHL
(;; on banner pages, and to make it easier to find your output at the printer) S
LHL
(;; \(it's easier to pick up one 50-page printout than to find 50 single-page) S
LHL
(;; printouts\).) S
LHL
(;;) S
LHL
(;; ps-print has a hook in the `kill-emacs-hook' so that you won't accidentally) S
LHL
(;; quit from Emacs while you have unprinted PostScript waiting in the spool) S
LHL
(;; buffer.  If you do attempt to exit with spooled PostScript, you'll be asked) S
LHL
(;; if you want to print it, and if you decline, you'll be asked to confirm the) S
LHL
(;; exit; this is modeled on the confirmation that Emacs uses for modified) S
LHL
(;; buffers.) S
LHL
(;;) S
LHL
(;; The word "buffer" or "region" in the command name determines how much of the) S
LHL
(;; buffer is printed:) S
LHL
(;;) S
LHL
(;;        buffer     - Print the entire buffer.) S
LHL
(;;) S
LHL
(;;        region     - Print just the current region.) S
LHL
(;;) S
LHL
(;; The -with-faces suffix on the command name means that the command will) S
LHL
(;; include font, color, and underline information in the PostScript image, so) S
LHL
(;; the printed image can look as pretty as the buffer.  The ps-print- commands) S
LHL
(;; without the -with-faces suffix don't include font, color, or underline) S
LHL
(;; information; images printed with these commands aren't as pretty, but are) S
LHL
(;; faster to generate.) S
LHL
(;;) S
LHL
(;; Two ps-print- command examples:) S
LHL
(;;) S
LHL
(;;        ps-print-buffer             - print the entire buffer, without font,) S
LHL
(;;                                      color, or underline information, and) S
LHL
(;;                                      send it immediately to the printer.) S
LHL
(;;) S
LHL
(;;        ps-spool-region-with-faces  - print just the current region; include) S
LHL
(;;                                      font, color, and underline information,) S
LHL
(;;                                      and spool the image in Emacs to send to) S
LHL
(;;                                      the printer later.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Invoking Ps-Print) S
LHL
(;; -----------------) S
LHL
(;;) S
LHL
(;; To print your buffer, type) S
LHL
(;;) S
LHL
(;;        M-x ps-print-buffer) S
LHL
(;;) S
LHL
(;; or substitute one of the other seven ps-print- commands.  The command will) S
LHL
(;; generate the PostScript image and print or spool it as specified.  By giving) S
LHL
(;; the command a prefix argument) S
LHL
(;;) S
LHL
(;;        C-u M-x ps-print-buffer) S
LHL
(;;) S
LHL
(;; it will save the PostScript image to a file instead of sending it to the) S
EndPage
EndDSCPage
EndSheet

%%Page: 3 31
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 145 def
/PageNumber 3 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
144 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;; printer; you will be prompted for the name of the file to save the image to.) S
LHL
(;; The prefix argument is ignored by the commands that spool their images, but) S
LHL
(;; you may save the spooled images to a file by giving a prefix argument to) S
LHL
(;; `ps-despool':) S
LHL
(;;) S
LHL
(;;        C-u M-x ps-despool) S
LHL
(;;) S
LHL
(;; When invoked this way, `ps-despool' will prompt you for the name of the file) S
LHL
(;; to save to.) S
LHL
(;;) S
LHL
(;; Any of the `ps-print-' commands can be bound to keys; I recommend binding) S
LHL
(;; `ps-spool-buffer-with-faces', `ps-spool-region-with-faces', and) S
LHL
(;; `ps-despool'.  Here are the bindings I use on my Sun 4 keyboard:) S
LHL
(;;) S
LHL
(;;   \(global-set-key 'f22 'ps-spool-buffer-with-faces\) ;f22 is prsc) S
LHL
(;;   \(global-set-key '\(shift f22\) 'ps-spool-region-with-faces\)) S
LHL
(;;   \(global-set-key '\(control f22\) 'ps-despool\)) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; The Printer Interface) S
LHL
(;; ---------------------) S
LHL
(;;) S
LHL
(;; The variables `ps-lpr-command' and `ps-lpr-switches' determine what command) S
LHL
(;; is used to send the PostScript images to the printer, and what arguments to) S
LHL
(;; give the command.  These are analogous to `lpr-command' and `lpr-switches'.) S
LHL
(;;) S
LHL
(;; Make sure that they contain appropriate values for your system;) S
LHL
(;; see the usage notes below and the documentation of these variables.) S
LHL
(;;) S
LHL
(;; The variable `ps-printer-name' determines the name of a local printer for) S
LHL
(;; printing PostScript files.) S
LHL
(;;) S
LHL
(;; The variable `ps-printer-name-option' determines the option used by some) S
LHL
(;; utilities to indicate the printer name, it's used only when) S
LHL
(;; `ps-printer-name' is a non-empty string.  If you're using lpr utility to) S
LHL
(;; print, for example, `ps-printer-name-option' should be set to "-P".) S
LHL
(;;) S
LHL
(;; NOTE: `ps-lpr-command' and `ps-lpr-switches' take their initial values from) S
LHL
(;;       the variables `lpr-command' and `lpr-switches'.  If you have) S
LHL
(;;       `lpr-command' set to invoke a pretty-printer such as `enscript', then) S
LHL
(;;       ps-print won't work properly.  `ps-lpr-command' must name a program) S
LHL
(;;       that does not format the files it prints.) S
LHL
(;;       `ps-printer-name' takes its initial value from the variable) S
LHL
(;;       `printer-name'.  `ps-printer-name-option' tries to guess which system) S
LHL
(;;       Emacs is running and takes its initial value in accordance with this) S
LHL
(;;       guess.) S
LHL
(;;) S
LHL
(;; The variable `ps-print-region-function' specifies a function to print the) S
LHL
(;; region on a PostScript printer.) S
LHL
(;; See definition of `call-process-region' for calling conventions.  The fourth) S
LHL
(;; and the sixth arguments are both nil.) S
LHL
(;;) S
LHL
(;; The variable `ps-manual-feed' indicates if the printer will manually feed) S
LHL
(;; paper.  If it's nil, automatic feeding takes place.  If it's non-nil, manual) S
LHL
(;; feeding takes place.  The default is nil \(automatic feeding\).) S
LHL
(;;) S
LHL
(;; The variable `ps-end-with-control-d' specifies whether C-d \(\\x04\) should be) S
LHL
(;; inserted at end of PostScript generated.  Non-nil means do so.  The default) S
LHL
(;; is nil \(don't insert\).) S
LHL
(;;) S
LHL
(;; If you're using Emacs for Windows 95/98/NT or MS-DOS, don't forget to) S
LHL
(;; customize the following variables: `ps-printer-name',) S
LHL
(;; `ps-printer-name-option', `ps-lpr-command', `ps-lpr-switches' and) S
LHL
(;; `ps-spool-config'.  See these variables documentation in the code or by) S
LHL
(;; typing, for example, C-h v ps-printer-name RET.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; The Page Layout) S
LHL
(;; ---------------) S
LHL
(;;) S
LHL
(;; All dimensions are floats in PostScript points.) S
LHL
(;; 1 inch  ==       2.54  cm    ==     72       points) S
EndPage
EndDSCPage
EndSheet

%%Page: 4 32
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 217 def
/PageNumber 4 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
216 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;; 1 cm    ==  \(/ 1 2.54\) inch  ==  \(/ 72 2.54\) points) S
LHL
(;;) S
LHL
(;; The variable `ps-paper-type' determines the size of paper ps-print formats) S
LHL
(;; for; it should contain one of the symbols: `a4' `a3' `letter' `legal') S
LHL
(;; `letter-small' `tabloid' `ledger' `statement' `executive' `a4small' `b4') S
LHL
(;; `b5'.) S
LHL
(;;) S
LHL
(;; If variable `ps-warn-paper-type' is nil, it's *not* given an error if) S
LHL
(;; PostScript printer doesn't have a paper with the size indicated by) S
LHL
(;; `ps-paper-type', instead it uses the default paper size.  If variable) S
LHL
(;; `ps-warn-paper-type' is non-nil, it's given an error if PostScript printer) S
LHL
(;; doesn't have a paper with the size indicated by `ps-paper-type'.  It's used) S
LHL
(;; when `ps-spool-config' is set to `setpagedevice' \(see section Duplex) S
LHL
(;; Printers\).  The default value is non-nil \(it gives an error\).) S
LHL
(;;) S
LHL
(;; The variable `ps-landscape-mode' determines the orientation of the printing) S
LHL
(;; on the page: nil means `portrait' mode, non-nil means `landscape' mode.) S
LHL
(;; There is no oblique mode yet, though this is easy to do in ps.) S
LHL
(;;) S
LHL
(;; In landscape mode, the text is NOT scaled: you may print 70 lines in) S
LHL
(;; portrait mode and only 50 lines in landscape mode.  The margins represent) S
LHL
(;; margins in the printed paper: the top margin is the margin between the top) S
LHL
(;; of the page and the printed header, whatever the orientation is.) S
LHL
(;;) S
LHL
(;; The variable `ps-number-of-columns' determines the number of columns both in) S
LHL
(;; landscape and portrait mode.) S
LHL
(;; You can use:) S
LHL
(;; - \(the standard\) one column portrait mode.) S
LHL
(;; - \(my favorite\) two columns landscape mode \(which spares trees\).) S
LHL
(;; but also:) S
LHL
(;; - one column landscape mode for files with very long lines.) S
LHL
(;; - multi-column portrait or landscape mode.) S
LHL
(;;) S
LHL
(;; The variable `ps-print-upside-down' determines other orientation for) S
LHL
(;; printing page: nil means `normal' printing, non-nil means `upside-down') S
LHL
(;; printing \(that is, the page is rotated by 180 grades\).  The default value is) S
LHL
(;; nil \(`normal' printing\).) S
LHL
(;;) S
LHL
(;; The `upside-down' orientation can be used in portrait or landscape mode.) S
LHL
(;;) S
LHL
(;; The variable `ps-selected-pages' specifies which pages to print.  If it's) S
LHL
(;; nil, all pages are printed.  If it's a list, the list element may be an) S
LHL
(;; integer or a cons cell \(FROM . TO\) designating FROM page to TO page; any) S
LHL
(;; invalid element is ignored, that is, an integer lesser than one or if FROM) S
LHL
(;; is greater than TO.  Otherwise, it's treated as nil.  The default value is) S
LHL
(;; nil \(print all pages\).  After ps-print processing `ps-selected-pages' is set) S
LHL
(;; to nil.  But the latest `ps-selected-pages' is saved in) S
LHL
(;; `ps-last-selected-pages' \(see it for documentation\).  So you can restore the) S
LHL
(;; latest selected pages by using `ps-last-selected-pages' or by calling) S
LHL
(;; `ps-restore-selected-pages' command \(see it for documentation\).) S
LHL
(;;) S
LHL
(;; The variable `ps-even-or-odd-pages' specifies if it prints even/odd pages.) S
LHL
(;;) S
LHL
(;; Valid values are:) S
LHL
(;;) S
LHL
(;; nil) S
10 W
(print all pages.) S
LHL
(;;) S
LHL
(;; even-page) S
4 W
(print only even pages.) S
LHL
(;;) S
LHL
(;; odd-page) S
5 W
(print only odd pages.) S
LHL
(;;) S
LHL
(;; even-sheet) S
3 W
(print only even sheets.) S
LHL
(;;) S
LHL
(;; odd-sheet) S
4 W
(print only odd sheets.) S
LHL
(;;) S
LHL
(;; Any other value is treated as nil.  The default value is nil.) S
LHL
(;;) S
LHL
(;; See `ps-even-or-odd-pages' for more detailed documentation.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Horizontal layout) S
LHL
(;; -----------------) S
EndPage
EndDSCPage
EndSheet

%%Page: 5 33
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 289 def
/PageNumber 5 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
288 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;) S
LHL
(;; The horizontal layout is determined by the variables) S
LHL
(;; `ps-left-margin' `ps-inter-column' `ps-right-margin') S
LHL
(;; as follows:) S
LHL
(;;) S
LHL
(;;  ------------------------------------------) S
LHL
(;;  |    |      |    |      |    |      |    |) S
LHL
(;;  | lm | text | ic | text | ic | text | rm |) S
LHL
(;;  |    |      |    |      |    |      |    |) S
LHL
(;;  ------------------------------------------) S
LHL
(;;) S
LHL
(;; If `ps-number-of-columns' is 1, `ps-inter-column' is not relevant.) S
LHL
(;; Usually, lm = rm > 0 and ic = lm) S
LHL
(;; If \(ic < 0\), the text of adjacent columns can overlap.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Vertical layout) S
LHL
(;; ---------------) S
LHL
(;;) S
LHL
(;; The vertical layout is determined by the variables) S
LHL
(;; `ps-bottom-margin' `ps-top-margin' `ps-header-offset' `ps-footer-offset') S
LHL
(;; as follows:) S
LHL
(;;) S
LHL
(;; |--------|        |--------|        |--------|        |--------|) S
LHL
(;; | tm     |        | tm     |        | tm     |        | tm     |) S
LHL
(;; |--------|        |--------|        |--------|        |--------|) S
LHL
(;; | header |        |        |        | header |        |        |) S
LHL
(;; |--------|        |        |        |--------|        |        |) S
LHL
(;; | ho     |        |        |        | ho     |        |        |) S
LHL
(;; |--------|        |        |        |--------|        |        |) S
LHL
(;; |        |        |        |        |        |        |        |) S
LHL
(;; | text   |   or   | text   |   or   | text   |   or   | text   |) S
LHL
(;; |        |        |        |        |        |        |        |) S
LHL
(;; |        |        |--------|        |--------|        |        |) S
LHL
(;; |        |        | fo     |        | fo     |        |        |) S
LHL
(;; |        |        |--------|        |--------|        |        |) S
LHL
(;; |        |        | footer |        | footer |        |        |) S
LHL
(;; |--------|        |--------|        |--------|        |--------|) S
LHL
(;; | bm     |        | bm     |        | bm     |        | bm     |) S
LHL
(;; |--------|        |--------|        |--------|        |--------|) S
LHL
(;;) S
LHL
(;; If `ps-print-header' is nil, `ps-header-offset' is not relevant.) S
LHL
(;; If `ps-print-footer' is nil, `ps-footer-offset' is not relevant.) S
LHL
(;; The margins represent margins in the printed paper:) S
LHL
(;; the top margin is the margin between the top of the page and the printed) S
LHL
(;; header, whatever the orientation is;) S
LHL
(;; the bottom margin is the margin between the bottom of the page and the) S
LHL
(;; printed footer, whatever the orientation is.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Headers & Footers) S
LHL
(;; -----------------) S
LHL
(;;) S
LHL
(;; ps-print can print headers at the top of each column or at the top of each) S
LHL
(;; page; the default headers contain the following four items: on the left, the) S
LHL
(;; name of the buffer and, if the buffer is visiting a file, the file's) S
LHL
(;; directory; on the right, the page number and date of printing.  The default) S
LHL
(;; headers look something like this:) S
LHL
(;;) S
LHL
(;;     ps-print.el                                         1/21) S
LHL
(;;     /home/jct/emacs-lisp/ps/new                     94/12/31) S
LHL
(;;) S
LHL
(;; When printing on duplex printers, left and right are reversed so that the) S
LHL
(;; page numbers are toward the outside \(cf. `ps-spool-duplex'\).) S
LHL
(;;) S
LHL
(;; Headers are configurable:) S
LHL
(;; To turn them off completely, set `ps-print-header' to nil.) S
LHL
(;; To turn off the header's gaudy framing box,) S
LHL
(;; set `ps-print-header-frame' to nil.) S
LHL
(;;) S
LHL
(;; The variable `ps-header-frame-alist' specifies header frame properties) S
LHL
(;; alist.  Valid frame properties are:) S
EndPage
EndDSCPage
EndSheet

%%Page: 6 34
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 361 def
/PageNumber 6 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
360 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;) S
LHL
(;;   fore-color) S
9 W
(Specify the foreground frame color.) S
LHL
(;;) S
22 W
(It should be a float number between 0.0 \(black color\)) S
LHL
(;;) S
22 W
(and 1.0 \(white color\), a string which is a color name,) S
LHL
(;;) S
22 W
(or a list of 3 float numbers which corresponds to the) S
LHL
(;;) S
22 W
(Red Green Blue color scale, each float number between) S
LHL
(;;) S
22 W
(0.0 \(dark color\) and 1.0 \(bright color\).) S
LHL
(;;) S
22 W
(The default is 0 \("black"\).) S
LHL
(;;) S
LHL
(;;   back-color) S
9 W
(Specify the background frame color \(similar to) S
LHL
(;;) S
22 W
(fore-color\).  The default is 0.9 \("gray90"\).) S
LHL
(;;) S
LHL
(;;   shadow-color) S
7 W
(Specify the shadow color \(similar to fore-color\).) S
LHL
(;;) S
22 W
(The default is 0 \("black"\).) S
LHL
(;;) S
LHL
(;;   border-color) S
7 W
(Specify the border color \(similar to fore-color\).) S
LHL
(;;) S
22 W
(The default is 0 \("black"\).) S
LHL
(;;) S
LHL
(;;   border-width) S
7 W
(Specify the border width.) S
LHL
(;;) S
22 W
(The default is 0.4.) S
LHL
(;;) S
LHL
(;; Any other property is ignored.) S
LHL
(;;) S
LHL
(;; Don't change this alist directly, instead use customization, or `ps-value',) S
LHL
(;; `ps-get', `ps-put' and `ps-del' functions \(see them for documentation\).) S
LHL
(;;) S
LHL
(;; To print only one header at the top of each page, set) S
LHL
(;; `ps-print-only-one-header' to t.) S
LHL
(;;) S
LHL
(;; To switch headers, set `ps-switch-header' to:) S
LHL
(;;) S
LHL
(;;    nil) S
7 W
(Never switch headers.) S
LHL
(;;) S
LHL
(;;    t) S
9 W
(Always switch headers.) S
LHL
(;;) S
LHL
(;;    duplex) S
4 W
(Switch headers only when duplexing is on, that is, when) S
LHL
(;;) S
14 W
(`ps-spool-duplex' is non-nil \(see Duplex Printers\).) S
LHL
(;;) S
LHL
(;; Any other value is treated as t.  The default value is `duplex'.) S
LHL
(;;) S
LHL
(;; The font family and size of text in the header are determined by the) S
LHL
(;; variables `ps-header-font-family', `ps-header-font-size' and) S
LHL
(;; `ps-header-title-font-size' \(see below\).) S
LHL
(;;) S
LHL
(;; The variable `ps-header-line-pad' determines the portion of a header title) S
LHL
(;; line height to insert between the header frame and the text it contains,) S
LHL
(;; both in the vertical and horizontal directions: .5 means half a line.) S
LHL
(;;) S
LHL
(;; Page numbers are printed in `n/m' format, indicating page n of m pages; to) S
LHL
(;; omit the total page count and just print the page number, set) S
LHL
(;; `ps-show-n-of-n' to nil.) S
LHL
(;;) S
LHL
(;; The amount of information in the header can be changed by changing the) S
LHL
(;; number of lines.  To show less, set `ps-header-lines' to 1, and the header) S
LHL
(;; will show only the buffer name and page number.  To show more, set) S
LHL
(;; `ps-header-lines' to 3, and the header will show the time of printing below) S
LHL
(;; the date.) S
LHL
(;;) S
LHL
(;; To change the content of the headers, change the variables `ps-left-header') S
LHL
(;; and `ps-right-header'.) S
LHL
(;; These variables are lists, specifying top-to-bottom the text to display on) S
LHL
(;; the left or right side of the header.  Each element of the list should be a) S
LHL
(;; string or a symbol.  Strings are inserted directly into the PostScript) S
LHL
(;; arrays, and should contain the PostScript string delimiters '\(' and '\)'.) S
LHL
(;;) S
LHL
(;; Symbols in the header format lists can either represent functions or) S
LHL
(;; variables.  Functions are called, and should return a string to show in the) S
LHL
(;; header.  Variables should contain strings to display in the header.  In) S
LHL
(;; either case, function or variable, the PostScript string delimiters are) S
LHL
(;; added by ps-print, and should not be part of the returned value.) S
LHL
(;;) S
LHL
(;; Here's an example: say we want the left header to display the text) S
EndPage
EndDSCPage
EndSheet

%%Page: 7 35
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 433 def
/PageNumber 7 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
432 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;) S
LHL
(;;     Moe) S
LHL
(;;     Larry) S
LHL
(;;     Curly) S
LHL
(;;) S
LHL
(;; where we have a function to return "Moe") S
LHL
(;;) S
LHL
(;;     \(defun moe-func \(\)) S
LHL
(;;       "Moe"\)) S
LHL
(;;) S
LHL
(;; a variable specifying "Larry") S
LHL
(;;) S
LHL
(;;     \(setq larry-var "Larry"\)) S
LHL
(;;) S
LHL
(;; and a literal for "Curly".  Here's how `ps-left-header' should be set:) S
LHL
(;;) S
LHL
(;;     \(setq ps-left-header \(list 'moe-func 'larry-var "\(Curly\)"\)\)) S
LHL
(;;) S
LHL
(;; Note that Curly has the PostScript string delimiters inside his quotes --) S
LHL
(;; those aren't misplaced lisp delimiters!) S
LHL
(;;) S
LHL
(;; Without them, PostScript would attempt to call the undefined function Curly,) S
LHL
(;; which would result in a PostScript error.) S
LHL
(;;) S
LHL
(;; Since most printers don't report PostScript errors except by aborting the) S
LHL
(;; print job, this kind of error can be hard to track down.) S
LHL
(;;) S
LHL
(;; Consider yourself warned!) S
LHL
(;;) S
LHL
(;; ps-print also print footers.  The footer variables are: `ps-print-footer',) S
LHL
(;; `ps-footer-offset', `ps-print-footer-frame', `ps-footer-font-family',) S
LHL
(;; `ps-footer-font-size', `ps-footer-line-pad', `ps-footer-lines',) S
LHL
(;; `ps-left-footer', `ps-right-footer' and `ps-footer-frame-alist'.  These) S
LHL
(;; variables are similar to those one that control headers.) S
LHL
(;;) S
LHL
(;; The variables `ps-print-only-one-header' and `ps-switch-header' also control) S
LHL
(;; the footer \(The same way that control header\).) S
LHL
(;;) S
LHL
(;; As a footer example, if you want to have a centered page number in the) S
LHL
(;; footer but without headers, set:) S
LHL
(;;) S
LHL
(;;    \(setq ps-print-header nil) S
LHL
(;;          ps-print-footer t) S
LHL
(;;          ps-print-footer-frame nil) S
LHL
(;;          ps-footer-lines 1) S
LHL
(;;          ps-right-footer nil) S
LHL
(;;          ps-left-footer) S
LHL
(;;          \(list \(concat "{pagenumberstring dup stringwidth pop") S
LHL
(;;                        " 2 div PrintWidth 2 div exch sub 0 rmoveto}"\)\)\)) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; PostScript Prologue Header) S
LHL
(;; --------------------------) S
LHL
(;;) S
LHL
(;; It is possible to add PostScript prologue header comments besides that) S
LHL
(;; ps-print generates by setting the variable `ps-print-prologue-header'.) S
LHL
(;;) S
LHL
(;; `ps-print-prologue-header' may be a string or a symbol function which) S
LHL
(;; returns a string.  Note that this string is inserted on PostScript prologue) S
LHL
(;; header section which is used to define some document characteristic through) S
LHL
(;; PostScript special comments, like "%%Requirements: jog\\n".) S
LHL
(;;) S
LHL
(;; By default `ps-print-prologue-header' is nil.) S
LHL
(;;) S
LHL
(;; ps-print always inserts the %%Requirements: comment, so if you need to) S
LHL
(;; insert more requirements put them first in `ps-print-prologue-header' using) S
LHL
(;; the "%%+" comment.  For example, if you need to set numcopies to 3 and jog) S
LHL
(;; on requirements and set %%LanguageLevel: to 2, do:) S
LHL
(;;) S
LHL
(;; \(setq ps-print-prologue-header) S
LHL
(;;       "%%+ numcopies\(3\) jog\\n%%LanguageLevel: 2\\n"\)) S
LHL
(;;) S
EndPage
EndDSCPage
EndSheet

%%Page: 8 36
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 505 def
/PageNumber 8 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
504 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;; The duplex requirement is inserted by ps-print \(see section Duplex) S
LHL
(;; Printers\).) S
LHL
(;;) S
LHL
(;; Do not forget to terminate the string with "\\n".) S
LHL
(;;) S
LHL
(;; For more information about PostScript document comments, see:) S
LHL
(;;    PostScript Language Reference Manual \(2nd edition\)) S
LHL
(;;    Adobe Systems Incorporated) S
LHL
(;;    Appendix G: Document Structuring Conventions -- Version 3.0) S
LHL
(;;) S
LHL
(;; It is also possible to add an user defined PostScript prologue code before) S
LHL
(;; all generated prologue code by setting the variable) S
LHL
(;; `ps-user-defined-prologue'.) S
LHL
(;;) S
LHL
(;; `ps-user-defined-prologue' may be a string or a symbol function which) S
LHL
(;; returns a string.  Note that this string is inserted after `ps-adobe-tag') S
LHL
(;; and PostScript prologue comments, and before ps-print PostScript prologue) S
LHL
(;; code section.  That is, this string is inserted after error handler) S
LHL
(;; initialization and before ps-print settings.) S
LHL
(;;) S
LHL
(;; By default `ps-user-defined-prologue' is nil.) S
LHL
(;;) S
LHL
(;; It's strongly recommended only insert PostScript code and/or comments) S
LHL
(;; specific for your printing system particularities.  For example, some) S
LHL
(;; special initialization that only your printing system needs.) S
LHL
(;;) S
LHL
(;; Do not insert code for duplex printing, n-up printing or error handler,) S
LHL
(;; ps-print handles this in a suitable way.) S
LHL
(;;) S
LHL
(;; For more information about PostScript, see:) S
LHL
(;;    PostScript Language Reference Manual \(2nd edition\)) S
LHL
(;;    Adobe Systems Incorporated) S
LHL
(;;) S
LHL
(;; As an example for `ps-user-defined-prologue' setting:) S
LHL
(;;) S
LHL
(;;   ;; Setting for HP PostScript printer) S
LHL
(;;   \(setq ps-user-defined-prologue) S
LHL
(;;) S
9 W
(\(concat "<</DeferredMediaSelection true /PageSize [612 792] ") S
LHL
(;;) S
17 W
("/MediaPosition 2 /MediaType \(Plain\)>> setpagedevice"\)\)) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; PostScript Error Handler) S
LHL
(;; ------------------------) S
LHL
(;;) S
LHL
(;; ps-print instruments generated PostScript code with an error handler.) S
LHL
(;;) S
LHL
(;; The variable `ps-error-handler-message' specifies where the error handler) S
LHL
(;; message should be sent.) S
LHL
(;;) S
LHL
(;; Valid values are:) S
LHL
(;;) S
LHL
(;; none) S
17 W
(catch the error and *DON'T* send any message.) S
LHL
(;;) S
LHL
(;; paper) S
16 W
(catch the error and print on paper the error message.) S
LHL
(;;) S
22 W
(This is the default value.) S
LHL
(;;) S
LHL
(;; system) S
15 W
(catch the error and send back the error message to) S
LHL
(;;) S
22 W
(printing system.  This is useful only if printing) S
LHL
(;;) S
22 W
(system send back an email reporting the error, or if) S
LHL
(;;) S
22 W
(there is some other alternative way to report back the) S
LHL
(;;) S
22 W
(error from the system to you.) S
LHL
(;;) S
LHL
(;; paper-and-system) S
5 W
(catch the error, print on paper the error message and) S
LHL
(;;) S
22 W
(send back the error message to printing system.) S
LHL
(;;) S
LHL
(;; Any other value is treated as `paper'.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Duplex Printers) S
LHL
(;; ---------------) S
LHL
(;;) S
LHL
(;; If you have a duplex-capable printer \(one that prints both sides of the) S
EndPage
EndDSCPage
EndSheet

%%Page: 9 37
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 577 def
/PageNumber 9 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
576 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;; paper\), set `ps-spool-duplex' to t.) S
LHL
(;; ps-print will insert blank pages to make sure each buffer starts on the) S
LHL
(;; correct side of the paper.) S
LHL
(;;) S
LHL
(;; The variable `ps-spool-config' specifies who is the responsible for setting) S
LHL
(;; duplex and page size.  Valid values are:) S
LHL
(;;) S
LHL
(;; lpr-switches    duplex and page size are configured by `ps-lpr-switches'.) S
LHL
(;;                 Don't forget to set `ps-lpr-switches' to select duplex) S
LHL
(;;                 printing for your printer.) S
LHL
(;;) S
LHL
(;; setpagedevice   duplex and page size are configured by ps-print using the) S
LHL
(;;                 setpagedevice PostScript operator.) S
LHL
(;;) S
LHL
(;; nil             duplex and page size are configured by ps-print *not* using) S
LHL
(;;                 the setpagedevice PostScript operator.) S
LHL
(;;) S
LHL
(;; Any other value is treated as nil.) S
LHL
(;;) S
LHL
(;; The default value is `lpr-switches'.) S
LHL
(;;) S
LHL
(;; WARNING: The setpagedevice PostScript operator affects ghostview utility) S
LHL
(;;          when viewing file generated using landscape.  Also on some) S
LHL
(;;          printers, setpagedevice affects zebra stripes; on other printers,) S
LHL
(;;          setpagedevice affects the left margin.) S
LHL
(;;          Besides all that, if your printer does not have the paper size) S
LHL
(;;          specified by setpagedevice, your printing will be aborted.) S
LHL
(;;          So, if you need to use setpagedevice, set `ps-spool-config' to) S
LHL
(;;          `setpagedevice', generate a test file and send it to your printer;) S
LHL
(;;          if the printed file isn't ok, set `ps-spool-config' to nil.) S
LHL
(;;) S
LHL
(;; The variable `ps-spool-tumble' specifies how the page images on opposite) S
LHL
(;; sides of a sheet are oriented with respect to each other.  If) S
LHL
(;; `ps-spool-tumble' is nil, produces output suitable for binding on the left) S
LHL
(;; or right.  If `ps-spool-tumble' is non-nil, produces output suitable for) S
LHL
(;; binding at the top or bottom.  It has effect only when `ps-spool-duplex' is) S
LHL
(;; non-nil.  The default value is nil.) S
LHL
(;;) S
LHL
(;; Some printer system prints a header page and forces the first page be) S
LHL
(;; printed on header page back, when using duplex.  If your printer system has) S
LHL
(;; this behavior, set variable `ps-banner-page-when-duplexing' to t.) S
LHL
(;;) S
LHL
(;; When `ps-banner-page-when-duplexing' is non-nil, it prints a blank page as) S
LHL
(;; the very first printed page.  So, it behaves as the very first character of) S
LHL
(;; buffer \(or region\) is ^L \(\\014\).) S
LHL
(;;) S
LHL
(;; The default for `ps-banner-page-when-duplexing' is nil \(*don't* skip the) S
LHL
(;; very first page\).) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; N-up Printing) S
LHL
(;; -------------) S
LHL
(;;) S
LHL
(;; The variable `ps-n-up-printing' specifies the number of pages per sheet of) S
LHL
(;; paper.  The value specified must be between 1 and 100.  The default is 1.) S
LHL
(;;) S
LHL
(;; NOTE: some PostScript printer may crash printing if `ps-n-up-printing' is) S
LHL
(;; set to a high value \(for example, 23\).  If this happens, set a lower value.) S
LHL
(;;) S
LHL
(;; The variable `ps-n-up-margin' specifies the margin in points between the) S
LHL
(;; sheet border and the n-up printing.  The default is 1 cm \(or 0.3937 inches,) S
LHL
(;; or 28.35 points\).) S
LHL
(;;) S
LHL
(;; If variable `ps-n-up-border-p' is non-nil a border is drawn around each) S
LHL
(;; page.  The default is t.) S
LHL
(;;) S
LHL
(;; The variable `ps-n-up-filling' specifies how page matrix is filled on each) S
LHL
(;; sheet of paper.  Following are the valid values for `ps-n-up-filling' with a) S
LHL
(;; filling example using a 3x4 page matrix:) S
LHL
(;;) S
LHL
(;;  left-top   1  2  3  4         left-bottom    9  10 11 12) S
LHL
(;;             5  6  7  8                        5  6  7  8) S
EndPage
EndDSCPage
EndSheet

%%Page: 10 38
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 649 def
/PageNumber 10 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
648 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;             9  10 11 12                       1  2  3  4) S
LHL
(;;) S
LHL
(;;  right-top  4  3  2  1         right-bottom   12 11 10 9) S
LHL
(;;             8  7  6  5                        8  7  6  5) S
LHL
(;;             12 11 10 9                        4  3  2  1) S
LHL
(;;) S
LHL
(;;  top-left   1  4  7  10        bottom-left    3  6  9  12) S
LHL
(;;             2  5  8  11                       2  5  8  11) S
LHL
(;;             3  6  9  12                       1  4  7  10) S
LHL
(;;) S
LHL
(;;  top-right  10 7  4  1         bottom-right   12 9  6  3) S
LHL
(;;             11 8  5  2                        11 8  5  2) S
LHL
(;;             12 9  6  3                        10 7  4  1) S
LHL
(;;) S
LHL
(;; Any other value is treated as `left-top'.) S
LHL
(;;) S
LHL
(;; The default value is left-top.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Control And 8-bit Characters) S
LHL
(;; ----------------------------) S
LHL
(;;) S
LHL
(;; The variable `ps-print-control-characters' specifies whether you want to see) S
LHL
(;; a printable form for control and 8-bit characters, that is, instead of) S
LHL
(;; sending, for example, a ^D \(\\004\) to printer, it is sent the string "^D".) S
LHL
(;;) S
LHL
(;; Valid values for `ps-print-control-characters' are:) S
LHL
(;;) S
LHL
(;;  8-bit           This is the value to use when you want an ASCII encoding of) S
LHL
(;;                  any control or non-ASCII character. Control characters are) S
LHL
(;;                  encoded as "^D", and non-ASCII characters have an) S
LHL
(;;                  octal encoding.) S
LHL
(;;) S
LHL
(;;  control-8-bit   This is the value to use when you want an ASCII encoding of) S
LHL
(;;                  any control character, whether it is 7 or 8-bit.) S
LHL
(;;                  European 8-bits accented characters are printed according) S
LHL
(;;                  the current font.) S
LHL
(;;) S
LHL
(;;  control         Only ASCII control characters have an ASCII encoding.) S
LHL
(;;                  European 8-bits accented characters are printed according) S
LHL
(;;                  the current font.) S
LHL
(;;) S
LHL
(;;  nil             No ASCII encoding. Any character is printed according the) S
LHL
(;;                  current font.) S
LHL
(;;) S
LHL
(;; Any other value is treated as nil.) S
LHL
(;;) S
LHL
(;; The default is `control-8-bit'.) S
LHL
(;;) S
LHL
(;; Characters TAB, NEWLINE and FORMFEED are always treated by ps-print engine.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Printing Multi-byte Buffer) S
LHL
(;; --------------------------) S
LHL
(;;) S
LHL
(;; See ps-mule.el for documentation.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Line Number) S
LHL
(;; -----------) S
LHL
(;;) S
LHL
(;; The variable `ps-line-number' specifies whether to number each line;) S
LHL
(;; non-nil means do so.  The default is nil \(don't number each line\).) S
LHL
(;;) S
LHL
(;; The variable `ps-line-number-color' specifies the color for line number.) S
LHL
(;; See `ps-zebra-color' for documentation.  The default is "black" \(or 0.0, or) S
LHL
(;; '\(0.0 0.0 0.0\)\).) S
LHL
(;;) S
LHL
(;; The variable `ps-line-number-font' specifies the font for line number.) S
LHL
(;; The default is "Times-Italic".) S
LHL
(;;) S
LHL
(;; The variable `ps-line-number-font-size' specifies the font size in points) S
EndPage
EndDSCPage
EndSheet

%%Page: 11 39
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 721 def
/PageNumber 11 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
720 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;; for line number.  See `ps-font-size' for documentation.  The default is 6.) S
LHL
(;;) S
LHL
(;; The variable `ps-line-number-step' specifies the interval that line number) S
LHL
(;; is printed.  For example, if `ps-line-number-step' is set to 2, the printing) S
LHL
(;; will look like:) S
LHL
(;;) S
LHL
(;;    1 one line) S
LHL
(;;      one line) S
LHL
(;;    3 one line) S
LHL
(;;      one line) S
LHL
(;;    5 one line) S
LHL
(;;      one line) S
LHL
(;;      ...) S
LHL
(;;) S
LHL
(;; Valid values are:) S
LHL
(;;) S
LHL
(;; integer) S
6 W
(an integer that specifies the interval that line number is) S
LHL
(;;) S
14 W
(printed.  If it's lesser than or equal to zero, it's used the) S
LHL
(;;) S
14 W
(value 1.) S
LHL
(;;) S
LHL
(;; `zebra') S
6 W
(specifies that only the line number of the first line in a) S
LHL
(;;) S
14 W
(zebra stripe is to be printed.) S
LHL
(;;) S
LHL
(;; Any other value is treated as `zebra'.) S
LHL
(;; The default value is 1, so each line number is printed.) S
LHL
(;;) S
LHL
(;; The variable `ps-line-number-start' specifies the starting point in the) S
LHL
(;; interval given by `ps-line-number-step'.  For example, if) S
LHL
(;; `ps-line-number-step' is set to 3 and `ps-line-number-start' is set to 3,) S
LHL
(;; the printing will look like:) S
LHL
(;;) S
LHL
(;;      one line) S
LHL
(;;      one line) S
LHL
(;;    3 one line) S
LHL
(;;      one line) S
LHL
(;;      one line) S
LHL
(;;    6 one line) S
LHL
(;;      one line) S
LHL
(;;      one line) S
LHL
(;;    9 one line) S
LHL
(;;      one line) S
LHL
(;;      ...) S
LHL
(;;) S
LHL
(;; The values for `ps-line-number-start':) S
LHL
(;;) S
LHL
(;;    * If `ps-line-number-step' is an integer, must be between 1 and the value) S
LHL
(;;) S
6 W
(of `ps-line-number-step' inclusive.) S
LHL
(;;) S
LHL
(;;    * If `ps-line-number-step' is set to `zebra', must be between 1 and the) S
LHL
(;;) S
6 W
(value of `ps-zebra-stripe-height' inclusive.) S
LHL
(;;) S
LHL
(;; The default value is 1, so the line number of the first line of each) S
LHL
(;; interval is printed.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Zebra Stripes) S
LHL
(;; -------------) S
LHL
(;;) S
LHL
(;; Zebra stripes are a kind of background that appear "underneath" the text and) S
LHL
(;; can make the text easier to read.  They look like this:) S
LHL
(;;) S
LHL
(;; XXXXXXXXXXXXXXXXXXXXXXXX) S
LHL
(;; XXXXXXXXXXXXXXXXXXXXXXXX) S
LHL
(;; XXXXXXXXXXXXXXXXXXXXXXXX) S
LHL
(;;) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; XXXXXXXXXXXXXXXXXXXXXXXX) S
LHL
(;; XXXXXXXXXXXXXXXXXXXXXXXX) S
LHL
(;; XXXXXXXXXXXXXXXXXXXXXXXX) S
LHL
(;;) S
LHL
(;; The blocks of X's represent rectangles filled with a light gray color.) S
EndPage
EndDSCPage
EndSheet

%%Page: 12 40
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 793 def
/PageNumber 12 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
792 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;; Each rectangle extends all the way across the page.) S
LHL
(;;) S
LHL
(;; The height, in lines, of each rectangle is controlled by the variable) S
LHL
(;; `ps-zebra-stripe-height', which is 3 by default.  The distance between) S
LHL
(;; stripes equals the height of a stripe.) S
LHL
(;;) S
LHL
(;; The variable `ps-zebra-stripes' controls whether to print zebra stripes.) S
LHL
(;; Non-nil means yes, nil means no.  The default is nil.) S
LHL
(;;) S
LHL
(;; The variable `ps-zebra-color' controls the zebra stripes gray scale or RGB) S
LHL
(;; color.  It should be a float number between 0.0 \(black color\) and 1.0 \(white) S
LHL
(;; color\), a string which is a color name, or a list of 3 numbers which) S
LHL
(;; corresponds to the Red Green Blue color scale.) S
LHL
(;; The default is 0.95 \(or "gray95", or '\(0.95 0.95 0.95\)\).) S
LHL
(;;) S
LHL
(;; The variable `ps-zebra-stripe-follow' specifies how zebra stripes continue) S
LHL
(;; on next page.  Visually, valid values are \(the character `+' at right of) S
LHL
(;; each column indicates that a line is printed\):) S
LHL
(;;) S
LHL
(;;) S
18 W
(nil         `follow'        `full'        `full-follow') S
LHL
(;; Current Page --------     -----------     ---------     ----------------) S
LHL
(;;) S
14 W
(1  XXXXX +   1  XXXXXXXX +   1  XXXXXX +   1  XXXXXXXXXXXXX +) S
LHL
(;;) S
14 W
(2  XXXXX +   2  XXXXXXXX +   2  XXXXXX +   2  XXXXXXXXXXXXX +) S
LHL
(;;) S
14 W
(3  XXXXX +   3  XXXXXXXX +   3  XXXXXX +   3  XXXXXXXXXXXXX +) S
LHL
(;;) S
14 W
(4        +   4           +   4         +   4                +) S
LHL
(;;) S
14 W
(5        +   5           +   5         +   5                +) S
LHL
(;;) S
14 W
(6        +   6           +   6         +   6                +) S
LHL
(;;) S
14 W
(7  XXXXX +   7  XXXXXXXX +   7  XXXXXX +   7  XXXXXXXXXXXXX +) S
LHL
(;;) S
14 W
(8  XXXXX +   8  XXXXXXXX +   8  XXXXXX +   8  XXXXXXXXXXXXX +) S
LHL
(;;) S
14 W
(9  XXXXX +   9  XXXXXXXX +   9  XXXXXX +   9  XXXXXXXXXXXXX +) S
LHL
(;;) S
14 W
(10       +   10          +) S
LHL
(;;) S
14 W
(11       +   11          +) S
LHL
(;;) S
14 W
(--------     -----------     ---------     ----------------) S
LHL
(;;    Next Page --------     -----------     ---------     ----------------) S
LHL
(;;) S
14 W
(12 XXXXX +   12          +   10 XXXXXX +   10               +) S
LHL
(;;) S
14 W
(13 XXXXX +   13 XXXXXXXX +   11 XXXXXX +   11               +) S
LHL
(;;) S
14 W
(14 XXXXX +   14 XXXXXXXX +   12 XXXXXX +   12               +) S
LHL
(;;) S
14 W
(15       +   15 XXXXXXXX +   13        +   13 XXXXXXXXXXXXX +) S
LHL
(;;) S
14 W
(16       +   16          +   14        +   14 XXXXXXXXXXXXX +) S
LHL
(;;) S
14 W
(17       +   17          +   15        +   15 XXXXXXXXXXXXX +) S
LHL
(;;) S
14 W
(18 XXXXX +   18          +   16 XXXXXX +   16               +) S
LHL
(;;) S
14 W
(19 XXXXX +   19 XXXXXXXX +   17 XXXXXX +   17               +) S
LHL
(;;) S
14 W
(20 XXXXX +   20 XXXXXXXX +   18 XXXXXX +   18               +) S
LHL
(;;) S
14 W
(21       +   21 XXXXXXXX +) S
LHL
(;;) S
14 W
(22       +   22          +) S
LHL
(;;) S
14 W
(--------     -----------     ---------     ----------------) S
LHL
(;;) S
LHL
(;; Any other value is treated as nil.) S
LHL
(;;) S
LHL
(;; See also section How Ps-Print Has A Text And/Or Image On Background.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Hooks) S
LHL
(;; -----) S
LHL
(;;) S
LHL
(;; ps-print has the following hook variables:) S
LHL
(;;) S
LHL
(;; `ps-print-hook') S
LHL
(;;    It is evaluated once before any printing process.  This is the right) S
LHL
(;;    place to initialize ps-print global data.) S
LHL
(;;    For an example, see section Adding a New Font Family.) S
LHL
(;;) S
LHL
(;; `ps-print-begin-sheet-hook') S
LHL
(;;    It is evaluated on each beginning of sheet of paper.) S
LHL
(;;    If `ps-n-up-printing' is equal to 1, `ps-print-begin-page-hook' is never) S
LHL
(;;    evaluated.) S
LHL
(;;) S
LHL
(;; `ps-print-begin-page-hook') S
LHL
(;;    It is evaluated on each beginning of page, except in the beginning of) S
LHL
(;;    page that `ps-print-begin-sheet-hook' is evaluated.) S
LHL
(;;) S
LHL
(;; `ps-print-begin-column-hook') S
EndPage
EndDSCPage
EndSheet

%%Page: 13 41
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 865 def
/PageNumber 13 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
864 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;    It is evaluated on each beginning of column, except in the beginning of) S
LHL
(;;    column that `ps-print-begin-page-hook' is evaluated or that) S
LHL
(;;    `ps-print-begin-sheet-hook' is evaluated.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Font Managing) S
LHL
(;; -------------) S
LHL
(;;) S
LHL
(;; ps-print now knows rather precisely some fonts: the variable) S
LHL
(;; `ps-font-info-database' contains information for a list of font families) S
LHL
(;; \(currently mainly `Courier' `Helvetica' `Times' `Palatino') S
LHL
(;; `Helvetica-Narrow' `NewCenturySchlbk'\).  Each font family contains the font) S
LHL
(;; names for standard, bold, italic and bold-italic characters, a reference) S
LHL
(;; size \(usually 10\) and the corresponding line height, width of a space and) S
LHL
(;; average character width.) S
LHL
(;;) S
LHL
(;; The variable `ps-font-family' determines which font family is to be used for) S
LHL
(;; ordinary text.  If its value does not correspond to a known font family, an) S
LHL
(;; error message is printed into the `*Messages*' buffer, which lists the) S
LHL
(;; currently available font families.) S
LHL
(;;) S
LHL
(;; The variable `ps-font-size' determines the size \(in points\) of the font for) S
LHL
(;; ordinary text, when generating PostScript.  Its value is a float or a cons) S
LHL
(;; of floats which has the following form:) S
LHL
(;;) S
LHL
(;;    \(LANDSCAPE-SIZE . PORTRAIT-SIZE\)) S
LHL
(;;) S
LHL
(;; Similarly, the variable `ps-header-font-family' determines which font family) S
LHL
(;; is to be used for text in the header.) S
LHL
(;;) S
LHL
(;; The variable `ps-header-font-size' determines the font size, in points, for) S
LHL
(;; text in the header \(similar to `ps-font-size'\).) S
LHL
(;;) S
LHL
(;; The variable `ps-header-title-font-size' determines the font size, in) S
LHL
(;; points, for the top line of text in the header \(similar to `ps-font-size'\).) S
LHL
(;;) S
LHL
(;; The variable `ps-line-spacing' determines the line spacing, in points, for) S
LHL
(;; ordinary text, when generating PostScript \(similar to `ps-font-size'\).  The) S
LHL
(;; default value is 0 \(zero = no line spacing\).) S
LHL
(;;) S
LHL
(;; The variable `ps-paragraph-spacing' determines the paragraph spacing, in) S
LHL
(;; points, for ordinary text, when generating PostScript \(similar to) S
LHL
(;; `ps-font-size'\).  The default value is 0 \(zero = no paragraph spacing\).) S
LHL
(;;) S
LHL
(;; To get all lines with some spacing set both `ps-line-spacing' and) S
LHL
(;; `ps-paragraph-spacing' variables.) S
LHL
(;;) S
LHL
(;; The variable `ps-paragraph-regexp' specifies the paragraph delimiter.  It) S
LHL
(;; should be a regexp or nil.  The default value is "[ \\t]*$", that is, an) S
LHL
(;; empty line or a line containing only spaces and tabs.) S
LHL
(;;) S
LHL
(;; The variable `ps-begin-cut-regexp' and `ps-end-cut-regexp' specify the start) S
LHL
(;; and end of a region to cut out when printing.) S
LHL
(;;) S
LHL
(;; As an example, variables `ps-begin-cut-regexp' and `ps-end-cut-regexp' may) S
LHL
(;; be set to "^Local Variables:" and "^End:", respectively, in order to leave) S
LHL
(;; out some special printing instructions from the actual print.  Special) S
LHL
(;; printing instructions may be appended to the end of the file just like any) S
LHL
(;; other buffer-local variables.  See section "Local Variables in Files" on) S
LHL
(;; Emacs manual for more information.) S
LHL
(;;) S
LHL
(;; Variables `ps-begin-cut-regexp' and `ps-end-cut-regexp' control together) S
LHL
(;; what actually gets printed.  Both variables may be set to nil in which case) S
LHL
(;; no cutting occurs.  By default, both variables are set to nil.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Adding a New Font Family) S
LHL
(;; ------------------------) S
LHL
(;;) S
LHL
(;; To use a new font family, you MUST first teach ps-print this font, i.e., add) S
LHL
(;; its information to `ps-font-info-database', otherwise ps-print cannot) S
LHL
(;; correctly place line and page breaks.) S
EndPage
EndDSCPage
EndSheet

%%Page: 14 42
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 937 def
/PageNumber 14 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
936 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;) S
LHL
(;; For example, assuming `Helvetica' is unknown, you first need to do the) S
LHL
(;; following ONLY ONCE:) S
LHL
(;;) S
LHL
(;; - create a new buffer) S
LHL
(;; - generate the PostScript image to a file \(C-u M-x ps-print-buffer\)) S
LHL
(;; - open this file and find the line:) S
LHL
(;;) S
6 W
(`% 3 cm 20 cm moveto  10/Courier ReportFontInfo  showpage') S
LHL
(;; - delete the leading `%' \(which is the PostScript comment character\)) S
LHL
(;; - replace in this line `Courier' by the new font \(say `Helvetica'\) to get) S
LHL
(;;   the line:) S
LHL
(;;) S
6 W
(`3 cm 20 cm moveto  10/Helvetica ReportFontInfo  showpage') S
LHL
(;; - send this file to the printer \(or to ghostscript\).) S
LHL
(;;   You should read the following on the output page:) S
LHL
(;;) S
LHL
(;;     For Helvetica 10 point, the line height is 11.56, the space width is 2.78) S
LHL
(;;     and a crude estimate of average character width is 5.09243) S
LHL
(;;) S
LHL
(;; - Add these values to the `ps-font-info-database':) S
LHL
(;;   \(setq ps-font-info-database) S
LHL
(;;) S
9 W
(\(append) S
LHL
(;;) S
10 W
('\(\(Helvetica) S
24 W
(; the family key) S
LHL
(;;) S
13 W
(\(fonts \(normal      . "Helvetica"\)) S
LHL
(;;) S
20 W
(\(bold        . "Helvetica-Bold"\)) S
LHL
(;;) S
20 W
(\(italic      . "Helvetica-Oblique"\)) S
LHL
(;;) S
20 W
(\(bold-italic . "Helvetica-BoldOblique"\)\)) S
LHL
(;;) S
13 W
(\(size . 10.0\)) S
LHL
(;;) S
13 W
(\(line-height . 11.56\)) S
LHL
(;;) S
13 W
(\(space-width . 2.78\)) S
LHL
(;;) S
13 W
(\(avg-char-width . 5.09243\)\)\)) S
LHL
(;;) S
10 W
(ps-font-info-database\)\)) S
LHL
(;; - Now you can use this font family with any size:) S
LHL
(;;) S
6 W
(\(setq ps-font-family 'Helvetica\)) S
LHL
(;; - if you want to use this family in another emacs session, you must put into) S
LHL
(;;   your `~/.emacs':) S
LHL
(;;) S
6 W
(\(require 'ps-print\)) S
LHL
(;;) S
6 W
(\(setq ps-font-info-database \(append ...\)\)\)) S
LHL
(;;   if you don't want to load ps-print, you have to copy the whole value:) S
LHL
(;;) S
6 W
(\(setq ps-font-info-database '\(<your stuff> <the standard stuff>\)\)) S
LHL
(;;   or, use `ps-print-hook' \(see section Hooks\):) S
LHL
(;;) S
6 W
(\(add-hook 'ps-print-hook) S
LHL
(;;) S
16 W
(\(lambda \(\)) S
LHL
(;;) S
19 W
(\(or \(assq 'Helvetica ps-font-info-database\)) S
LHL
(;;) S
23 W
(\(setq ps-font-info-database \(append ...\)\)\)\)\)) S
LHL
(;;) S
LHL
(;; You can create new `mixed' font families like:) S
LHL
(;;      \(my-mixed-family) S
LHL
(;;       \(fonts \(normal               . "Courier-Bold"\)) S
LHL
(;;              \(bold                 . "Helvetica"\)) S
LHL
(;;              \(italic               . "ZapfChancery-MediumItalic"\)) S
LHL
(;;              \(bold-italic          . "NewCenturySchlbk-BoldItalic"\)) S
LHL
(;;              \(w3-table-hack-x-face . "LineDrawNormal"\)\)) S
LHL
(;;       \(size . 10.0\)) S
LHL
(;;       \(line-height . 10.55\)) S
LHL
(;;       \(space-width . 6.0\)) S
LHL
(;;       \(avg-char-width . 6.0\)\)) S
LHL
(;;) S
LHL
(;; Now you can use your new font family with any size:) S
LHL
(;;) S
6 W
(\(setq ps-font-family 'my-mixed-family\)) S
LHL
(;;) S
LHL
(;; Note that on above example the `w3-table-hack-x-face' entry refers to a face) S
LHL
(;; symbol, so when printing this face it'll be used the font `LineDrawNormal'.) S
LHL
(;; If the face `w3-table-hack-x-face' is remapped to use bold and/or italic) S
LHL
(;; attribute, the corresponding entry \(bold, italic or bold-italic\) will be) S
LHL
(;; used instead of `w3-table-hack-x-face' entry.) S
LHL
(;;) S
LHL
(;; Note also that the font family entry order is irrelevant, so the above) S
LHL
(;; example could also be written:) S
LHL
(;;      \(my-mixed-family) S
LHL
(;;       \(size . 10.0\)) S
LHL
(;;       \(fonts \(w3-table-hack-x-face . "LineDrawNormal"\)) S
LHL
(;;              \(bold                 . "Helvetica"\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 15 43
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1009 def
/PageNumber 15 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1008 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;              \(bold-italic          . "NewCenturySchlbk-BoldItalic"\)) S
LHL
(;;              \(italic               . "ZapfChancery-MediumItalic"\)) S
LHL
(;;              \(normal               . "Courier-Bold"\)\)) S
LHL
(;;       \(avg-char-width . 6.0\)) S
LHL
(;;       \(space-width . 6.0\)) S
LHL
(;;       \(line-height . 10.55\)\)) S
LHL
(;;) S
LHL
(;; Despite the note above, it is recommended that some convention about) S
LHL
(;; entry order be used.) S
LHL
(;;) S
LHL
(;; You can get information on all the fonts resident in YOUR printer) S
LHL
(;; by uncommenting the line:) S
LHL
(;;) S
6 W
(% 3 cm 20 cm moveto  ReportAllFontInfo           showpage) S
LHL
(;;) S
LHL
(;; The PostScript file should be sent to YOUR PostScript printer.) S
LHL
(;; If you send it to ghostscript or to another PostScript printer, you may get) S
LHL
(;; slightly different results.) S
LHL
(;; Anyway, as ghostscript fonts are autoload, you won't get much font info.) S
LHL
(;;) S
LHL
(;; Note also that ps-print DOESN'T download any font to your printer, instead) S
LHL
(;; it uses the fonts resident in your printer.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; How Ps-Print Deals With Faces) S
LHL
(;; -----------------------------) S
LHL
(;;) S
LHL
(;; The ps-print-*-with-faces commands attempt to determine which faces should) S
LHL
(;; be printed in bold or italic, but their guesses aren't always right.  For) S
LHL
(;; example, you might want to map colors into faces so that blue faces print in) S
LHL
(;; bold, and red faces in italic.) S
LHL
(;;) S
LHL
(;; It is possible to force ps-print to consider specific faces bold, italic or) S
LHL
(;; underline, no matter what font they are displayed in, by setting the) S
LHL
(;; variables `ps-bold-faces', `ps-italic-faces' and `ps-underlined-faces'.) S
LHL
(;; These variables contain lists of faces that ps-print should consider bold,) S
LHL
(;; italic or underline; to set them, put code like the following into your) S
LHL
(;; init file:) S
LHL
(;;) S
LHL
(;;      \(setq ps-bold-faces '\(my-blue-face\)\)) S
LHL
(;;      \(setq ps-italic-faces '\(my-red-face\)\)) S
LHL
(;;      \(setq ps-underlined-faces '\(my-green-face\)\)) S
LHL
(;;) S
LHL
(;; Faces like bold-italic that are both bold and italic should go in *both*) S
LHL
(;; lists.) S
LHL
(;;) S
LHL
(;; ps-print keeps internal lists of which fonts are bold and which are italic;) S
LHL
(;; these lists are built the first time you invoke ps-print.) S
LHL
(;; For the sake of efficiency, the lists are built only once; the same lists) S
LHL
(;; are referred in later invocations of ps-print.) S
LHL
(;;) S
LHL
(;; Because these lists are built only once, it's possible for them to get out) S
LHL
(;; of sync, if a face changes, or if new faces are added.  To get the lists) S
LHL
(;; back in sync, you can set the variable `ps-build-face-reference' to t, and) S
LHL
(;; the lists will be rebuilt the next time ps-print is invoked.  If you need) S
LHL
(;; that the lists always be rebuilt when ps-print is invoked, set the variable) S
LHL
(;; `ps-always-build-face-reference' to t.) S
LHL
(;;) S
LHL
(;; If you need to print without worrying about face background color, set the) S
LHL
(;; variable `ps-use-face-background' which specifies if face background should) S
LHL
(;; be used.  Valid values are:) S
LHL
(;;) S
LHL
(;;    t) S
9 W
(always use face background color.) S
LHL
(;;    nil) S
7 W
(never use face background color.) S
LHL
(;;    \(face...\)) S
1 W
(list of faces whose background color will be used.) S
LHL
(;;) S
LHL
(;; Any other value will be treated as t.) S
LHL
(;; The default value is nil.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; How Ps-Print Deals With Color) S
LHL
(;; -----------------------------) S
LHL
(;;) S
EndPage
EndDSCPage
EndSheet

%%Page: 16 44
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1081 def
/PageNumber 16 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1080 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;; ps-print detects faces with foreground and background colors defined and) S
LHL
(;; embeds color information in the PostScript image.) S
LHL
(;; The default foreground and background colors are defined by the variables) S
LHL
(;; `ps-default-fg' and `ps-default-bg'.) S
LHL
(;; On black/white printers, colors are displayed in gray scale.) S
LHL
(;; To turn off color output, set `ps-print-color-p' to nil.) S
LHL
(;; You can also set `ps-print-color-p' to 'black-white to have a better looking) S
LHL
(;; on black/white printers.  See also `ps-black-white-faces' for documentation.) S
LHL
(;;) S
LHL
(;; ps-print also detects if the text foreground and background colors are) S
LHL
(;; equals when `ps-fg-validate-p' is non-nil.  In this case, if these colors) S
LHL
(;; are used, no text will appear.  You can use `ps-fg-list' to give a list of) S
LHL
(;; foreground colors to be used when text foreground and background colors are) S
LHL
(;; equals.  It'll be used the first foreground color in `ps-fg-list' which is) S
LHL
(;; different from the background color.  If `ps-fg-list' is nil, the default) S
LHL
(;; foreground color is used.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; How Ps-Print Maps Faces) S
LHL
(;; -----------------------) S
LHL
(;;) S
LHL
(;; As ps-print uses PostScript to print buffers, it is possible to have other) S
LHL
(;; attributes associated with faces. So the new attributes used by ps-print) S
LHL
(;; are:) S
LHL
(;;) S
LHL
(;;   strikeout - like underline, but the line is in middle of text.) S
LHL
(;;   overline  - like underline, but the line is over the text.) S
LHL
(;;   shadow    - text will have a shadow.) S
LHL
(;;   box       - text will be surrounded by a box.) S
LHL
(;;   outline   - print characters as hollow outlines.) S
LHL
(;;) S
LHL
(;; See the documentation for `ps-extend-face'.) S
LHL
(;;) S
LHL
(;; Let's, for example, remap `font-lock-keyword-face' to another foreground) S
LHL
(;; color and bold attribute:) S
LHL
(;;) S
LHL
(;;    \(ps-extend-face '\(font-lock-keyword-face "RoyalBlue" nil bold\) 'MERGE\)) S
LHL
(;;) S
LHL
(;; If you want to use a new face, define it first with `defface', and then call) S
LHL
(;; `ps-extend-face' to specify how to print it.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; How Ps-Print Has A Text And/Or Image On Background) S
LHL
(;; --------------------------------------------------) S
LHL
(;;) S
LHL
(;; ps-print can print texts and/or EPS PostScript images on background; it is) S
LHL
(;; possible to define the following text attributes: font name, font size,) S
LHL
(;; initial position, angle, gray scale and pages to print.) S
LHL
(;;) S
LHL
(;; It has the following EPS PostScript images attributes: file name containing) S
LHL
(;; the image, initial position, X and Y scales, angle and pages to print.) S
LHL
(;;) S
LHL
(;; See documentation for `ps-print-background-text' and) S
LHL
(;; `ps-print-background-image'.) S
LHL
(;;) S
LHL
(;; For example, if we wish to print text "preliminary" on all pages and text) S
LHL
(;; "special" on page 5 and from page 11 to page 17, we could specify:) S
LHL
(;;) S
LHL
(;; \(setq ps-print-background-text) S
LHL
(;;       '\(\("preliminary"\)) S
LHL
(;;         \("special") S
LHL
(;;          "LeftMargin" "BottomMargin PrintHeight add" ; X and Y position) S
LHL
(;;                                      ; \(upper left corner\)) S
LHL
(;;          nil nil nil) S
LHL
(;;          "PrintHeight neg PrintPageWidth atan" ; angle) S
LHL
(;;          5 \(11 . 17\)\)                ; page list) S
LHL
(;;         \)\)) S
LHL
(;;) S
LHL
(;; Similarly, we could print image "~/images/EPS-image1.ps" on all pages and) S
LHL
(;; image "~/images/EPS-image2.ps" on page 5 and from page 11 to page 17, we) S
LHL
(;; specify:) S
LHL
(;;) S
EndPage
EndDSCPage
EndSheet

%%Page: 17 45
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1153 def
/PageNumber 17 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1152 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;; \(setq ps-print-background-image) S
LHL
(;;       '\(\("~/images/EPS-image1.ps") S
LHL
(;;          "LeftMargin" "BottomMargin"\) ; X and Y position \(lower left corner\)) S
LHL
(;;         \("~/images/EPS-image2.ps") S
LHL
(;;          "LeftMargin" "BottomMargin PrintHeight 2 div add" ; X and Y pos.) S
LHL
(;;                                      ; \(upper left corner\)) S
LHL
(;;          nil nil nil) S
LHL
(;;          5 \(11 . 17\)\)                ; page list) S
LHL
(;;         \)\)) S
LHL
(;;) S
LHL
(;; If it is not possible to read \(or does not exist\) an image file, that file) S
LHL
(;; is ignored.) S
LHL
(;;) S
LHL
(;; The printing order is:) S
LHL
(;;) S
LHL
(;;    1. Print background color) S
LHL
(;;    2. Print zebra stripes) S
LHL
(;;    3. Print background texts that it should be on all pages) S
LHL
(;;    4. Print background images that it should be on all pages) S
LHL
(;;    5. Print background texts only for current page \(if any\)) S
LHL
(;;    6. Print background images only for current page \(if any\)) S
LHL
(;;    7. Print header) S
LHL
(;;    8. Print buffer text \(with faces, if specified\) and line number) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Utilities) S
LHL
(;; ---------) S
LHL
(;;) S
LHL
(;; Some tools are provided to help you customize your font setup.) S
LHL
(;;) S
LHL
(;; `ps-setup' returns \(some part of\) the current setup.) S
LHL
(;;) S
LHL
(;; To avoid wrapping too many lines, you may want to adjust the left and right) S
LHL
(;; margins and the font size.  On UN*X systems, do:) S
LHL
(;; pr -t file | awk '{printf "%3d %s\\n", length\($0\), $0}' | sort -r | head) S
LHL
(;; to determine the longest lines of your file.) S
LHL
(;; Then, the command `ps-line-lengths' will give you the correspondence between) S
LHL
(;; a line length \(number of characters\) and the maximum font size which doesn't) S
LHL
(;; wrap such a line with the current ps-print setup.) S
LHL
(;;) S
LHL
(;; The commands `ps-nb-pages-buffer' and `ps-nb-pages-region' display the) S
LHL
(;; correspondence between a number of pages and the maximum font size which) S
LHL
(;; allow the number of lines of the current buffer or of its current region to) S
LHL
(;; fit in this number of pages.) S
LHL
(;;) S
LHL
(;; NOTE: line folding is not taken into account in this process and could) S
LHL
(;;       change the results.) S
LHL
(;;) S
LHL
(;; The command `ps-print-customize' activates a customization buffer for) S
LHL
(;; ps-print options.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; New since version 1.5) S
LHL
(;; ---------------------) S
LHL
(;;) S
LHL
(;; Color output capability.) S
LHL
(;; Automatic detection of font attributes \(bold, italic\).) S
LHL
(;; Configurable headers with page numbers.) S
LHL
(;; Slightly faster.) S
LHL
(;; Support for different paper sizes.) S
LHL
(;; Better conformance to PostScript Document Structure Conventions.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; New since version 2.8) S
LHL
(;; ---------------------) S
LHL
(;;) S
LHL
(;; [vinicius] Vinicius Jose Latorre <viniciusjl@ig.com.br>) S
LHL
(;;) S
LHL
(;;    2007-10-27) S
LHL
(;;) S
7 W
(`ps-fg-validate-p', `ps-fg-list') S
LHL
(;;) S
LHL
(;;    2004-02-29) S
EndPage
EndDSCPage
EndSheet

%%Page: 18 46
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1225 def
/PageNumber 18 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1224 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;) S
7 W
(`ps-time-stamp-yyyy-mm-dd', `ps-time-stamp-iso8601') S
LHL
(;;) S
LHL
(;;    2001-06-19) S
LHL
(;;) S
7 W
(`ps-time-stamp-locale-default') S
LHL
(;;) S
LHL
(;;    2001-05-30) S
LHL
(;;) S
7 W
(Handle before-string and after-string overlay properties.) S
LHL
(;;) S
LHL
(;;    2001-04-07) S
LHL
(;;) S
7 W
(`ps-line-number-color', `ps-print-footer', `ps-footer-offset',) S
LHL
(;;) S
7 W
(`ps-print-footer-frame', `ps-footer-font-family',) S
LHL
(;;) S
7 W
(`ps-footer-font-size', `ps-footer-line-pad', `ps-footer-lines',) S
LHL
(;;) S
7 W
(`ps-left-footer', `ps-right-footer', `ps-footer-frame-alist' and) S
LHL
(;;) S
7 W
(`ps-header-frame-alist'.) S
LHL
(;;) S
LHL
(;;    2001-03-28) S
LHL
(;;) S
7 W
(`ps-line-spacing', `ps-paragraph-spacing', `ps-paragraph-regexp',) S
LHL
(;;) S
7 W
(`ps-begin-cut-regexp' and `ps-end-cut-regexp'.) S
LHL
(;;) S
LHL
(;;    2000-11-22) S
LHL
(;;) S
7 W
(`ps-line-number-font', `ps-line-number-font-size' and) S
LHL
(;;) S
7 W
(`ps-end-with-control-d'.) S
LHL
(;;) S
LHL
(;;    2000-08-21) S
LHL
(;;) S
7 W
(`ps-even-or-odd-pages') S
LHL
(;;) S
LHL
(;;    2000-06-17) S
LHL
(;;) S
7 W
(`ps-manual-feed', `ps-warn-paper-type', `ps-print-upside-down',) S
LHL
(;;) S
7 W
(`ps-selected-pages', `ps-last-selected-pages',) S
LHL
(;;) S
7 W
(`ps-restore-selected-pages', `ps-switch-header',) S
LHL
(;;) S
7 W
(`ps-line-number-step', `ps-line-number-start',) S
LHL
(;;) S
7 W
(`ps-zebra-stripe-follow' and `ps-use-face-background'.) S
LHL
(;;) S
LHL
(;;    2000-03-10) S
LHL
(;;) S
7 W
(PostScript error handler.) S
LHL
(;;) S
7 W
(`ps-user-defined-prologue' and `ps-error-handler-message'.) S
LHL
(;;) S
LHL
(;;    1999-12-11) S
LHL
(;;) S
7 W
(`ps-print-customize'.) S
LHL
(;;) S
LHL
(;;    1999-07-03) S
LHL
(;;) S
7 W
(Better customization.) S
LHL
(;;) S
7 W
(`ps-banner-page-when-duplexing' and `ps-zebra-color'.) S
LHL
(;;) S
LHL
(;;    1999-05-13) S
LHL
(;;) S
7 W
(N-up printing.) S
LHL
(;;) S
7 W
(Hook: `ps-print-begin-sheet-hook'.) S
LHL
(;;) S
LHL
(;; [kenichi] 1999-05-09 Ken'ichi Handa <handa@m17n.org>) S
LHL
(;;) S
LHL
(;;    `ps-print-region-function') S
LHL
(;;) S
LHL
(;; [vinicius] Vinicius Jose Latorre <viniciusjl@ig.com.br>) S
LHL
(;;) S
LHL
(;;    1999-03-01) S
LHL
(;;) S
7 W
(PostScript tumble and setpagedevice.) S
LHL
(;;) S
LHL
(;;    1998-09-22) S
LHL
(;;) S
7 W
(PostScript prologue header comment insertion.) S
LHL
(;;) S
7 W
(Skip invisible text better.) S
LHL
(;;) S
LHL
(;; [kenichi] 1998-08-19 Ken'ichi Handa <handa@m17n.org>) S
LHL
(;;) S
LHL
(;;    Multi-byte buffer handling.) S
LHL
(;;) S
LHL
(;; [vinicius] Vinicius Jose Latorre <viniciusjl@ig.com.br>) S
LHL
(;;) S
LHL
(;;    1998-03-06) S
LHL
(;;) S
7 W
(Skip invisible text.) S
LHL
(;;) S
LHL
(;;    1997-11-30) S
LHL
(;;) S
7 W
(Hooks: `ps-print-hook', `ps-print-begin-page-hook' and) S
EndPage
EndDSCPage
EndSheet

%%Page: 19 47
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1297 def
/PageNumber 19 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1296 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;) S
7 W
(`ps-print-begin-column-hook'.) S
LHL
(;;) S
7 W
(Put one header per page over the columns.) S
LHL
(;;) S
7 W
(Better database font management.) S
LHL
(;;) S
7 W
(Better control characters handling.) S
LHL
(;;) S
LHL
(;;    1997-11-21) S
LHL
(;;) S
7 W
(Dynamic evaluation at print time of `ps-lpr-switches'.) S
LHL
(;;) S
7 W
(Handle control characters.) S
LHL
(;;) S
7 W
(Face remapping.) S
LHL
(;;) S
7 W
(New face attributes.) S
LHL
(;;) S
7 W
(Line number.) S
LHL
(;;) S
7 W
(Zebra stripes.) S
LHL
(;;) S
7 W
(Text and/or image on background.) S
LHL
(;;) S
LHL
(;; [jack] 1996-05-17 Jacques Duthen <duthen@cegelec-red.fr>) S
LHL
(;;) S
LHL
(;;    Font family and float size for text and header.) S
LHL
(;;    Landscape mode.) S
LHL
(;;    Multiple columns.) S
LHL
(;;    Tools for page setup.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Known bugs and limitations of ps-print) S
LHL
(;; --------------------------------------) S
LHL
(;;) S
LHL
(;; Although color printing will work in XEmacs 19.12, it doesn't work well; in) S
LHL
(;; particular, bold or italic fonts don't print in the right background color.) S
LHL
(;;) S
LHL
(;; Invisible properties aren't correctly ignored in XEmacs 19.12.) S
LHL
(;;) S
LHL
(;; Automatic font-attribute detection doesn't work well, especially with) S
LHL
(;; hilit19 and older versions of get-create-face.  Users having problems with) S
LHL
(;; auto-font detection should use the lists `ps-italic-faces', `ps-bold-faces') S
LHL
(;; and `ps-underlined-faces' and/or turn off automatic detection by setting) S
LHL
(;; `ps-auto-font-detect' to nil.) S
LHL
(;;) S
LHL
(;; Automatic font-attribute detection doesn't work with XEmacs 19.12 in tty) S
LHL
(;; mode; use the lists `ps-italic-faces', `ps-bold-faces' and) S
LHL
(;; `ps-underlined-faces' instead.) S
LHL
(;;) S
LHL
(;; Still too slow; could use some hand-optimization.) S
LHL
(;;) S
LHL
(;; Default background color isn't working.) S
LHL
(;;) S
LHL
(;; Faces are always treated as opaque.) S
LHL
(;;) S
LHL
(;; Epoch, Lucid and Emacs 22 not supported.  At all.) S
LHL
(;;) S
LHL
(;; Fixed-pitch fonts work better for line folding, but are not required.) S
LHL
(;;) S
LHL
(;; `ps-nb-pages-buffer' and `ps-nb-pages-region' don't take care of folding) S
LHL
(;; lines.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Things to change) S
LHL
(;; ----------------) S
LHL
(;;) S
LHL
(;; Avoid page break inside a paragraph.) S
LHL
(;;) S
LHL
(;; Add `ps-non-bold-faces' and `ps-non-italic-faces' \(should be easy\).) S
LHL
(;;) S
LHL
(;; Improve the memory management for big files \(hard?\).) S
LHL
(;;) S
LHL
(;; `ps-nb-pages-buffer' and `ps-nb-pages-region' should take care of folding) S
LHL
(;; lines.) S
LHL
(;;) S
LHL
(;;) S
LHL
(;; Acknowledgments) S
LHL
(;; ---------------) S
LHL
(;;) S
LHL
(;; Thanks to Eduard Wiebe <usenet@pusto.de> for fixing face) S
LHL
(;; background/foreground extraction.) S
EndPage
EndDSCPage
EndSheet

%%Page: 20 48
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1369 def
/PageNumber 20 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1368 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;) S
LHL
(;; Thanks to Friedrich Delgado Friedrichs <friedel@nomaden.org> for new label) S
LHL
(;; printer page sizes.) S
LHL
(;;) S
LHL
(;; Thanks to Michael Piotrowski <mxp@dynalabs.de> for improving the DSC) S
LHL
(;; compliance of the generated PostScript.) S
LHL
(;;) S
LHL
(;; Thanks to Adam Doppelt <adoppelt@avogadro.com> for face mapping suggestion) S
LHL
(;; for black/white PostScript printers.) S
LHL
(;;) S
LHL
(;; Thanks to Toni Ronkko <tronkko@hytti.uku.fi> for line and paragraph spacing,) S
LHL
(;; region to cut out when printing and footer suggestions.) S
LHL
(;;) S
LHL
(;; Thanks to Pavel Janik ml <Pavel@Janik.cz> for documentation correction.) S
LHL
(;;) S
LHL
(;; Thanks to Corinne Ilvedson <cilvedson@draper.com> for line number font size) S
LHL
(;; suggestion.) S
LHL
(;;) S
LHL
(;; Thanks to Gord Wait <Gord_Wait@spectrumsignal.com> for) S
LHL
(;; `ps-user-defined-prologue' example setting for HP PostScript printer.) S
LHL
(;;) S
LHL
(;; Thanks to Paul Furnanz <pfurnanz@synopsys.com> for XEmacs compatibility) S
LHL
(;; suggestion for `ps-postscript-code-directory' variable.) S
LHL
(;;) S
LHL
(;; Thanks to David X Callaway <dxc@xprt.net> for helping debugging PostScript) S
LHL
(;; level 1 compatibility.) S
LHL
(;;) S
LHL
(;; Thanks to Colin Marquardt <colin.marquardt@usa.alcatel.com> for:) S
LHL
(;;    - upside-down, line number step, line number start and zebra stripe) S
LHL
(;;) S
6 W
(follow suggestions.) S
LHL
(;;    - `ps-time-stamp-yyyy-mm-dd' and `ps-time-stamp-iso8601' suggestion.) S
LHL
(;;    - and for XEmacs beta-tests.) S
LHL
(;;) S
LHL
(;; Thanks to Klaus Berndl <klaus.berndl@sdm.de> for user defined PostScript) S
LHL
(;; prologue code suggestion, for odd/even printing suggestion and for) S
LHL
(;; `ps-prologue-file' enhancement.) S
LHL
(;;) S
LHL
(;; Thanks to Ken'ichi Handa <handa@m17n.org> for multi-byte buffer handling.) S
LHL
(;;) S
LHL
(;; Thanks to Matthew O Persico <Matthew.Persico@lazard.com> for line number on) S
LHL
(;; empty columns.) S
LHL
(;;) S
LHL
(;; Thanks to Theodore Jump <tjump@cais.com> for adjust PostScript code order on) S
LHL
(;; last page.) S
LHL
(;;) S
LHL
(;; Thanks to Roland Ducournau <ducour@lirmm.fr> for) S
LHL
(;; `ps-print-control-characters' variable documentation.) S
LHL
(;;) S
LHL
(;; Thanks to Marcus G Daniels <marcus@cathcart.sysc.pdx.edu> for a better) S
LHL
(;; database font management.) S
LHL
(;;) S
LHL
(;; Thanks to Martin Boyer <gamin@videotron.ca> for some ideas on putting one) S
LHL
(;; header per page over the columns and correct line numbers when printing a) S
LHL
(;; region.) S
LHL
(;;) S
LHL
(;; Thanks to Steven L Baur <steve@miranova.com> for dynamic evaluation at) S
LHL
(;; print time of `ps-lpr-switches'.) S
LHL
(;;) S
LHL
(;; Thanks to Kevin Rodgers <kevinr@ihs.com> for handling control characters) S
LHL
(;; \(his code was severely modified, but the main idea was kept\).) S
LHL
(;;) S
LHL
(;; Thanks to some suggestions on:) S
LHL
(;;  * Face color map: Marco Melgazzi <marco@techie.com>) S
LHL
(;;  * XEmacs compatibility: William J. Henney <will@astrosmo.unam.mx>) S
LHL
(;;  * Check `ps-paper-type': Sudhakar Frederick <sfrederi@asc.corp.mot.com>) S
LHL
(;;) S
LHL
(;; Thanks to Jacques Duthen <duthen@cegelec-red.fr> \(Jack\) for version 3.4 I) S
LHL
(;; started from. [vinicius]) S
LHL
(;;) S
LHL
(;; Thanks to Jim Thompson <?@?> for the 2.8 version I started from.  [jack]) S
LHL
(;;) S
LHL
(;; Thanks to Kevin Rodgers <kevinr@ihs.com> for adding support for color and) S
EndPage
EndDSCPage
EndSheet

%%Page: 21 49
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1441 def
/PageNumber 21 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1440 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;; the invisible property.) S
LHL
(;;) S
LHL
(;; Thanks to Avishai Yacobi, avishaiy@mcil.comm.mot.com, for writing the) S
LHL
(;; initial port to Emacs 19.  His code is no longer part of ps-print, but his) S
LHL
(;; work is still appreciated.) S
LHL
(;;) S
LHL
(;; Thanks to Remi Houdaille and Michel Train <michel@metasoft.fdn.org> for) S
LHL
(;; adding underline support.  Their code also is no longer part of ps-print,) S
LHL
(;; but their efforts are not forgotten.) S
LHL
(;;) S
LHL
(;; Thanks also to all of you who mailed code to add features to ps-print;) S
LHL
(;; although I didn't use your code, I still appreciate your sharing it with me.) S
LHL
(;;) S
LHL
(;; Thanks to all who mailed comments, encouragement, and criticism.) S
LHL
(;; Thanks also to all who responded to my survey; I had too many responses to) S
LHL
(;; reply to them all, but I greatly appreciate your interest.) S
LHL
(;;) S
LHL
(;; Jim) S
LHL
(;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;) S
PHL
LHL
(;;; Code:) S
PHL
PHL
LHL
(\(require 'lpr\)) S
PHL
PHL
LHL
(\(if \(featurep 'xemacs\)) S
LHL
(    \(or \(featurep 'lisp-float-type\)) S
LHL
8 W
(\(error "`ps-print' requires floating point support"\)\)) S
LHL
(  \(unless \(and \(boundp 'emacs-major-version\)) S
LHL
15 W
(\(>= emacs-major-version 23\)\)) S
LHL
(    \(error "`ps-print' only supports Emacs 23 and higher"\)\)\)) S
PHL
PHL
LHL
(;; Load XEmacs/Emacs definitions) S
LHL
(\(require 'ps-def\)) S
PHL
LHL
(;; autoloads for secondary file) S
LHL
(\(require 'ps-print-loaddefs\)) S
PHL
LHL
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;) S
LHL
(;; User Variables:) S
PHL
PHL
LHL
(;;; Interface to the command system) S
PHL
LHL
(\(defgroup postscript nil) S
LHL
(  "Support for printing and PostScript.") S
LHL
(  :tag "PostScript") S
LHL
(  :version "20") S
LHL
(  :group 'external\)) S
PHL
LHL
(\(defgroup ps-print nil) S
LHL
(  "PostScript generator for Emacs.") S
LHL
(  :link '\(emacs-library-link :tag "Source Lisp File" "ps-print.el"\)) S
LHL
(  :prefix "ps-") S
LHL
(  :version "20") S
LHL
(  :group 'text) S
LHL
(  :group 'postscript\)) S
PHL
LHL
(\(defgroup ps-print-horizontal nil) S
LHL
(  "Horizontal page layout.") S
LHL
(  :prefix "ps-") S
LHL
(  :tag "Horizontal") S
LHL
(  :version "20") S
LHL
(  :group 'ps-print\)) S
PHL
LHL
(\(defgroup ps-print-vertical nil) S
LHL
(  "Vertical page layout.") S
LHL
(  :prefix "ps-") S
LHL
(  :tag "Vertical") S
LHL
(  :version "20") S
EndPage
EndDSCPage
EndSheet

%%Page: 22 50
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1513 def
/PageNumber 22 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1512 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  :group 'ps-print\)) S
PHL
LHL
(\(defgroup ps-print-headers nil) S
LHL
(  "Headers & footers layout.") S
LHL
(  :prefix "ps-") S
LHL
(  :tag "Header & Footer") S
LHL
(  :version "20") S
LHL
(  :group 'ps-print\)) S
PHL
LHL
(\(defgroup ps-print-font nil) S
LHL
(  "Fonts customization.") S
LHL
(  :prefix "ps-") S
LHL
(  :tag "Font") S
LHL
(  :version "20") S
LHL
(  :group 'ps-print\)) S
PHL
LHL
(\(defgroup ps-print-color nil) S
LHL
(  "Color customization.") S
LHL
(  :prefix "ps-") S
LHL
(  :tag "Color") S
LHL
(  :version "20") S
LHL
(  :group 'ps-print\)) S
PHL
LHL
(\(defgroup ps-print-face nil) S
LHL
(  "Faces customization.") S
LHL
(  :prefix "ps-") S
LHL
(  :tag "PS Faces") S
LHL
(  :version "20") S
LHL
(  :group 'ps-print) S
LHL
(  :group 'faces\)) S
PHL
LHL
(\(defgroup ps-print-n-up nil) S
LHL
(  "N-up customization.") S
LHL
(  :prefix "ps-") S
LHL
(  :tag "N-Up") S
LHL
(  :version "20") S
LHL
(  :group 'ps-print\)) S
PHL
LHL
(\(defgroup ps-print-zebra nil) S
LHL
(  "Zebra customization.") S
LHL
(  :prefix "ps-") S
LHL
(  :tag "Zebra") S
LHL
(  :version "20") S
LHL
(  :group 'ps-print\)) S
PHL
LHL
(\(defgroup ps-print-background nil) S
LHL
(  "Background customization.") S
LHL
(  :prefix "ps-") S
LHL
(  :tag "Background") S
LHL
(  :version "20") S
LHL
(  :group 'ps-print\)) S
PHL
LHL
(\(defgroup ps-print-printer '\(\(lpr custom-group\)\)) S
LHL
(  "Printer customization.") S
LHL
(  :prefix "ps-") S
LHL
(  :tag "Printer") S
LHL
(  :version "20") S
LHL
(  :group 'ps-print\)) S
PHL
LHL
(\(defgroup ps-print-page nil) S
LHL
(  "Page customization.") S
LHL
(  :prefix "ps-") S
LHL
(  :tag "Page") S
LHL
(  :version "20") S
LHL
(  :group 'ps-print\)) S
PHL
LHL
(\(defgroup ps-print-miscellany nil) S
LHL
(  "Miscellany customization.") S
LHL
(  :prefix "ps-") S
LHL
(  :tag "Miscellany") S
LHL
(  :version "20") S
LHL
(  :group 'ps-print\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 23 51
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1585 def
/PageNumber 23 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1584 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
PHL
LHL
(\(defcustom ps-error-handler-message 'paper) S
LHL
(  "Specify where the error handler message should be sent.) S
PHL
LHL
(Valid values are:) S
PHL
LHL
(   `none') S
15 W
(catch the error and *DON'T* send any message.) S
PHL
LHL
(   `paper') S
14 W
(catch the error and print on paper the error message.) S
PHL
LHL
(   `system') S
13 W
(catch the error and send back the error message to) S
LHL
24 W
(printing system.  This is useful only if printing system) S
LHL
24 W
(send back an email reporting the error, or if there is) S
LHL
24 W
(some other alternative way to report back the error from) S
LHL
24 W
(the system to you.) S
PHL
LHL
(   `paper-and-system') S
3 W
(catch the error, print on paper the error message and) S
LHL
24 W
(send back the error message to printing system.) S
PHL
LHL
(Any other value is treated as `paper'.") S
LHL
(  :type '\(choice :menu-tag "Error Handler Message") S
LHL
17 W
(:tag "Error Handler Message") S
LHL
17 W
(\(const none\)   \(const paper\)) S
LHL
17 W
(\(const system\) \(const paper-and-system\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-user-defined-prologue nil) S
LHL
(  "User defined PostScript prologue code inserted before all prologue code.) S
PHL
LHL
(`ps-user-defined-prologue' may be a string or a symbol function which returns a) S
LHL
(string.  Note that this string is inserted after `ps-adobe-tag' and PostScript) S
LHL
(prologue comments, and before ps-print PostScript prologue code section.  That) S
LHL
(is, this string is inserted after error handler initialization and before) S
LHL
(ps-print settings.) S
PHL
LHL
(It's strongly recommended only insert PostScript code and/or comments specific) S
LHL
(for your printing system particularities.  For example, some special) S
LHL
(initialization that only your printing system needs.) S
PHL
LHL
(Do not insert code for duplex printing, n-up printing or error handler,) S
LHL
(ps-print handles this in a suitable way.) S
PHL
LHL
(For more information about PostScript, see:) S
LHL
(   PostScript Language Reference Manual \(2nd edition\)) S
LHL
(   Adobe Systems Incorporated) S
PHL
LHL
(As an example for `ps-user-defined-prologue' setting:) S
PHL
LHL
(   ;; Setting for HP PostScript printer) S
LHL
(   \(setq ps-user-defined-prologue) S
LHL
9 W
(\(concat \\"<</DeferredMediaSelection true /PageSize [612 792] \\") S
LHL
17 W
(\\"/MediaPosition 2 /MediaType \(Plain\)>> setpagedevice\\"\)\)") S
LHL
(  :type '\(choice :menu-tag "User Defined Prologue") S
LHL
17 W
(:tag "User Defined Prologue") S
LHL
17 W
(\(const :tag "none" nil\) string symbol\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-print-prologue-header nil) S
LHL
(  "PostScript prologue header comments besides that ps-print generates.) S
PHL
LHL
(`ps-print-prologue-header' may be a string or a symbol function which returns a) S
LHL
(string.  Note that this string is inserted on PostScript prologue header) S
LHL
(section which is used to define some document characteristic through PostScript) S
LHL
(special comments, like \\"%%Requirements: jog\\\\n\\".) S
PHL
LHL
(ps-print always inserts the %%Requirements: comment, so if you need to insert) S
LHL
(more requirements put them first in `ps-print-prologue-header' using the) S
LHL
(\\"%%+\\" comment.  For example, if you need to set numcopies to 3 and jog on) S
LHL
(requirements and set %%LanguageLevel: to 2, do:) S
EndPage
EndDSCPage
EndSheet

%%Page: 24 52
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1657 def
/PageNumber 24 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1656 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
LHL
( \(setq ps-print-prologue-header) S
LHL
(       \\"%%+ numcopies\(3\) jog\\\\n%%LanguageLevel: 2\\\\n\\"\)) S
PHL
LHL
(The duplex requirement is inserted by ps-print \(see `ps-spool-duplex'\).) S
PHL
LHL
(Do not forget to terminate the string with \\"\\\\n\\".) S
PHL
LHL
(For more information about PostScript document comments, see:) S
LHL
(   PostScript Language Reference Manual \(2nd edition\)) S
LHL
(   Adobe Systems Incorporated) S
LHL
(   Appendix G: Document Structuring Conventions -- Version 3.0") S
LHL
(  :type '\(choice :menu-tag "Prologue Header") S
LHL
17 W
(:tag "Prologue Header") S
LHL
17 W
(\(const :tag "none" nil\) string symbol\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-printer-name nil) S
LHL
(  "The name of a local printer for printing PostScript files.) S
PHL
LHL
(On Unix-like systems, a string value should be a name understood by lpr's -P) S
LHL
(option; a value of nil means use the value of `printer-name' instead.) S
PHL
LHL
(On MS-DOS and MS-Windows systems, a string value is taken as the name of the) S
LHL
(printer device or port to which PostScript files are written, provided) S
LHL
(`ps-lpr-command' is \\"\\".  By default it is the same as `printer-name'; typical) S
LHL
(non-default settings would be \\"LPT1\\" to \\"LPT3\\" for parallel printers, or) S
LHL
(\\"COM1\\" to \\"COM4\\" or \\"AUX\\" for serial printers, or \\"\\\\\\\\hostname\\\\printer\\") S
LHL
(for a shared network printer.  You can also set it to a name of a file, in) S
LHL
(which case the output gets appended to that file.  \\\(Note that `ps-print') S
LHL
(package already has facilities for printing to a file, so you might as well use) S
LHL
(them instead of changing the setting of this variable.\)  If you want to) S
LHL
(silently discard the printed output, set this to \\"NUL\\".) S
PHL
LHL
(Set to t, if the utility given by `ps-lpr-command' needs an empty printer name.) S
PHL
LHL
(Any other value is treated as t, that is, an empty printer name.) S
PHL
LHL
(See also `ps-printer-name-option' for documentation.") S
LHL
(  :type '\(choice :menu-tag "Printer Name") S
LHL
17 W
(:tag "Printer Name") S
LHL
17 W
(\(const :tag "Same as printer-name" nil\)) S
LHL
17 W
(\(const :tag "No Printer Name" t\)) S
LHL
17 W
(\(file :tag "Print to file"\)) S
LHL
17 W
(\(string :tag "Pipe to ps-lpr-command"\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-printer\)) S
PHL
LHL
(\(defcustom ps-printer-name-option) S
LHL
(  \(cond \(lpr-windows-system "/D:"\)) S
LHL
8 W
(\(t lpr-printer-switch\)\)) S
LHL
(  "Option for `ps-printer-name' variable \(see it\).) S
PHL
LHL
(On Unix-like systems, if `lpr' is in use, this should be the string) S
LHL
(\\"-P\\"; if `lp' is in use, this should be the string \\"-d\\".) S
PHL
LHL
(On MS-DOS and MS-Windows systems, if `print' is in use, this should be) S
LHL
(the string \\"/D:\\".) S
PHL
LHL
(For any other printing utility, see its documentation.) S
PHL
LHL
(Set this to \\"\\" or nil, if the utility given by `ps-lpr-command') S
LHL
(needs an empty printer name option--that is, pass the printer name) S
LHL
(with no special option preceding it.) S
PHL
LHL
(This variable is used only when `ps-printer-name' is a non-empty string.") S
LHL
(  :type '\(choice :menu-tag "Printer Name Option") S
LHL
17 W
(:tag "Printer Name Option") S
LHL
17 W
(\(const :tag "None" nil\)) S
LHL
17 W
(\(string :tag "Option"\)\)) S
LHL
(  :version "21.1") S
EndPage
EndDSCPage
EndSheet

%%Page: 25 53
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1729 def
/PageNumber 25 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1728 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  :group 'ps-print-printer\)) S
PHL
LHL
(\(defcustom ps-lpr-command lpr-command) S
LHL
(  "Name of program for printing a PostScript file.) S
PHL
LHL
(On MS-DOS and MS-Windows systems, if the value is an empty string then Emacs) S
LHL
(will write directly to the printer port named by `ps-printer-name'.  The) S
LHL
(programs `print' and `nprint' \(the standard print programs on Windows NT and) S
LHL
(Novell Netware respectively\) are handled specially, using `ps-printer-name' as) S
LHL
(the destination for output; any other program is treated like `lpr' except that) S
LHL
(an explicit filename is given as the last argument.") S
LHL
(  :type 'string) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-printer\)) S
PHL
LHL
(\(defcustom ps-lpr-switches lpr-switches) S
LHL
(  "List of extra switches to pass to `ps-lpr-command'.) S
PHL
LHL
(The list element can be:) S
PHL
LHL
(   string) S
7 W
(it should be an option for `ps-lpr-command' \(which see\).) S
LHL
16 W
(For example: \\"-o Duplex=DuplexNoTumble\\") S
PHL
LHL
(   symbol) S
7 W
(it can be a function or variable symbol.  If it's a function) S
LHL
16 W
(symbol, it should be a function with no argument.  The result) S
LHL
16 W
(of the function or the variable value should be a string or a) S
LHL
16 W
(list of strings.) S
PHL
LHL
(   list) S
9 W
(the header should be a symbol function and the tail is the) S
LHL
16 W
(arguments for this function.  This function should return a) S
LHL
16 W
(string or a list of strings.) S
PHL
LHL
(Any other value is silently ignored.) S
PHL
LHL
(It is recommended to set `ps-printer-name' \(which see\) instead of including an) S
LHL
(explicit switch on this list.) S
PHL
LHL
(See `ps-lpr-command'.") S
LHL
(  :type '\(repeat :tag "PostScript lpr Switches") S
LHL
17 W
(\(choice :menu-tag "PostScript lpr Switch") S
LHL
25 W
(:tag "PostScript lpr Switch") S
LHL
25 W
(string symbol \(repeat sexp\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-printer\)) S
PHL
LHL
(\(defcustom ps-print-region-function) S
LHL
(  \(if \(memq system-type '\(ms-dos windows-nt\)\)) S
LHL
(      #'w32-direct-ps-print-region-function) S
LHL
(    #'call-process-region\)) S
LHL
(  "Specify a function to print the region on a PostScript printer.) S
LHL
(See definition of `call-process-region' for calling conventions.  The fourth) S
LHL
(and the sixth arguments are both nil.") S
LHL
(  :type 'function) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-printer\)) S
PHL
LHL
(\(defcustom ps-manual-feed nil) S
LHL
(  "Non-nil means the printer will manually feed paper.) S
PHL
LHL
(If it's nil, automatic feeding takes place.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-printer\)) S
PHL
LHL
(\(defcustom ps-end-with-control-d \(and lpr-windows-system t\)) S
LHL
(  "Non-nil means insert C-d at end of PostScript file generated.") S
LHL
(  :version "21.1") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-printer\)) S
PHL
LHL
(;;; Page layout) S
EndPage
EndDSCPage
EndSheet

%%Page: 26 54
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1801 def
/PageNumber 26 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1800 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
LHL
(;; All page dimensions are in PostScript points.) S
LHL
(;; 1 inch  ==       2.54  cm    ==     72       points) S
LHL
(;; 1 cm    ==  \(/ 1 2.54\) inch  ==  \(/ 72 2.54\) points) S
PHL
LHL
(;; Letter      8.5   inch x 11.0   inch) S
LHL
(;; Legal       8.5   inch x 14.0   inch) S
LHL
(;; A4          8.26  inch x 11.69  inch = 21.0 cm x 29.7 cm) S
PHL
LHL
(;; LetterSmall 7.68  inch x 10.16  inch) S
LHL
(;; Tabloid    11.0   inch x 17.0   inch) S
LHL
(;; Ledger     17.0   inch x 11.0   inch) S
LHL
(;; Statement   5.5   inch x  8.5   inch) S
LHL
(;; Executive   7.5   inch x 10.0   inch) S
LHL
(;; A3         11.69  inch x 16.5   inch = 29.7 cm x 42.0 cm) S
LHL
(;; A4Small     7.47  inch x 10.85  inch) S
LHL
(;; B4         10.125 inch x 14.33  inch) S
LHL
(;; B5          7.16  inch x 10.125 inch) S
PHL
LHL
(;;;###autoload) S
LHL
(\(defcustom ps-page-dimensions-database) S
LHL
( \(purecopy) S
LHL
(  \(list \(list 'a4    \(/ \(* 72 21.0\) 2.54\)  \(/ \(* 72 29.7\) 2.54\) "A4"\)) S
LHL
8 W
(\(list 'a3    \(/ \(* 72 29.7\) 2.54\)  \(/ \(* 72 42.0\) 2.54\) "A3"\)) S
LHL
8 W
(\(list 'letter       \(* 72  8.5\)    \(* 72 11.0\)          "Letter"\)) S
LHL
8 W
(\(list 'legal        \(* 72  8.5\)    \(* 72 14.0\)          "Legal"\)) S
LHL
8 W
(\(list 'letter-small \(* 72  7.68\)   \(* 72 10.16\)         "LetterSmall"\)) S
LHL
8 W
(\(list 'tabloid      \(* 72 11.0\)    \(* 72 17.0\)          "Tabloid"\)) S
LHL
8 W
(\(list 'ledger       \(* 72 17.0\)    \(* 72 11.0\)          "Ledger"\)) S
LHL
8 W
(\(list 'statement    \(* 72  5.5\)    \(* 72  8.5\)          "Statement"\)) S
LHL
8 W
(\(list 'executive    \(* 72  7.5\)    \(* 72 10.0\)          "Executive"\)) S
LHL
8 W
(\(list 'a4small      \(* 72  7.47\)   \(* 72 10.85\)         "A4Small"\)) S
LHL
8 W
(\(list 'b4           \(* 72 10.125\)  \(* 72 14.33\)         "B4"\)) S
LHL
8 W
(\(list 'b5           \(* 72  7.16\)   \(* 72 10.125\)        "B5"\)) S
LHL
8 W
(;; page sizes for label printer) S
LHL
8 W
(;; NOTE: the page sizes below don't have n-up > 1.) S
LHL
8 W
('\(addresslarge       236.0      99.0 "AddressLarge"\)) S
LHL
8 W
('\(addresssmall       236.0      68.0 "AddressSmall"\)) S
LHL
8 W
('\(cuthanging13        90.0     222.0 "CutHanging13"\)) S
LHL
8 W
('\(cuthanging15        90.0     114.0 "CutHanging15"\)) S
LHL
8 W
('\(diskette           181.0     136.0 "Diskette"\)) S
LHL
8 W
('\(eurofilefolder     139.0     112.0 "EuropeanFilefolder"\)) S
LHL
8 W
('\(eurofoldernarrow   526.0     107.0 "EuroFolderNarrow"\)) S
LHL
8 W
('\(eurofolderwide     526.0     136.0 "EuroFolderWide"\)) S
LHL
8 W
('\(euronamebadge      189.0     108.0 "EuroNameBadge"\)) S
LHL
8 W
('\(euronamebadgelarge 223.0     136.0 "EuroNameBadgeLarge"\)) S
LHL
8 W
('\(filefolder         230.0      37.0 "FileFolder"\)) S
LHL
8 W
('\(jewelry             76.0     136.0 "Jewelry"\)) S
LHL
8 W
('\(mediabadge         180.0     136.0 "MediaBadge"\)) S
LHL
8 W
('\(multipurpose       126.0      68.0 "MultiPurpose"\)) S
LHL
8 W
('\(retaillabel         90.0     104.0 "RetailLabel"\)) S
LHL
8 W
('\(shipping           271.0     136.0 "Shipping"\)) S
LHL
8 W
('\(slide35mm           26.0     104.0 "Slide35mm"\)) S
LHL
8 W
('\(spine8mm           187.0      26.0 "Spine8mm"\)) S
LHL
8 W
('\(topcoated          425.19685 136.0 "TopCoatedPaper"\)) S
LHL
8 W
('\(topcoatedpaper     396.0     136.0 "TopcoatedPaper150"\)) S
LHL
8 W
('\(vhsface            205.0     127.0 "VHSFace"\)) S
LHL
8 W
('\(vhsspine           400.0      50.0 "VHSSpine"\)) S
LHL
8 W
('\(zipdisk            156.0     136.0 "ZipDisk"\)\)\)) S
LHL
(  "List associating a symbolic paper type to its width, height and doc media.) S
LHL
(See `ps-paper-type'.") S
LHL
(  :type '\(repeat \(list :tag "Paper Type") S
LHL
23 W
(\(symbol :tag "Symbol Name"\)) S
LHL
23 W
(\(number :tag "Width in points"\)) S
LHL
23 W
(\(number :tag "Height in points"\)) S
LHL
23 W
(\(string :tag "Media"\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-page\)) S
PHL
LHL
(;;;###autoload) S
LHL
(\(defcustom ps-paper-type 'letter) S
LHL
(  "Specify the size of paper to format for.) S
EndPage
EndDSCPage
EndSheet

%%Page: 27 55
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1873 def
/PageNumber 27 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1872 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(Should be one of the paper types defined in `ps-page-dimensions-database', for) S
LHL
(example `letter', `legal' or `a4'.") S
LHL
(  :type '\(symbol :validate \(lambda \(wid\)) S
LHL
29 W
(\(if \(assq \(widget-value wid\)) S
LHL
39 W
(ps-page-dimensions-database\)) S
LHL
33 W
(nil) S
LHL
31 W
(\(widget-put wid :error "Unknown paper size"\)) S
LHL
31 W
(wid\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-page\)) S
PHL
LHL
(\(defcustom ps-warn-paper-type t) S
LHL
(  "Non-nil means give an error if paper size is not equal to `ps-paper-type'.) S
PHL
LHL
(It's used when `ps-spool-config' is set to `setpagedevice'.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-page\)) S
PHL
LHL
(\(defcustom ps-landscape-mode nil) S
LHL
(  "Non-nil means print in landscape mode.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-page\)) S
PHL
LHL
(\(defcustom ps-print-upside-down nil) S
LHL
(  "Non-nil means print upside-down \(that is, rotated by 180 degrees\).") S
LHL
(  :type 'boolean) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-page\)) S
PHL
LHL
(\(defcustom ps-selected-pages nil) S
LHL
(  "Specify which pages to print.) S
PHL
LHL
(If nil, print all pages.) S
PHL
LHL
(If a list, the lists element may be an integer or a cons cell \(FROM . TO\)) S
LHL
(designating FROM page to TO page; any invalid element is ignored, that is, an) S
LHL
(integer lesser than one or if FROM is greater than TO.) S
PHL
LHL
(Otherwise, it's treated as nil.) S
PHL
LHL
(After ps-print processing `ps-selected-pages' is set to nil.  But the) S
LHL
(latest `ps-selected-pages' is saved in `ps-last-selected-pages' \(which) S
LHL
(see\).  So you can restore the latest selected pages by using) S
LHL
(`ps-last-selected-pages' or with the `ps-restore-selected-pages') S
LHL
(command \(which see\).) S
PHL
LHL
(See also `ps-even-or-odd-pages'.") S
LHL
(  :type '\(repeat :tag "Selected Pages") S
LHL
17 W
(\(radio :tag "Page") S
LHL
24 W
(\(integer :tag "Number"\)) S
LHL
24 W
(\(cons :tag "Range") S
LHL
30 W
(\(integer :tag "From"\)) S
LHL
30 W
(\(integer :tag "To"\)\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-page\)) S
PHL
LHL
(\(defcustom ps-even-or-odd-pages nil) S
LHL
(  "Specify if it prints even/odd pages.) S
PHL
LHL
(Valid values are:) S
PHL
LHL
(   nil) S
10 W
(print all pages.) S
PHL
LHL
(   `even-page') S
2 W
(print only even pages.) S
PHL
LHL
(   `odd-page') S
3 W
(print only odd pages.) S
PHL
LHL
(   `even-sheet') S
1 W
(print only even sheets.) S
LHL
16 W
(That is, if `ps-n-up-printing' is 1, it behaves as `even-page';) S
LHL
16 W
(but for values greater than 1, it'll print only the even sheet) S
EndPage
EndDSCPage
EndSheet

%%Page: 28 56
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 1945 def
/PageNumber 28 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
1944 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
16 W
(of paper.) S
PHL
LHL
(   `odd-sheet') S
2 W
(print only odd sheets.) S
LHL
16 W
(That is, if `ps-n-up-printing' is 1, it behaves as `odd-page';) S
LHL
16 W
(but for values greater than 1, it'll print only the odd sheet) S
LHL
16 W
(of paper.) S
PHL
LHL
(Any other value is treated as nil.) S
PHL
LHL
(If you set option `ps-selected-pages', first the pages are) S
LHL
(filtered by option `ps-selected-pages' and then by `ps-even-or-odd-pages'.) S
LHL
(For example, if we have:) S
PHL
LHL
(   \(setq ps-selected-pages \\\\='\(1 4 \(6 . 10\) \(12 . 16\) 20\)\)) S
PHL
LHL
(Combining with `ps-even-or-odd-pages' and option `ps-n-up-printing', we have:) S
PHL
LHL
(`ps-n-up-printing' = 1:) S
LHL
(   `ps-even-or-odd-pages') S
7 W
(PAGES PRINTED) S
LHL
8 W
(nil) S
21 W
(1, 4, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 20) S
LHL
8 W
(even-page) S
15 W
(4, 6, 8, 10, 12, 14, 16, 20) S
LHL
8 W
(odd-page) S
16 W
(1, 7, 9, 13, 15) S
LHL
8 W
(even-sheet) S
14 W
(4, 6, 8, 10, 12, 14, 16, 20) S
LHL
8 W
(odd-sheet) S
15 W
(1, 7, 9, 13, 15) S
PHL
LHL
(`ps-n-up-printing' = 2:) S
LHL
(   `ps-even-or-odd-pages') S
7 W
(PAGES PRINTED) S
LHL
8 W
(nil) S
21 W
(1/4, 6/7, 8/9, 10/12, 13/14, 15/16, 20) S
LHL
8 W
(even-page) S
15 W
(4/6, 8/10, 12/14, 16/20) S
LHL
8 W
(odd-page) S
16 W
(1/7, 9/13, 15) S
LHL
8 W
(even-sheet) S
14 W
(6/7, 10/12, 15/16) S
LHL
8 W
(odd-sheet) S
15 W
(1/4, 8/9, 13/14, 20) S
PHL
LHL
(So even-page/odd-page are about page parity and even-sheet/odd-sheet are about) S
LHL
(sheet parity.") S
LHL
(  :type '\(choice :menu-tag "Print Even/Odd Pages") S
LHL
17 W
(:tag "Print Even/Odd Pages") S
LHL
17 W
(\(const :tag "All Pages" nil\)) S
LHL
17 W
(\(const :tag "Only Even Pages" even-page\)) S
LHL
17 W
(\(const :tag "Only Odd Pages" odd-page\)) S
LHL
17 W
(\(const :tag "Only Even Sheets" even-sheet\)) S
LHL
17 W
(\(const :tag "Only Odd Sheets" odd-sheet\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-page\)) S
PHL
LHL
(\(defcustom ps-print-control-characters 'control-8-bit) S
LHL
(  "Specify the printable form for control and 8-bit characters.) S
LHL
(That is, instead of sending, for example, a ^D \(\\\\004\) to printer,) S
LHL
(it is sent the string \\"^D\\".) S
PHL
LHL
(Valid values are:) S
PHL
LHL
(  `8-bit'         This is the value to use when you want an ASCII encoding of) S
LHL
18 W
(any control or non-ASCII character.  Control characters are) S
LHL
18 W
(encoded as \\"^D\\", and non-ASCII characters have an) S
LHL
18 W
(octal encoding.) S
PHL
LHL
(  `control-8-bit' This is the value to use when you want an ASCII encoding of) S
LHL
18 W
(any control character, whether it is 7 or 8-bit.) S
LHL
18 W
(European 8-bits accented characters are printed according) S
LHL
18 W
(the current font.) S
PHL
LHL
(  `control'       Only ASCII control characters have an ASCII encoding.) S
LHL
18 W
(European 8-bits accented characters are printed according) S
LHL
18 W
(the current font.) S
PHL
LHL
(  nil             No ASCII encoding.  Any character is printed according the) S
LHL
18 W
(current font.) S
PHL
LHL
(Any other value is treated as nil.") S
LHL
(  :type '\(choice :menu-tag "Control Char") S
LHL
17 W
(:tag "Control Char") S
EndPage
EndDSCPage
EndSheet

%%Page: 29 57
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2017 def
/PageNumber 29 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2016 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
17 W
(\(const 8-bit\)   \(const control-8-bit\)) S
LHL
17 W
(\(const control\) \(const :tag "nil" nil\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-n-up-printing 1) S
LHL
(  "Specify the number of pages per sheet paper.") S
LHL
(  :type '\(integer) S
LHL
10 W
(:tag "N Up Printing") S
LHL
10 W
(:validate) S
LHL
10 W
(\(lambda \(wid\)) S
LHL
12 W
(\(if \(and \(< 0 \(widget-value wid\)\)) S
LHL
21 W
(\(<= \(widget-value wid\) 100\)\)) S
LHL
16 W
(nil) S
LHL
14 W
(\(widget-put) S
LHL
15 W
(wid :error) S
LHL
15 W
("Number of pages per sheet paper must be between 1 and 100."\)) S
LHL
14 W
(wid\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-n-up\)) S
PHL
LHL
(\(defcustom ps-n-up-margin \(/ \(* 72  1.0\) 2.54\) ; 1 cm) S
LHL
(  "Specify the margin in points between the sheet border and n-up printing.") S
LHL
(  :type 'number) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-n-up\)) S
PHL
LHL
(\(defcustom ps-n-up-border-p t) S
LHL
(  "Non-nil means a border is drawn around each page.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-n-up\)) S
PHL
LHL
(\(defcustom ps-n-up-filling 'left-top) S
LHL
(  "Specify how page matrix is filled on each sheet of paper.) S
PHL
LHL
(Following are the valid values for `ps-n-up-filling' with a filling example) S
LHL
(using a 3x4 page matrix:) S
PHL
LHL
(   `left-top'   1  2  3  4         `left-bottom'    9  10 11 12) S
LHL
16 W
(5  6  7  8                          5  6  7  8) S
LHL
16 W
(9  10 11 12                         1  2  3  4) S
PHL
LHL
(   `right-top'  4  3  2  1         `right-bottom'   12 11 10 9) S
LHL
16 W
(8  7  6  5                          8  7  6  5) S
LHL
16 W
(12 11 10 9                          4  3  2  1) S
PHL
LHL
(   `top-left'   1  4  7  10        `bottom-left'    3  6  9  12) S
LHL
16 W
(2  5  8  11                         2  5  8  11) S
LHL
16 W
(3  6  9  12                         1  4  7  10) S
PHL
LHL
(   `top-right'  10 7  4  1         `bottom-right'   12 9  6  3) S
LHL
16 W
(11 8  5  2                          11 8  5  2) S
LHL
16 W
(12 9  6  3                          10 7  4  1) S
PHL
LHL
(Any other value is treated as `left-top'.") S
LHL
(  :type '\(choice :menu-tag "N-Up Filling") S
LHL
17 W
(:tag "N-Up Filling") S
LHL
17 W
(\(const left-top\)  \(const left-bottom\)) S
LHL
17 W
(\(const right-top\) \(const right-bottom\)) S
LHL
17 W
(\(const top-left\)  \(const bottom-left\)) S
LHL
17 W
(\(const top-right\) \(const bottom-right\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-n-up\)) S
PHL
LHL
(\(defcustom ps-number-of-columns \(if ps-landscape-mode 2 1\)) S
LHL
(  "Specify the number of columns.") S
LHL
(  :type 'number) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-zebra-stripes nil) S
EndPage
EndDSCPage
EndSheet

%%Page: 30 58
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2089 def
/PageNumber 30 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2088 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  "Non-nil means print zebra stripes.) S
LHL
(See also documentation for `ps-zebra-stripe-height' and `ps-zebra-color'.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-zebra\)) S
PHL
LHL
(\(defcustom ps-zebra-stripe-height 3) S
LHL
(  "Number of zebra stripe lines.) S
LHL
(See also documentation for `ps-zebra-stripes' and `ps-zebra-color'.") S
LHL
(  :type 'number) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-zebra\)) S
PHL
LHL
(\(defcustom ps-zebra-color 0.95) S
LHL
(  "Zebra stripe gray scale or RGB color.) S
LHL
(See also documentation for `ps-zebra-stripes' and `ps-zebra-stripe-height'.") S
LHL
(  :type '\(choice :menu-tag "Zebra Gray/Color") S
LHL
17 W
(:tag "Zebra Gray/Color") S
LHL
17 W
(\(number :tag "Gray Scale" :value 0.95\)) S
LHL
17 W
(\(string :tag "Color Name" :value "gray95"\)) S
LHL
17 W
(\(list :tag "RGB Color" :value \(0.95 0.95 0.95\)) S
LHL
23 W
(\(number :tag "Red"\)) S
LHL
23 W
(\(number :tag "Green"\)) S
LHL
23 W
(\(number :tag "Blue"\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-zebra\)) S
PHL
LHL
(\(defcustom ps-zebra-stripe-follow nil) S
LHL
(  "Specify how zebra stripes continue on next page.) S
PHL
LHL
(Visually, valid values are \(the character `+' at right of each column indicates) S
LHL
(that a line is printed\):) S
PHL
LHL
20 W
(nil         `follow'        `full'        `full-follow') S
LHL
(   Current Page --------     -----------     ---------     ----------------) S
LHL
16 W
(1  XXXXX +   1  XXXXXXXX +   1  XXXXXX +   1  XXXXXXXXXXXXX +) S
LHL
16 W
(2  XXXXX +   2  XXXXXXXX +   2  XXXXXX +   2  XXXXXXXXXXXXX +) S
LHL
16 W
(3  XXXXX +   3  XXXXXXXX +   3  XXXXXX +   3  XXXXXXXXXXXXX +) S
LHL
16 W
(4        +   4           +   4         +   4                +) S
LHL
16 W
(5        +   5           +   5         +   5                +) S
LHL
16 W
(6        +   6           +   6         +   6                +) S
LHL
16 W
(7  XXXXX +   7  XXXXXXXX +   7  XXXXXX +   7  XXXXXXXXXXXXX +) S
LHL
16 W
(8  XXXXX +   8  XXXXXXXX +   8  XXXXXX +   8  XXXXXXXXXXXXX +) S
LHL
16 W
(9  XXXXX +   9  XXXXXXXX +   9  XXXXXX +   9  XXXXXXXXXXXXX +) S
LHL
16 W
(10       +   10          +) S
LHL
16 W
(11       +   11          +) S
LHL
16 W
(--------     -----------     ---------     ----------------) S
LHL
(      Next Page --------     -----------     ---------     ----------------) S
LHL
16 W
(12 XXXXX +   12          +   10 XXXXXX +   10               +) S
LHL
16 W
(13 XXXXX +   13 XXXXXXXX +   11 XXXXXX +   11               +) S
LHL
16 W
(14 XXXXX +   14 XXXXXXXX +   12 XXXXXX +   12               +) S
LHL
16 W
(15       +   15 XXXXXXXX +   13        +   13 XXXXXXXXXXXXX +) S
LHL
16 W
(16       +   16          +   14        +   14 XXXXXXXXXXXXX +) S
LHL
16 W
(17       +   17          +   15        +   15 XXXXXXXXXXXXX +) S
LHL
16 W
(18 XXXXX +   18          +   16 XXXXXX +   16               +) S
LHL
16 W
(19 XXXXX +   19 XXXXXXXX +   17 XXXXXX +   17               +) S
LHL
16 W
(20 XXXXX +   20 XXXXXXXX +   18 XXXXXX +   18               +) S
LHL
16 W
(21       +   21 XXXXXXXX +) S
LHL
16 W
(22       +   22          +) S
LHL
16 W
(--------     -----------     ---------     ----------------) S
PHL
LHL
(Any other value is treated as nil.") S
LHL
(  :type '\(choice :menu-tag "Zebra Stripe Follow") S
LHL
17 W
(:tag "Zebra Stripe Follow") S
LHL
17 W
(\(const :tag "Always Restart" nil\)) S
LHL
17 W
(\(const :tag "Continue on Next Page" follow\)) S
LHL
17 W
(\(const :tag "Print Only Full Stripe" full\)) S
LHL
17 W
(\(const :tag "Continue on Full Stripe" full-follow\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-zebra\)) S
PHL
LHL
(\(defcustom ps-line-number nil) S
EndPage
EndDSCPage
EndSheet

%%Page: 31 59
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2161 def
/PageNumber 31 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2160 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  "Non-nil means print line number.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-line-number-step 1) S
LHL
(  "Specify the interval that line number is printed.) S
PHL
LHL
(For example, `ps-line-number-step' is set to 2, the printing will look like:) S
PHL
LHL
(   1 one line) S
LHL
(     one line) S
LHL
(   3 one line) S
LHL
(     one line) S
LHL
(   5 one line) S
LHL
(     one line) S
LHL
(     ...) S
PHL
LHL
(Valid values are:) S
PHL
LHL
(   integer) S
6 W
(an integer that specifies the interval that line number is) S
LHL
16 W
(printed.  If it's lesser than or equal to zero, it's used the) S
LHL
16 W
(value 1.) S
PHL
LHL
(   `zebra') S
6 W
(specifies that only the line number of the first line in a) S
LHL
16 W
(zebra stripe is to be printed.) S
PHL
LHL
(Any other value is treated as `zebra'.") S
LHL
(  :type '\(choice :menu-tag "Line Number Step") S
LHL
17 W
(:tag "Line Number Step") S
LHL
17 W
(\(integer :tag "Step Interval"\)) S
LHL
17 W
(\(const :tag "Synchronize Zebra" zebra\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-line-number-start 1) S
LHL
(  "Specify the starting point in the interval given by `ps-line-number-step'.) S
PHL
LHL
(For example, if `ps-line-number-step' is set to 3 and `ps-line-number-start' is) S
LHL
(set to 3, the printing will look like:) S
PHL
LHL
(      one line) S
LHL
(      one line) S
LHL
(    3 one line) S
LHL
(      one line) S
LHL
(      one line) S
LHL
(    6 one line) S
LHL
(      one line) S
LHL
(      one line) S
LHL
(    9 one line) S
LHL
(      one line) S
LHL
(      ...) S
PHL
LHL
(The values for `ps-line-number-start':) S
PHL
LHL
(   * If `ps-line-number-step' is an integer, must be between 1 and the value of) S
LHL
(     `ps-line-number-step' inclusive.) S
PHL
LHL
(   * If `ps-line-number-step' is set to `zebra', must be between 1 and the) S
LHL
(     value of `ps-zebra-strip-height' inclusive.  Use this combination if you) S
LHL
(     wish that line number be relative to zebra stripes.") S
LHL
(  :type '\(integer :tag "Start Step Interval"\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-print-background-image nil) S
LHL
(  "EPS image list to be printed on background.) S
PHL
LHL
(The elements are:) S
PHL
LHL
(   \(FILENAME X Y XSCALE YSCALE ROTATION PAGES...\)) S
PHL
EndPage
EndDSCPage
EndSheet

%%Page: 32 60
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2233 def
/PageNumber 32 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2232 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(FILENAME is a file name which contains an EPS image or some PostScript) S
LHL
(programming like EPS.) S
LHL
(FILENAME is ignored, if it doesn't exist or is read protected.) S
PHL
LHL
(X and Y are relative positions on paper to put the image.) S
LHL
(If X and Y are nil, the image is centered on paper.) S
PHL
LHL
(XSCALE and YSCALE are scale factor to be applied to image before printing.) S
LHL
(If XSCALE and YSCALE are nil, the original size is used.) S
PHL
LHL
(ROTATION is the image rotation angle; if nil, the default is 0.) S
PHL
LHL
(PAGES designates the page to print background image.) S
LHL
(PAGES may be a number or a cons cell \(FROM . TO\) designating FROM page to TO) S
LHL
(page.) S
LHL
(If PAGES is nil, print background image on all pages.) S
PHL
LHL
(X, Y, XSCALE, YSCALE and ROTATION may be a floating point number, an integer) S
LHL
(number or a string.  If it is a string, the string should contain PostScript) S
LHL
(programming that returns a float or integer value.) S
PHL
LHL
(For example, if you wish to print an EPS image on all pages use:) S
PHL
LHL
(   \(\(\\"~/images/EPS-image.ps\\"\)\)") S
LHL
(  :type '\(repeat) S
LHL
10 W
(\(list) S
LHL
11 W
(\(file   :tag "EPS File"\)) S
LHL
11 W
(\(choice :tag "X" \(const :tag "default" nil\) number string\)) S
LHL
11 W
(\(choice :tag "Y" \(const :tag "default" nil\) number string\)) S
LHL
11 W
(\(choice :tag "X Scale" \(const :tag "default" nil\) number string\)) S
LHL
11 W
(\(choice :tag "Y Scale" \(const :tag "default" nil\) number string\)) S
LHL
11 W
(\(choice :tag "Rotation" \(const :tag "default" nil\) number string\)) S
LHL
11 W
(\(repeat :tag "Pages" :inline t) S
LHL
19 W
(\(radio \(integer :tag "Page"\)) S
LHL
26 W
(\(cons :tag "Range") S
LHL
32 W
(\(integer :tag "From"\)) S
LHL
32 W
(\(integer :tag "To"\)\)\)\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-background\)) S
PHL
LHL
(\(defcustom ps-print-background-text nil) S
LHL
(  "Text list to be printed on background.) S
PHL
LHL
(The elements are:) S
PHL
LHL
(   \(STRING X Y FONT FONTSIZE GRAY ROTATION PAGES...\)) S
PHL
LHL
(STRING is the text to be printed on background.) S
PHL
LHL
(X and Y are positions on paper to put the text.) S
LHL
(If X and Y are nil, the text is positioned at lower left corner.) S
PHL
LHL
(FONT is a font name to be used on printing the text.) S
LHL
(If nil, \\"Times-Roman\\" is used.) S
PHL
LHL
(FONTSIZE is font size to be used, if nil, 200 is used.) S
PHL
LHL
(GRAY is the text gray factor \(should be very light like 0.8\).) S
LHL
(If nil, the default is 0.85.) S
PHL
LHL
(ROTATION is the text rotation angle; if nil, the angle is given by the diagonal) S
LHL
(from lower left corner to upper right corner.) S
PHL
LHL
(PAGES designates the page to print background text.) S
LHL
(PAGES may be a number or a cons cell \(FROM . TO\) designating FROM page to TO) S
LHL
(page.) S
LHL
(If PAGES is nil, print background text on all pages.) S
PHL
LHL
(X, Y, FONTSIZE, GRAY and ROTATION may be a floating point number, an integer) S
LHL
(number or a string.  If it is a string, the string should contain PostScript) S
LHL
(programming that returns a float or integer value.) S
PHL
EndPage
EndDSCPage
EndSheet

%%Page: 33 61
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2305 def
/PageNumber 33 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2304 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(For example, if you wish to print text \\"Preliminary\\" on all pages use:) S
PHL
LHL
(   \(\(\\"Preliminary\\"\)\)") S
LHL
(  :type '\(repeat) S
LHL
10 W
(\(list) S
LHL
11 W
(\(string :tag "Text"\)) S
LHL
11 W
(\(choice :tag "X" \(const :tag "default" nil\) number string\)) S
LHL
11 W
(\(choice :tag "Y" \(const :tag "default" nil\) number string\)) S
LHL
11 W
(\(choice :tag "Font" \(const :tag "default" nil\) string\)) S
LHL
11 W
(\(choice :tag "Fontsize" \(const :tag "default" nil\) number string\)) S
LHL
11 W
(\(choice :tag "Gray" \(const :tag "default" nil\) number string\)) S
LHL
11 W
(\(choice :tag "Rotation" \(const :tag "default" nil\) number string\)) S
LHL
11 W
(\(repeat :tag "Pages" :inline t) S
LHL
19 W
(\(radio \(integer :tag "Page"\)) S
LHL
26 W
(\(cons :tag "Range") S
LHL
32 W
(\(integer :tag "From"\)) S
LHL
32 W
(\(integer :tag "To"\)\)\)\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-background\)) S
PHL
LHL
(;;; Horizontal layout) S
PHL
LHL
(;;  ------------------------------------------) S
LHL
(;;  |    |      |    |      |    |      |    |) S
LHL
(;;  | lm | text | ic | text | ic | text | rm |) S
LHL
(;;  |    |      |    |      |    |      |    |) S
LHL
(;;  ------------------------------------------) S
PHL
LHL
(\(defcustom ps-left-margin   \(/ \(* 72  2.0\) 2.54\) ;   2 cm) S
LHL
(  "Left margin in points \(1/72 inch\).") S
LHL
(  :type 'number) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-horizontal\)) S
PHL
LHL
(\(defcustom ps-right-margin  \(/ \(* 72  2.0\) 2.54\) ;   2 cm) S
LHL
(  "Right margin in points \(1/72 inch\).") S
LHL
(  :type 'number) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-horizontal\)) S
PHL
LHL
(\(defcustom ps-inter-column  \(/ \(* 72  2.0\) 2.54\) ;   2 cm) S
LHL
(  "Horizontal space between columns in points \(1/72 inch\).") S
LHL
(  :type 'number) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-horizontal\)) S
PHL
LHL
(;;; Vertical layout) S
PHL
LHL
(;; |--------|) S
LHL
(;; | tm     |) S
LHL
(;; |--------|) S
LHL
(;; | header |) S
LHL
(;; |--------|) S
LHL
(;; | ho     |) S
LHL
(;; |--------|) S
LHL
(;; | text   |) S
LHL
(;; |--------|) S
LHL
(;; | bm     |) S
LHL
(;; |--------|) S
PHL
LHL
(\(defcustom ps-bottom-margin \(/ \(* 72  1.5\) 2.54\) ; 1.5 cm) S
LHL
(  "Bottom margin in points \(1/72 inch\).") S
LHL
(  :type 'number) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-vertical\)) S
PHL
LHL
(\(defcustom ps-top-margin    \(/ \(* 72  1.5\) 2.54\) ; 1.5 cm) S
LHL
(  "Top margin in points \(1/72 inch\).") S
LHL
(  :type 'number) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-vertical\)) S
PHL
EndPage
EndDSCPage
EndSheet

%%Page: 34 62
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2377 def
/PageNumber 34 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2376 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(\(defcustom ps-header-offset \(/ \(* 72  1.0\) 2.54\) ; 1.0 cm) S
LHL
(  "Vertical space in points \(1/72 inch\) between the main text and the header.") S
LHL
(  :type 'number) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-vertical\)) S
PHL
LHL
(\(defcustom ps-header-line-pad 0.15) S
LHL
(  "Portion of a header title line height to insert.) S
LHL
(The insertion is done between the header frame and the text it contains,) S
LHL
(both in the vertical and horizontal directions.") S
LHL
(  :type 'number) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-vertical\)) S
PHL
LHL
(\(defcustom ps-footer-offset \(/ \(* 72  1.0\) 2.54\) ; 1.0 cm) S
LHL
(  "Vertical space in points \(1/72 inch\) between the main text and the footer.") S
LHL
(  :type 'number) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-vertical\)) S
PHL
LHL
(\(defcustom ps-footer-line-pad 0.15) S
LHL
(  "Portion of a footer title line height to insert.) S
LHL
(The insertion is done between the footer frame and the text it contains,) S
LHL
(both in the vertical and horizontal directions.") S
LHL
(  :type 'number) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-vertical\)) S
PHL
LHL
(;;; Header/Footer setup) S
PHL
LHL
(\(defcustom ps-print-header t) S
LHL
(  "Non-nil means print a header at the top of each page.) S
LHL
(By default, the header displays the buffer name, page number, and, if the) S
LHL
(buffer is visiting a file, the file's directory.  Headers are customizable by) S
LHL
(changing variables `ps-left-header' and `ps-right-header'.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-print-header-frame t) S
LHL
(  "Non-nil means draw a gaudy frame around the header.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-header-frame-alist) S
LHL
(  '\(\(fore-color   . 0.0\)) S
LHL
(    \(back-color   . 0.9\)) S
LHL
(    \(border-width . 0.4\)) S
LHL
(    \(border-color . 0.0\)) S
LHL
(    \(shadow-color . 0.0\)\)) S
LHL
(  "Specify header frame properties alist.) S
PHL
LHL
(Valid frame properties are:) S
PHL
LHL
(   `fore-color') S
9 W
(Specify the foreground frame color.) S
LHL
24 W
(It should be a float number between 0.0 \(black color\)) S
LHL
24 W
(and 1.0 \(white color\), a string which is a color name,) S
LHL
24 W
(or a list of 3 float numbers which corresponds to the) S
LHL
24 W
(Red Green Blue color scale, each float number between) S
LHL
24 W
(0.0 \(dark color\) and 1.0 \(bright color\).) S
PHL
LHL
(   `back-color') S
9 W
(Specify the background frame color \(similar to) S
LHL
24 W
(`fore-color'\).) S
PHL
LHL
(   `shadow-color') S
7 W
(Specify the shadow color \(similar to `fore-color'\).) S
PHL
LHL
(   `border-color') S
7 W
(Specify the border color \(similar to `fore-color'\).) S
PHL
LHL
(   `border-width') S
7 W
(Specify the border width.) S
PHL
LHL
(Any other property is ignored.) S
EndPage
EndDSCPage
EndSheet

%%Page: 35 63
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2449 def
/PageNumber 35 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2448 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
LHL
(Don't change this alist directly, instead use customization, or `ps-value',) S
LHL
(`ps-get', `ps-put' and `ps-del' functions \(see them for documentation\).") S
LHL
(  :version "21.1") S
LHL
(  :type '\(repeat) S
LHL
10 W
(\(choice :menu-tag "Header Frame Element") S
LHL
18 W
(:tag "") S
LHL
18 W
(\(cons :tag "Foreground Color" :format "%v") S
LHL
24 W
(\(const :format "" fore-color\)) S
LHL
24 W
(\(choice :menu-tag "Foreground Color") S
LHL
32 W
(:tag "Foreground Color") S
LHL
32 W
(\(number :tag "Gray Scale" :value 0.0\)) S
LHL
32 W
(\(string :tag "Color Name" :value "black"\)) S
LHL
32 W
(\(list :tag "RGB Color" :value \(0.0 0.0 0.0\)) S
LHL
38 W
(\(number :tag "Red"\)) S
LHL
38 W
(\(number :tag "Green"\)) S
LHL
38 W
(\(number :tag "Blue"\)\)\)\)) S
LHL
18 W
(\(cons :tag "Background Color" :format "%v") S
LHL
24 W
(\(const :format "" back-color\)) S
LHL
24 W
(\(choice :menu-tag "Background Color") S
LHL
32 W
(:tag "Background Color") S
LHL
32 W
(\(number :tag "Gray Scale" :value 0.9\)) S
LHL
32 W
(\(string :tag "Color Name" :value "gray90"\)) S
LHL
32 W
(\(list :tag "RGB Color" :value \(0.9 0.9 0.9\)) S
LHL
38 W
(\(number :tag "Red"\)) S
LHL
38 W
(\(number :tag "Green"\)) S
LHL
38 W
(\(number :tag "Blue"\)\)\)\)) S
LHL
18 W
(\(cons :tag "Border Width" :format "%v") S
LHL
24 W
(\(const :format "" border-width\)) S
LHL
24 W
(\(number :tag "Border Width" :value 0.4\)\)) S
LHL
18 W
(\(cons :tag "Border Color" :format "%v") S
LHL
24 W
(\(const :format "" border-color\)) S
LHL
24 W
(\(choice :menu-tag "Border Color") S
LHL
32 W
(:tag "Border Color") S
LHL
32 W
(\(number :tag "Gray Scale" :value 0.0\)) S
LHL
32 W
(\(string :tag "Color Name" :value "black"\)) S
LHL
32 W
(\(list :tag "RGB Color" :value \(0.0 0.0 0.0\)) S
LHL
38 W
(\(number :tag "Red"\)) S
LHL
38 W
(\(number :tag "Green"\)) S
LHL
38 W
(\(number :tag "Blue"\)\)\)\)) S
LHL
18 W
(\(cons :tag "Shadow Color" :format "%v") S
LHL
24 W
(\(const :format "" shadow-color\)) S
LHL
24 W
(\(choice :menu-tag "Shadow Color") S
LHL
32 W
(:tag "Shadow Color") S
LHL
32 W
(\(number :tag "Gray Scale" :value 0.0\)) S
LHL
32 W
(\(string :tag "Color Name" :value "black"\)) S
LHL
32 W
(\(list :tag "RGB Color" :value \(0.0 0.0 0.0\)) S
LHL
38 W
(\(number :tag "Red"\)) S
LHL
38 W
(\(number :tag "Green"\)) S
LHL
38 W
(\(number :tag "Blue"\)\)\)\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-header-lines 2) S
LHL
(  "Number of lines to display in page header, when generating PostScript.") S
LHL
(  :type 'integer) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-print-footer nil) S
LHL
(  "Non-nil means print a footer at the bottom of each page.) S
LHL
(By default, the footer displays page number.) S
LHL
(Footers are customizable by changing variables `ps-left-footer' and) S
LHL
(`ps-right-footer'.") S
LHL
(  :type 'boolean) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-print-footer-frame t) S
LHL
(  "Non-nil means draw a gaudy frame around the footer.") S
LHL
(  :type 'boolean) S
LHL
(  :version "21.1") S
EndPage
EndDSCPage
EndSheet

%%Page: 36 64
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2521 def
/PageNumber 36 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2520 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-footer-frame-alist) S
LHL
(  '\(\(fore-color   . 0.0\)) S
LHL
(    \(back-color   . 0.9\)) S
LHL
(    \(border-width . 0.4\)) S
LHL
(    \(border-color . 0.0\)) S
LHL
(    \(shadow-color . 0.0\)\)) S
LHL
(  "Specify footer frame properties alist.) S
PHL
LHL
(Don't change this alist directly, instead use customization, or `ps-value',) S
LHL
(`ps-get', `ps-put' and `ps-del' functions \(see them for documentation\).) S
PHL
LHL
(See also `ps-header-frame-alist' for documentation.") S
LHL
(  :type '\(repeat) S
LHL
10 W
(\(choice :menu-tag "Header Frame Element") S
LHL
18 W
(:tag "") S
LHL
18 W
(\(cons :tag "Foreground Color" :format "%v") S
LHL
24 W
(\(const :format "" fore-color\)) S
LHL
24 W
(\(choice :menu-tag "Foreground Color") S
LHL
32 W
(:tag "Foreground Color") S
LHL
32 W
(\(number :tag "Gray Scale" :value 0.0\)) S
LHL
32 W
(\(string :tag "Color Name" :value "black"\)) S
LHL
32 W
(\(list :tag "RGB Color" :value \(0.0 0.0 0.0\)) S
LHL
38 W
(\(number :tag "Red"\)) S
LHL
38 W
(\(number :tag "Green"\)) S
LHL
38 W
(\(number :tag "Blue"\)\)\)\)) S
LHL
18 W
(\(cons :tag "Background Color" :format "%v") S
LHL
24 W
(\(const :format "" back-color\)) S
LHL
24 W
(\(choice :menu-tag "Background Color") S
LHL
32 W
(:tag "Background Color") S
LHL
32 W
(\(number :tag "Gray Scale" :value 0.9\)) S
LHL
32 W
(\(string :tag "Color Name" :value "gray90"\)) S
LHL
32 W
(\(list :tag "RGB Color" :value \(0.9 0.9 0.9\)) S
LHL
38 W
(\(number :tag "Red"\)) S
LHL
38 W
(\(number :tag "Green"\)) S
LHL
38 W
(\(number :tag "Blue"\)\)\)\)) S
LHL
18 W
(\(cons :tag "Border Width" :format "%v") S
LHL
24 W
(\(const :format "" border-width\)) S
LHL
24 W
(\(number :tag "Border Width" :value 0.4\)\)) S
LHL
18 W
(\(cons :tag "Border Color" :format "%v") S
LHL
24 W
(\(const :format "" border-color\)) S
LHL
24 W
(\(choice :menu-tag "Border Color") S
LHL
32 W
(:tag "Border Color") S
LHL
32 W
(\(number :tag "Gray Scale" :value 0.0\)) S
LHL
32 W
(\(string :tag "Color Name" :value "black"\)) S
LHL
32 W
(\(list :tag "RGB Color" :value \(0.0 0.0 0.0\)) S
LHL
38 W
(\(number :tag "Red"\)) S
LHL
38 W
(\(number :tag "Green"\)) S
LHL
38 W
(\(number :tag "Blue"\)\)\)\)) S
LHL
18 W
(\(cons :tag "Shadow Color" :format "%v") S
LHL
24 W
(\(const :format "" shadow-color\)) S
LHL
24 W
(\(choice :menu-tag "Shadow Color") S
LHL
32 W
(:tag "Shadow Color") S
LHL
32 W
(\(number :tag "Gray Scale" :value 0.0\)) S
LHL
32 W
(\(string :tag "Color Name" :value "black"\)) S
LHL
32 W
(\(list :tag "RGB Color" :value \(0.0 0.0 0.0\)) S
LHL
38 W
(\(number :tag "Red"\)) S
LHL
38 W
(\(number :tag "Green"\)) S
LHL
38 W
(\(number :tag "Blue"\)\)\)\)\)\)) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-footer-lines 2) S
LHL
(  "Number of lines to display in page footer, when generating PostScript.") S
LHL
(  :type 'integer) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-print-only-one-header nil) S
LHL
(  "Non-nil means print only one header/footer at the top/bottom of each page.) S
LHL
(This is useful when printing more than one column, so it is possible to have) S
EndPage
EndDSCPage
EndSheet

%%Page: 37 65
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2593 def
/PageNumber 37 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2592 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(only one header/footer over all columns or one header/footer per column.) S
LHL
(See also `ps-print-header' and `ps-print-footer'.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-switch-header 'duplex) S
LHL
(  "Specify if headers/footers are switched or not.) S
PHL
LHL
(Valid values are:) S
PHL
LHL
(nil) S
5 W
(Never switch headers/footers.) S
PHL
LHL
(t) S
7 W
(Always switch headers/footers.) S
PHL
LHL
(duplex) S
2 W
(Switch headers/footers only when duplexing is on, that is, when) S
LHL
8 W
(`ps-spool-duplex' is non-nil.) S
PHL
LHL
(Any other value is treated as t.) S
PHL
LHL
(See also `ps-print-header' and `ps-print-footer'.") S
LHL
(  :type '\(choice :menu-tag "Switch Header/Footer") S
LHL
17 W
(:tag "Switch Header/Footer") S
LHL
17 W
(\(const :tag "Never Switch" nil\)) S
LHL
17 W
(\(const :tag "Always Switch" t\)) S
LHL
17 W
(\(const :tag "Switch When Duplexing" duplex\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-show-n-of-n t) S
LHL
(  "Non-nil means show page numbers as N/M, meaning page N of M.) S
LHL
(NOTE: page numbers are displayed as part of headers,) S
LHL
(      see variable `ps-print-header'.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-spool-config) S
LHL
(  \(if lpr-windows-system) S
LHL
(      nil) S
LHL
(    'lpr-switches\)) S
LHL
(  "Specify who is responsible for setting duplex and page size.) S
PHL
LHL
(Valid values are:) S
PHL
LHL
(  `lpr-switches'    duplex and page size are configured by `ps-lpr-switches'.) S
LHL
20 W
(Don't forget to set `ps-lpr-switches' to select duplex) S
LHL
20 W
(printing for your printer.) S
PHL
LHL
(  `setpagedevice'   duplex and page size are configured by ps-print using the) S
LHL
20 W
(setpagedevice PostScript operator.) S
PHL
LHL
(  nil               duplex and page size are configured by ps-print *not* using) S
LHL
20 W
(the setpagedevice PostScript operator.) S
PHL
LHL
(Any other value is treated as nil.) S
PHL
LHL
(WARNING: The setpagedevice PostScript operator affects ghostview utility when) S
LHL
9 W
(viewing file generated using landscape.  Also on some printers,) S
LHL
9 W
(setpagedevice affects zebra stripes; on other printers, setpagedevice) S
LHL
9 W
(affects the left margin.) S
LHL
9 W
(Besides all that, if your printer does not have the paper size) S
LHL
9 W
(specified by setpagedevice, your printing will be aborted.) S
LHL
9 W
(So, if you need to use setpagedevice, set `ps-spool-config' to) S
LHL
9 W
(`setpagedevice', generate a test file and send it to your printer; if) S
LHL
9 W
(the printed file isn't OK, set `ps-spool-config' to nil.") S
LHL
(  :type '\(choice :menu-tag "Spool Config") S
LHL
17 W
(:tag "Spool Config") S
LHL
17 W
(\(const lpr-switches\) \(const setpagedevice\)) S
LHL
17 W
(\(const :tag "nil" nil\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-headers\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 38 66
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2665 def
/PageNumber 38 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2664 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
LHL
(\(defcustom ps-spool-duplex nil) S
10 W
(; Not many people have duplex printers,) S
LHL
40 W
(; so default to nil.) S
LHL
(  "Non-nil generates PostScript for a two-sided printer.) S
LHL
(For a duplex printer, the `ps-spool-*' and `ps-print-*' commands will insert) S
LHL
(blank pages as needed between print jobs so that the next buffer printed will) S
LHL
(start on the right page.  Also, if headers are turned on, the headers will be) S
LHL
(reversed on duplex printers so that the page numbers fall to the left on) S
LHL
(even-numbered pages.) S
PHL
LHL
(See also `ps-spool-tumble'.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-spool-tumble nil) S
LHL
(  "Specify how the page images on opposite sides of a sheet are oriented.) S
LHL
(If `ps-spool-tumble' is nil, produces output suitable for binding on the left) S
LHL
(or right.  If `ps-spool-tumble' is non-nil, produces output suitable for) S
LHL
(binding at the top or bottom.) S
PHL
LHL
(It has effect only when `ps-spool-duplex' is non-nil.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(;;; Fonts) S
PHL
LHL
(\(defcustom ps-font-info-database) S
LHL
(  '\(\(Courier) S
28 W
(; the family key) S
LHL
(     \(fonts \(normal      . "Courier"\)) S
LHL
12 W
(\(bold        . "Courier-Bold"\)) S
LHL
12 W
(\(italic      . "Courier-Oblique"\)) S
LHL
12 W
(\(bold-italic . "Courier-BoldOblique"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 10.55\)) S
LHL
(     \(space-width . 6.0\)) S
LHL
(     \(avg-char-width . 6.0\)\)) S
LHL
(    \(Helvetica) S
26 W
(; the family key) S
LHL
(     \(fonts \(normal      . "Helvetica"\)) S
LHL
12 W
(\(bold        . "Helvetica-Bold"\)) S
LHL
12 W
(\(italic      . "Helvetica-Oblique"\)) S
LHL
12 W
(\(bold-italic . "Helvetica-BoldOblique"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 11.56\)) S
LHL
(     \(space-width . 2.78\)) S
LHL
(     \(avg-char-width . 5.09243\)\)) S
LHL
(    \(Times) S
LHL
(     \(fonts \(normal      . "Times-Roman"\)) S
LHL
12 W
(\(bold        . "Times-Bold"\)) S
LHL
12 W
(\(italic      . "Times-Italic"\)) S
LHL
12 W
(\(bold-italic . "Times-BoldItalic"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 11.0\)) S
LHL
(     \(space-width . 2.5\)) S
LHL
(     \(avg-char-width . 4.71432\)\)) S
LHL
(    \(Palatino) S
LHL
(     \(fonts \(normal      . "Palatino-Roman"\)) S
LHL
12 W
(\(bold        . "Palatino-Bold"\)) S
LHL
12 W
(\(italic      . "Palatino-Italic"\)) S
LHL
12 W
(\(bold-italic . "Palatino-BoldItalic"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 12.1\)) S
LHL
(     \(space-width . 2.5\)) S
LHL
(     \(avg-char-width . 5.08676\)\)) S
LHL
(    \(Helvetica-Narrow) S
LHL
(     \(fonts \(normal      . "Helvetica-Narrow"\)) S
LHL
12 W
(\(bold        . "Helvetica-Narrow-Bold"\)) S
LHL
12 W
(\(italic      . "Helvetica-Narrow-Oblique"\)) S
LHL
12 W
(\(bold-italic . "Helvetica-Narrow-BoldOblique"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 11.56\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 39 67
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2737 def
/PageNumber 39 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2736 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(     \(space-width . 2.2796\)) S
LHL
(     \(avg-char-width . 4.17579\)\)) S
LHL
(    \(NewCenturySchlbk) S
LHL
(     \(fonts \(normal      . "NewCenturySchlbk-Roman"\)) S
LHL
12 W
(\(bold        . "NewCenturySchlbk-Bold"\)) S
LHL
12 W
(\(italic      . "NewCenturySchlbk-Italic"\)) S
LHL
12 W
(\(bold-italic . "NewCenturySchlbk-BoldItalic"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 12.15\)) S
LHL
(     \(space-width . 2.78\)) S
LHL
(     \(avg-char-width . 5.31162\)\)) S
LHL
(    ;; got no bold for the next ones) S
LHL
(    \(AvantGarde-Book) S
LHL
(     \(fonts \(normal . "AvantGarde-Book"\)) S
LHL
12 W
(\(italic . "AvantGarde-BookOblique"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 11.77\)) S
LHL
(     \(space-width . 2.77\)) S
LHL
(     \(avg-char-width . 5.45189\)\)) S
LHL
(    \(AvantGarde-Demi) S
LHL
(     \(fonts \(normal . "AvantGarde-Demi"\)) S
LHL
12 W
(\(italic . "AvantGarde-DemiOblique"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 12.72\)) S
LHL
(     \(space-width . 2.8\)) S
LHL
(     \(avg-char-width . 5.51351\)\)) S
LHL
(    \(Bookman-Demi) S
LHL
(     \(fonts \(normal . "Bookman-Demi"\)) S
LHL
12 W
(\(italic . "Bookman-DemiItalic"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 11.77\)) S
LHL
(     \(space-width . 3.4\)) S
LHL
(     \(avg-char-width . 6.05946\)\)) S
LHL
(    \(Bookman-Light) S
LHL
(     \(fonts \(normal . "Bookman-Light"\)) S
LHL
12 W
(\(italic . "Bookman-LightItalic"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 11.79\)) S
LHL
(     \(space-width . 3.2\)) S
LHL
(     \(avg-char-width . 5.67027\)\)) S
LHL
(    ;; got no bold and no italic for the next ones) S
LHL
(    \(Symbol) S
LHL
(     \(fonts \(normal . "Symbol"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 13.03\)) S
LHL
(     \(space-width . 2.5\)) S
LHL
(     \(avg-char-width . 3.24324\)\)) S
LHL
(    \(Zapf-Dingbats) S
LHL
(     \(fonts \(normal . "Zapf-Dingbats"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 9.63\)) S
LHL
(     \(space-width . 2.78\)) S
LHL
(     \(avg-char-width . 2.78\)\)) S
LHL
(    \(ZapfChancery-MediumItalic) S
LHL
(     \(fonts \(normal . "ZapfChancery-MediumItalic"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 11.45\)) S
LHL
(     \(space-width . 2.2\)) S
LHL
(     \(avg-char-width . 4.10811\)\)) S
LHL
(    ;; We keep this wrong entry name \(but with correct font name\) for) S
LHL
(    ;; backward compatibility.) S
LHL
(    \(Zapf-Chancery-MediumItalic) S
LHL
(     \(fonts \(normal . "ZapfChancery-MediumItalic"\)\)) S
LHL
(     \(size . 10.0\)) S
LHL
(     \(line-height . 11.45\)) S
LHL
(     \(space-width . 2.2\)) S
LHL
(     \(avg-char-width . 4.10811\)\)) S
LHL
(    \)) S
LHL
(  "Font info database.) S
LHL
(Each element comprises: font family \(the key\), name, bold, italic, bold-italic,) S
LHL
(reference size, line height, space width, average character width.) S
LHL
(To get the info for another specific font \(say Helvetica\), do the following:) S
EndPage
EndDSCPage
EndSheet

%%Page: 40 68
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2809 def
/PageNumber 40 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2808 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(- create a new buffer) S
LHL
(- generate the PostScript image to a file \(C-u M-x ps-print-buffer\)) S
LHL
(- open this file and delete the leading `%' \(which is the PostScript comment) S
LHL
(  character\) from the line) S
LHL
11 W
(`% 3 cm 20 cm moveto  10/Courier ReportFontInfo  showpage') S
LHL
(  to get the line) S
LHL
11 W
(`3 cm 20 cm moveto  10/Helvetica ReportFontInfo  showpage') S
LHL
(- add the values to `ps-font-info-database'.) S
LHL
(You can get all the fonts of YOUR printer using `ReportAllFontInfo'.) S
PHL
LHL
(Note also that ps-print DOESN'T download any font to your printer, instead it) S
LHL
(uses the fonts resident in your printer.") S
LHL
(  :type '\(repeat) S
LHL
10 W
(\(list :tag "Font Definition") S
LHL
16 W
(\(symbol :tag "Font Family"\)) S
LHL
16 W
(\(cons :format "%v") S
LHL
22 W
(\(const :format "" fonts\)) S
LHL
22 W
(\(repeat :tag "Faces") S
LHL
30 W
(\(cons \(choice :menu-tag "Font Weight/Slant") S
LHL
44 W
(:tag "Font Weight/Slant") S
LHL
44 W
(\(const normal\)) S
LHL
44 W
(\(const bold\)) S
LHL
44 W
(\(const italic\)) S
LHL
44 W
(\(const bold-italic\)) S
LHL
44 W
(\(symbol :tag "Face"\)\)) S
LHL
36 W
(\(string :tag "Font Name"\)\)\)\)) S
LHL
16 W
(\(cons :format "%v") S
LHL
22 W
(\(const :format "" size\)) S
LHL
22 W
(\(number :tag "Reference Size"\)\)) S
LHL
16 W
(\(cons :format "%v") S
LHL
22 W
(\(const :format "" line-height\)) S
LHL
22 W
(\(number :tag "Line Height"\)\)) S
LHL
16 W
(\(cons :format "%v") S
LHL
22 W
(\(const :format "" space-width\)) S
LHL
22 W
(\(number :tag "Space Width"\)\)) S
LHL
16 W
(\(cons :format "%v") S
LHL
22 W
(\(const :format "" avg-char-width\)) S
LHL
22 W
(\(number :tag "Average Character Width"\)\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-font\)) S
PHL
LHL
(\(defcustom ps-font-family 'Courier) S
LHL
(  "Font family name for ordinary text, when generating PostScript.") S
LHL
(  :type 'symbol) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-font\)) S
PHL
LHL
(\(defcustom ps-font-size   '\(7 . 8.5\)) S
LHL
(  "Font size, in points, for ordinary text, when generating PostScript.) S
LHL
(Either a float or a cons of floats \(LANDSCAPE-SIZE . PORTRAIT-SIZE\).") S
LHL
(  :type '\(choice :menu-tag "Ordinary Text Font Size") S
LHL
17 W
(:tag "Ordinary Text Font Size") S
LHL
17 W
(\(number :tag "Text Size"\)) S
LHL
17 W
(\(cons :tag "Landscape/Portrait") S
LHL
23 W
(\(number :tag "Landscape Text Size"\)) S
LHL
23 W
(\(number :tag "Portrait Text Size"\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-font\)) S
PHL
LHL
(\(defcustom ps-header-font-family      'Helvetica) S
LHL
(  "Font family name for text in the header, when generating PostScript.") S
LHL
(  :type 'symbol) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-font\)) S
PHL
LHL
(\(defcustom ps-header-font-size       '\(10 . 12\)) S
LHL
(  "Font size, in points, for text in the header, when generating PostScript.) S
LHL
(Either a float or a cons of floats \(LANDSCAPE-SIZE . PORTRAIT-SIZE\).") S
LHL
(  :type '\(choice :menu-tag "Header Font Size") S
LHL
17 W
(:tag "Header Font Size") S
LHL
17 W
(\(number :tag "Header Size"\)) S
LHL
17 W
(\(cons :tag "Landscape/Portrait") S
EndPage
EndDSCPage
EndSheet

%%Page: 41 69
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2881 def
/PageNumber 41 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2880 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
23 W
(\(number :tag "Landscape Header Size"\)) S
LHL
23 W
(\(number :tag "Portrait Header Size"\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-font\)) S
PHL
LHL
(\(defcustom ps-header-title-font-size '\(12 . 14\)) S
LHL
(  "Font size, in points, for the top line of text in header, in PostScript.) S
LHL
(Either a float or a cons of floats \(LANDSCAPE-SIZE . PORTRAIT-SIZE\).") S
LHL
(  :type '\(choice :menu-tag "Header Title Font Size") S
LHL
17 W
(:tag "Header Title Font Size") S
LHL
17 W
(\(number :tag "Header Title Size"\)) S
LHL
17 W
(\(cons :tag "Landscape/Portrait") S
LHL
23 W
(\(number :tag "Landscape Header Title Size"\)) S
LHL
23 W
(\(number :tag "Portrait Header Title Size"\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-font\)) S
PHL
LHL
(\(defcustom ps-footer-font-family      'Helvetica) S
LHL
(  "Font family name for text in the footer, when generating PostScript.") S
LHL
(  :type 'symbol) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-font\)) S
PHL
LHL
(\(defcustom ps-footer-font-size       '\(10 . 12\)) S
LHL
(  "Font size, in points, for text in the footer, when generating PostScript.) S
LHL
(Either a float or a cons of floats \(LANDSCAPE-SIZE . PORTRAIT-SIZE\).") S
LHL
(  :type '\(choice :menu-tag "Footer Font Size") S
LHL
17 W
(:tag "Footer Font Size") S
LHL
17 W
(\(number :tag "Footer Size"\)) S
LHL
17 W
(\(cons :tag "Landscape/Portrait") S
LHL
23 W
(\(number :tag "Landscape Footer Size"\)) S
LHL
23 W
(\(number :tag "Portrait Footer Size"\)\)\)) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-font\)) S
PHL
LHL
(\(defcustom ps-line-number-color      "black") S
LHL
(  "Specify color for line-number, when generating PostScript.") S
LHL
(  :type '\(choice :menu-tag "Line Number Color") S
LHL
17 W
(:tag "Line Number Color") S
LHL
17 W
(\(number :tag "Gray Scale" :value 0\)) S
LHL
17 W
(\(string :tag "Color Name" :value "black"\)) S
LHL
17 W
(\(list :tag "RGB Color" :value \(0 0 0\)) S
LHL
23 W
(\(number :tag "Red"\)) S
LHL
23 W
(\(number :tag "Green"\)) S
LHL
23 W
(\(number :tag "Blue"\)\)\)) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-font) S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-line-number-font      "Times-Italic") S
LHL
(  "Font for line-number, when generating PostScript.") S
LHL
(  :type 'string) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-font) S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-line-number-font-size 6) S
LHL
(  "Font size, in points, for line number, when generating PostScript.) S
LHL
(Either a float or a cons of floats \(LANDSCAPE-SIZE . PORTRAIT-SIZE\).") S
LHL
(  :type '\(choice :menu-tag "Line Number Font Size") S
LHL
17 W
(:tag "Line Number Font Size") S
LHL
17 W
(\(number :tag "Font Size"\)) S
LHL
17 W
(\(cons :tag "Landscape/Portrait") S
LHL
23 W
(\(number :tag "Landscape Font Size"\)) S
LHL
23 W
(\(number :tag "Portrait Font Size"\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-font) S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(;;; Colors) S
PHL
LHL
(;; Printing color requires x-color-values.) S
EndPage
EndDSCPage
EndSheet

%%Page: 42 70
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 2953 def
/PageNumber 42 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
2952 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;; XEmacs change: Need autoload for the "Options->Printing->Color Printing") S
LHL
(;;                widget to work.) S
LHL
(;;;###autoload) S
LHL
(\(defcustom ps-print-color-p) S
LHL
(  \(or \(fboundp 'x-color-values\)) S
9 W
(; Emacs) S
LHL
(      \(fboundp 'color-instance-rgb-components\)\)) S
LHL
40 W
(; XEmacs) S
LHL
(  "Specify how buffer's text color is printed.) S
PHL
LHL
(Valid values are:) S
PHL
LHL
(   nil) S
10 W
(Do not print colors.) S
PHL
LHL
(   t) S
12 W
(Print colors.) S
PHL
LHL
(   black-white) S
2 W
(Print colors on black/white printer.) S
LHL
16 W
(See also `ps-black-white-faces'.) S
PHL
LHL
(Any other value is treated as t.") S
LHL
(  :type '\(choice :menu-tag "Print Color") S
LHL
17 W
(:tag "Print Color") S
LHL
17 W
(\(const :tag "Do NOT Print Color" nil\)) S
LHL
17 W
(\(const :tag "Print Always Color" t\)) S
LHL
17 W
(\(const :tag "Print Black/White Color" black-white\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-color\)) S
PHL
LHL
(\(defcustom ps-default-fg nil) S
LHL
(  "RGB values of the default foreground color.) S
PHL
LHL
(The `ps-default-fg' variable contains the default foreground color used by) S
LHL
(ps-print, that is, if there is a face in a text that doesn't have a foreground) S
LHL
(color, the `ps-default-fg' color should be used.) S
PHL
LHL
(Valid values are:) S
PHL
LHL
(   t) S
12 W
(The foreground color of Emacs session will be used.) S
PHL
LHL
(   frame-parameter) S
6 W
(The foreground-color frame parameter will be used.) S
PHL
LHL
(   NUMBER) S
7 W
(It's a real value between 0.0 \(black\) and 1.0 \(white\) that) S
LHL
16 W
(indicate the gray color.) S
PHL
LHL
(   COLOR-NAME) S
3 W
(It's a string which contains the color name.  For example:) S
LHL
16 W
(\\"yellow\\".) S
PHL
LHL
(   LIST) S
9 W
(It's a list of RGB values, that is a list of three real values) S
LHL
16 W
(of the form:) S
PHL
LHL
18 W
(\(RED GREEN BLUE\)) S
PHL
LHL
16 W
(Where RED, GREEN and BLUE are reals between 0.0 \(no color\) and) S
LHL
16 W
(1.0 \(full color\).) S
PHL
LHL
(Any other value is ignored and black color will be used.) S
PHL
LHL
(This variable is used only when `ps-print-color-p' \(which see\) is neither nil) S
LHL
(nor black-white.") S
LHL
(  :type '\(choice :menu-tag "Default Foreground Gray/Color") S
LHL
17 W
(\(const :tag "Session Foreground" t\)) S
LHL
17 W
(\(const :tag "Frame Foreground" frame-parameter\)) S
LHL
17 W
(\(number :tag "Gray Scale" :value 0.0\)) S
LHL
17 W
(\(string :tag "Color Name" :value "black"\)) S
LHL
17 W
(\(list :tag "RGB Color" :value \(0.0 0.0 0.0\)) S
LHL
23 W
(\(number :tag "Red"\)) S
LHL
23 W
(\(number :tag "Green"\)) S
LHL
23 W
(\(number :tag "Blue"\)\)) S
LHL
17 W
(\(other :tag "Default Foreground Gray/Color" nil\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-color\)) S
PHL
LHL
(\(defcustom ps-default-bg nil) S
EndPage
EndDSCPage
EndSheet

%%Page: 43 71
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3025 def
/PageNumber 43 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3024 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  "RGB values of the default background color.) S
PHL
LHL
(The `ps-default-bg' variable contains the default background color used by) S
LHL
(ps-print, that is, if there is a face in a text that doesn't have a background) S
LHL
(color, the `ps-default-bg' color should be used.) S
PHL
LHL
(Valid values are:) S
PHL
LHL
(   t) S
12 W
(The background color of Emacs session will be used.) S
PHL
LHL
(   frame-parameter) S
6 W
(The background-color frame parameter will be used.) S
PHL
LHL
(   NUMBER) S
7 W
(It's a real value between 0.0 \(black\) and 1.0 \(white\) that) S
LHL
16 W
(indicate the gray color.) S
PHL
LHL
(   COLOR-NAME) S
3 W
(It's a string which contains the color name.  For example:) S
LHL
16 W
(\\"yellow\\".) S
PHL
LHL
(   LIST) S
9 W
(It's a list of RGB values, that is a list of three real values) S
LHL
16 W
(of the form:) S
PHL
LHL
18 W
(\(RED GREEN BLUE\)) S
PHL
LHL
16 W
(Where RED, GREEN and BLUE are reals between 0.0 \(no color\) and) S
LHL
16 W
(1.0 \(full color\).) S
PHL
LHL
(Any other value is ignored and white color will be used.) S
PHL
LHL
(This variable is used only when `ps-print-color-p' \(which see\) is neither nil) S
LHL
(nor black-white.) S
PHL
LHL
(See also `ps-use-face-background'.") S
LHL
(  :type '\(choice :menu-tag "Default Background Gray/Color") S
LHL
17 W
(\(const :tag "Session Background" t\)) S
LHL
17 W
(\(const :tag "Frame Background" frame-parameter\)) S
LHL
17 W
(\(number :tag "Gray Scale" :value 1.0\)) S
LHL
17 W
(\(string :tag "Color Name" :value "white"\)) S
LHL
17 W
(\(list :tag "RGB Color" :value \(1.0 1.0 1.0\)) S
LHL
23 W
(\(number :tag "Red"\)) S
LHL
23 W
(\(number :tag "Green"\)) S
LHL
23 W
(\(number :tag "Blue"\)\)) S
LHL
17 W
(\(other :tag "Default Background Gray/Color" nil\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-color\)) S
PHL
LHL
(\(defcustom ps-fg-list nil) S
LHL
(  "Specify foreground color list.) S
PHL
LHL
(This list is used to chose a text foreground color which is different than the) S
LHL
(background color.  It'll be used the first foreground color in `ps-fg-list') S
LHL
(which is different from the background color.) S
PHL
LHL
(If this list is nil, the default foreground color is used.  See) S
LHL
(`ps-default-fg'.) S
PHL
LHL
(The list element valid values are:) S
PHL
LHL
(   NUMBER) S
7 W
(It's a real value between 0.0 \(black\) and 1.0 \(white\) that) S
LHL
16 W
(indicate the gray color.) S
PHL
LHL
(   COLOR-NAME) S
3 W
(It's a string which contains the color name.  For example:) S
LHL
16 W
(\\"yellow\\".) S
PHL
LHL
(   LIST) S
9 W
(It's a list of RGB values, that is a list of three real values) S
LHL
16 W
(of the form:) S
PHL
LHL
18 W
(\(RED GREEN BLUE\)) S
PHL
LHL
16 W
(Where RED, GREEN and BLUE are reals between 0.0 \(no color\) and) S
LHL
16 W
(1.0 \(full color\).) S
PHL
LHL
(Any other value is ignored and black color will be used.) S
EndPage
EndDSCPage
EndSheet

%%Page: 44 72
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3097 def
/PageNumber 44 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3096 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
LHL
(This variable is used only when `ps-fg-validate-p' \(which see\) is non-nil and) S
LHL
(when `ps-print-color-p' \(which see\) is neither nil nor black-white.") S
LHL
(  :type '\(repeat) S
LHL
10 W
(\(choice :menu-tag "Foreground Gray/Color") S
LHL
18 W
(:tag "Foreground Gray/Color") S
LHL
18 W
(\(number :tag "Gray Scale" :value 0.0\)) S
LHL
18 W
(\(string :tag "Color Name" :value "black"\)) S
LHL
18 W
(\(list :tag "RGB Color" :value \(0.0 0.0 0.0\)) S
LHL
24 W
(\(number :tag "Red"\)) S
LHL
24 W
(\(number :tag "Green"\)) S
LHL
24 W
(\(number :tag "Blue"\)\)\)\)) S
LHL
(  :version "22") S
LHL
(  :group 'ps-print-color\)) S
PHL
LHL
(\(defcustom ps-fg-validate-p t) S
LHL
(  "Non-nil means validate if foreground color is different than background.) S
PHL
LHL
(If text foreground and background colors are equals, no text will appear.) S
PHL
LHL
(See also `ps-fg-list'.") S
LHL
(  :type 'boolean) S
LHL
(  :version "22") S
LHL
(  :group 'ps-print-color\)) S
PHL
LHL
(\(defcustom ps-auto-font-detect t) S
LHL
(  "Non-nil means automatically detect bold/italic/underline face attributes.) S
LHL
(If nil, we rely solely on the lists `ps-bold-faces', `ps-italic-faces', and) S
LHL
(`ps-underlined-faces'.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-font\)) S
PHL
LHL
(\(defcustom ps-black-white-faces) S
LHL
(  '\(\(font-lock-builtin-face       "black"  nil bold       \)) S
LHL
(    \(font-lock-comment-face       "gray20" nil      italic\)) S
LHL
(    \(font-lock-constant-face      "black"  nil bold       \)) S
LHL
(    \(font-lock-function-name-face "black"  nil bold       \)) S
LHL
(    \(font-lock-keyword-face       "black"  nil bold       \)) S
LHL
(    \(font-lock-string-face        "black"  nil      italic\)) S
LHL
(    \(font-lock-type-face          "black"  nil      italic\)) S
LHL
(    \(font-lock-variable-name-face "black"  nil bold italic\)) S
LHL
(    \(font-lock-warning-face       "black"  nil bold italic\)\)) S
LHL
(  "Specify list of face attributes to print colors on black/white printers.) S
PHL
LHL
(The list elements are the same as defined on `ps-extend-face' \(which see\).) S
PHL
LHL
(This variable is used only when `ps-print-color-p' is set to `black-white'.") S
LHL
(  :version "21.1") S
LHL
(  :type '\(repeat) S
LHL
10 W
(\(list :tag "Face Specification") S
LHL
16 W
(\(face :tag "Face Symbol"\)) S
LHL
16 W
(\(choice :menu-tag "Foreground Color") S
LHL
24 W
(:tag "Foreground Color") S
LHL
24 W
(\(const :tag "Black" nil\)) S
LHL
24 W
(\(string :tag "Color Name"\)\)) S
LHL
16 W
(\(choice :menu-tag "Background Color") S
LHL
24 W
(:tag "Background Color") S
LHL
24 W
(\(const :tag "None" nil\)) S
LHL
24 W
(\(string :tag "Color Name"\)\)) S
LHL
16 W
(\(repeat :inline t) S
LHL
24 W
(\(choice :menu-tag "Attribute") S
LHL
32 W
(\(const bold\)) S
LHL
32 W
(\(const italic\)) S
LHL
32 W
(\(const underline\)) S
LHL
32 W
(\(const strikeout\)) S
LHL
32 W
(\(const overline\)) S
LHL
32 W
(\(const shadow\)) S
LHL
32 W
(\(const box\)) S
LHL
32 W
(\(const outline\)\)\)\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-face\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 45 73
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3169 def
/PageNumber 45 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3168 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
LHL
(\(defcustom ps-bold-faces) S
LHL
(  \(unless ps-print-color-p) S
LHL
(    '\(font-lock-function-name-face) S
LHL
(      font-lock-builtin-face) S
LHL
(      font-lock-variable-name-face) S
LHL
(      font-lock-keyword-face) S
LHL
(      font-lock-warning-face\)\)) S
LHL
(  "A list of the \(non-bold\) faces that should be printed in bold font.) S
LHL
(This applies to generating PostScript.") S
LHL
(  :type '\(repeat face\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-face\)) S
PHL
LHL
(\(defcustom ps-italic-faces) S
LHL
(  \(unless ps-print-color-p) S
LHL
(    '\(font-lock-variable-name-face) S
LHL
(      font-lock-type-face) S
LHL
(      font-lock-string-face) S
LHL
(      font-lock-comment-face) S
LHL
(      font-lock-warning-face\)\)) S
LHL
(  "A list of the \(non-italic\) faces that should be printed in italic font.) S
LHL
(This applies to generating PostScript.") S
LHL
(  :type '\(repeat face\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-face\)) S
PHL
LHL
(\(defcustom ps-underlined-faces) S
LHL
(  \(unless ps-print-color-p) S
LHL
(    '\(font-lock-function-name-face) S
LHL
(      font-lock-constant-face) S
LHL
(      font-lock-warning-face\)\)) S
LHL
(  "A list of the \(non-underlined\) faces that should be printed underlined.) S
LHL
(This applies to generating PostScript.") S
LHL
(  :type '\(repeat face\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-face\)) S
PHL
LHL
(\(defcustom ps-use-face-background nil) S
LHL
(  "Specify if face background should be used.) S
PHL
LHL
(Valid values are:) S
PHL
LHL
(   t) S
12 W
(always use face background color.) S
LHL
(   nil) S
10 W
(never use face background color.) S
LHL
(   \(face...\)) S
4 W
(list of faces whose background color will be used.) S
PHL
LHL
(Any other value will be treated as t.") S
LHL
(  :type '\(choice :menu-tag "Use Face Background") S
LHL
17 W
(:tag "Use Face Background") S
LHL
17 W
(\(const :tag "Always Use Face Background" t\)) S
LHL
17 W
(\(const :tag "Never Use Face Background" nil\)) S
LHL
17 W
(\(repeat :menu-tag "Face Background List") S
LHL
25 W
(:tag "Face Background List") S
LHL
25 W
(face\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-face\)) S
PHL
LHL
(\(defcustom ps-left-header) S
LHL
(  \(list 'ps-get-buffer-name 'ps-header-dirpart\)) S
LHL
(  "The items to display \(each on a line\) on the left part of the page header.) S
LHL
(This applies to generating PostScript.) S
PHL
LHL
(The value should be a list of strings and symbols, each representing an entry) S
LHL
(in the PostScript array HeaderLinesLeft.) S
PHL
LHL
(Strings are inserted unchanged into the array; those representing) S
LHL
(PostScript string literals should be delimited with PostScript string) S
LHL
(delimiters `\(' and `\)'.) S
PHL
LHL
(For symbols with bound functions, the function is called and should return a) S
LHL
(string to be inserted into the array.  For symbols with bound values, the value) S
EndPage
EndDSCPage
EndSheet

%%Page: 46 74
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3241 def
/PageNumber 46 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3240 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(should be a string to be inserted into the array.  In either case, function or) S
LHL
(variable, the string value has PostScript string delimiters added to it.) S
PHL
LHL
(If symbols are unbounded, they are silently ignored.") S
LHL
(  :type '\(repeat \(choice :menu-tag "Left Header") S
LHL
25 W
(:tag "Left Header") S
LHL
25 W
(string symbol\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-right-header) S
LHL
(  \(list "/pagenumberstring load") S
LHL
8 W
('ps-time-stamp-locale-default 'ps-time-stamp-hh:mm:ss\)) S
LHL
(  "The items to display \(each on a line\) on the right part of the page header.) S
LHL
(This applies to generating PostScript.) S
PHL
LHL
(See the variable `ps-left-header' for a description of the format of this) S
LHL
(variable.) S
PHL
LHL
(There are the following basic functions implemented:) S
PHL
LHL
(   `ps-time-stamp-locale-default') S
7 W
(Return the locale's \\"preferred\\" date) S
LHL
40 W
(as, for example, \\"06/18/01\\".) S
PHL
LHL
(   `ps-time-stamp-hh:mm:ss') S
13 W
(Return time as \\"17:28:31\\".) S
PHL
LHL
(   `ps-time-stamp-mon-dd-yyyy') S
10 W
(Return date as \\"Jun 18 2001\\".) S
PHL
LHL
(   `ps-time-stamp-yyyy-mm-dd') S
11 W
(Return date as \\"2001-06-18\\" \(ISO) S
LHL
40 W
(date\).) S
PHL
LHL
(   `ps-time-stamp-iso8601') S
14 W
(Alias for `ps-time-stamp-yyyy-mm-dd'.) S
PHL
LHL
(You can also create your own time stamp function by using `format-time-string') S
LHL
(\\\(which see\).") S
LHL
(  :type '\(repeat \(choice :menu-tag "Right Header") S
LHL
25 W
(:tag "Right Header") S
LHL
25 W
(string symbol\)\)) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-left-footer) S
LHL
(  \(list 'ps-get-buffer-name 'ps-header-dirpart\)) S
LHL
(  "The items to display \(each on a line\) on the left part of the page footer.) S
LHL
(This applies to generating PostScript.) S
PHL
LHL
(The value should be a list of strings and symbols, each representing an entry) S
LHL
(in the PostScript array FooterLinesLeft.) S
PHL
LHL
(Strings are inserted unchanged into the array; those representing PostScript) S
LHL
(string literals should be delimited with PostScript string delimiters `\(' and) S
LHL
(`\)'.) S
PHL
LHL
(For symbols with bound functions, the function is called and should return a) S
LHL
(string to be inserted into the array.  For symbols with bound values, the value) S
LHL
(should be a string to be inserted into the array.  In either case, function or) S
LHL
(variable, the string value has PostScript string delimiters added to it.) S
PHL
LHL
(If symbols are unbounded, they are silently ignored.") S
LHL
(  :type '\(repeat \(choice :menu-tag "Left Footer") S
LHL
25 W
(:tag "Left Footer") S
LHL
25 W
(string symbol\)\)) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-right-footer) S
LHL
(  \(list "/pagenumberstring load") S
LHL
8 W
('ps-time-stamp-locale-default 'ps-time-stamp-hh:mm:ss\)) S
LHL
(  "The items to display \(each on a line\) on the right part of the page footer.) S
LHL
(This applies to generating PostScript.) S
PHL
LHL
(See the variable `ps-left-footer' for a description of the format of this) S
EndPage
EndDSCPage
EndSheet

%%Page: 47 75
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3313 def
/PageNumber 47 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3312 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(variable.) S
PHL
LHL
(There are the following basic functions implemented:) S
PHL
LHL
(   `ps-time-stamp-locale-default') S
7 W
(Return the locale's \\"preferred\\" date) S
LHL
40 W
(as, for example, \\"06/18/01\\".) S
PHL
LHL
(   `ps-time-stamp-hh:mm:ss') S
13 W
(Return time as \\"17:28:31\\".) S
PHL
LHL
(   `ps-time-stamp-mon-dd-yyyy') S
10 W
(Return date as \\"Jun 18 2001\\".) S
PHL
LHL
(   `ps-time-stamp-yyyy-mm-dd') S
11 W
(Return date as \\"2001-06-18\\" \(ISO) S
LHL
40 W
(date\).) S
PHL
LHL
(   `ps-time-stamp-iso8601') S
14 W
(Alias for `ps-time-stamp-yyyy-mm-dd'.) S
PHL
LHL
(You can also create your own time stamp function by using `format-time-string') S
LHL
(\\\(which see\).") S
LHL
(  :type '\(repeat \(choice :menu-tag "Right Footer") S
LHL
25 W
(:tag "Right Footer") S
LHL
25 W
(string symbol\)\)) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-razzle-dazzle t) S
LHL
(  "Non-nil means report progress while formatting buffer.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-adobe-tag "%!PS-Adobe-3.0\\n") S
LHL
(  "Contains the header line identifying the output as PostScript.) S
LHL
(By default, `ps-adobe-tag' contains the standard identifier.  Some printers) S
LHL
(require slightly different versions of this line.") S
LHL
(  :type 'string) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-build-face-reference t) S
LHL
(  "Non-nil means build the reference face lists.) S
PHL
LHL
(ps-print sets this value to nil after it builds its internal reference lists of) S
LHL
(bold and italic faces.  By setting its value back to t, you can force ps-print) S
LHL
(to rebuild the lists the next time you invoke one of the ...-with-faces) S
LHL
(commands.) S
PHL
LHL
(You should set this value back to t after you change the attributes of any) S
LHL
(face, or create new faces.  Most users shouldn't have to worry about its) S
LHL
(setting, though.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-face\)) S
PHL
LHL
(\(defcustom ps-always-build-face-reference nil) S
LHL
(  "Non-nil means always rebuild the reference face lists.) S
PHL
LHL
(If this variable is non-nil, ps-print will rebuild its internal reference lists) S
LHL
(of bold and italic faces *every* time one of the ...-with-faces commands is) S
LHL
(called.  Most users shouldn't need to set this variable.") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-face\)) S
PHL
LHL
(\(defcustom ps-banner-page-when-duplexing nil) S
LHL
(  "Non-nil means the very first page is skipped.) S
LHL
(It's like the very first character of buffer \(or region\) is ^L \(\\\\014\).") S
LHL
(  :type 'boolean) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-headers\)) S
PHL
LHL
(\(defcustom ps-postscript-code-directory) S
LHL
(  \(cond \(\(fboundp 'locate-data-directory\) ; XEmacs) S
EndPage
EndDSCPage
EndSheet

%%Page: 48 76
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3385 def
/PageNumber 48 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3384 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(         \(locate-data-directory "ps-print"\)\)) S
LHL
(        \(\(boundp 'data-directory\)       ; XEmacs and Emacs.) S
LHL
(         data-directory\)) S
LHL
(        \(t                              ; don't know what to do) S
LHL
(         \(error "`ps-postscript-code-directory' isn't set properly"\)\)\)) S
LHL
(  "Directory where it's located the PostScript prologue file used by ps-print.) S
LHL
(By default, this directory is the same as in the variable `data-directory'.") S
LHL
(  :type 'directory) S
LHL
(  :version "20") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-line-spacing 0) S
LHL
(  "Specify line spacing, in points, for ordinary text.) S
PHL
LHL
(Either a float or a cons of floats \(LANDSCAPE-SIZE . PORTRAIT-SIZE\).) S
PHL
LHL
(See also `ps-paragraph-spacing' and `ps-paragraph-regexp'.) S
PHL
LHL
(To get all lines with some spacing set both `ps-line-spacing' and) S
LHL
(`ps-paragraph-spacing' variables.") S
LHL
(  :type '\(choice :menu-tag "Line Spacing For Ordinary Text") S
LHL
17 W
(:tag "Line Spacing For Ordinary Text") S
LHL
17 W
(\(number :tag "Line Spacing"\)) S
LHL
17 W
(\(cons :tag "Landscape/Portrait") S
LHL
23 W
(\(number :tag "Landscape Line Spacing"\)) S
LHL
23 W
(\(number :tag "Portrait Line Spacing"\)\)\)) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-paragraph-spacing 0) S
LHL
(  "Specify paragraph spacing, in points, for ordinary text.) S
PHL
LHL
(Either a float or a cons of floats \(LANDSCAPE-SIZE . PORTRAIT-SIZE\).) S
PHL
LHL
(See also `ps-line-spacing' and `ps-paragraph-regexp'.) S
PHL
LHL
(To get all lines with some spacing set both `ps-line-spacing' and) S
LHL
(`ps-paragraph-spacing' variables.") S
LHL
(  :type '\(choice :menu-tag "Paragraph Spacing For Ordinary Text") S
LHL
17 W
(:tag "Paragraph Spacing For Ordinary Text") S
LHL
17 W
(\(number :tag "Paragraph Spacing"\)) S
LHL
17 W
(\(cons :tag "Landscape/Portrait") S
LHL
23 W
(\(number :tag "Landscape Paragraph Spacing"\)) S
LHL
23 W
(\(number :tag "Portrait Paragraph Spacing"\)\)\)) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-paragraph-regexp "[ \\t]*$") S
LHL
(  "Specify paragraph delimiter.) S
PHL
LHL
(It should be a regexp or nil.) S
PHL
LHL
(See also `ps-paragraph-spacing'.") S
LHL
(  :type '\(choice :menu-tag "Paragraph Delimiter") S
LHL
17 W
(\(const :tag "No Delimiter" nil\)) S
LHL
17 W
(\(regexp :tag "Delimiter Regexp"\)\)) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-begin-cut-regexp nil) S
LHL
(  "Specify regexp which is start of a region to cut out when printing.) S
PHL
LHL
(As an example, variables `ps-begin-cut-regexp' and `ps-end-cut-regexp' may be) S
LHL
(set to \\"^Local Variables:\\" and \\"^End:\\", respectively, in order to leave out) S
LHL
(some special printing instructions from the actual print.  Special printing) S
LHL
(instructions may be appended to the end of the file just like any other) S
LHL
(buffer-local variables.  See section \\"Local Variables in Files\\" on Emacs) S
LHL
(manual for more information.) S
PHL
LHL
(Variables `ps-begin-cut-regexp' and `ps-end-cut-regexp' control together what) S
LHL
(actually gets printed.  Both variables may be set to nil in which case no) S
LHL
(cutting occurs.") S
EndPage
EndDSCPage
EndSheet

%%Page: 49 77
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3457 def
/PageNumber 49 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3456 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  :type '\(choice \(const :tag "No Delimiter" nil\)) S
LHL
17 W
(\(regexp :tag "Delimiter Regexp"\)\)) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
LHL
(\(defcustom ps-end-cut-regexp nil) S
LHL
(  "Specify regexp which is end of the region to cut out when printing.) S
PHL
LHL
(See `ps-begin-cut-regexp' for more information.") S
LHL
(  :type '\(choice \(const :tag "No Delimiter" nil\)) S
LHL
17 W
(\(regexp :tag "Delimiter Regexp"\)\)) S
LHL
(  :version "21.1") S
LHL
(  :group 'ps-print-miscellany\)) S
PHL
PHL
LHL
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;) S
LHL
(;; Selected Pages) S
PHL
PHL
LHL
(\(defvar ps-last-selected-pages nil) S
LHL
(  "Latest `ps-selected-pages' value."\)) S
PHL
PHL
LHL
(\(defun ps-restore-selected-pages \(\)) S
LHL
(  "Restore latest `ps-selected-pages' value.") S
LHL
(  \(interactive\)) S
LHL
(  \(setq ps-selected-pages ps-last-selected-pages\)\)) S
PHL
PHL
LHL
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;) S
LHL
(;; Customization) S
PHL
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-print-customize \(\)) S
LHL
(  "Customization of ps-print group.") S
LHL
(  \(interactive\)) S
LHL
(  \(customize-group 'ps-print\)\)) S
PHL
PHL
LHL
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;) S
LHL
(;; User commands) S
PHL
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-print-buffer \(&optional filename\)) S
LHL
(  "Generate and print a PostScript image of the buffer.) S
PHL
LHL
(Interactively, when you use a prefix argument \(\\\\[universal-argument]\), the command prompts the) S
LHL
(user for a file name, and saves the PostScript image in that file instead of) S
LHL
(sending it to the printer.) S
PHL
LHL
(Noninteractively, the argument FILENAME is treated as follows: if it is nil,) S
LHL
(send the image to the printer.  If FILENAME is a string, save the PostScript) S
LHL
(image in a file with that name.") S
LHL
(  \(interactive \(list \(ps-print-preprint current-prefix-arg\)\)\)) S
LHL
(  \(ps-print-without-faces \(point-min\) \(point-max\) filename\)\)) S
PHL
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-print-buffer-with-faces \(&optional filename\)) S
LHL
(  "Generate and print a PostScript image of the buffer.) S
LHL
(Like `ps-print-buffer', but includes font, color, and underline information in) S
LHL
(the generated image.  This command works only if you are using a window system,) S
LHL
(so it has a way to determine color values.") S
LHL
(  \(interactive \(list \(ps-print-preprint current-prefix-arg\)\)\)) S
LHL
(  \(ps-print-with-faces \(point-min\) \(point-max\) filename\)\)) S
PHL
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-print-region \(from to &optional filename\)) S
LHL
(  "Generate and print a PostScript image of the region.) S
EndPage
EndDSCPage
EndSheet

%%Page: 50 78
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3529 def
/PageNumber 50 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3528 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(Like `ps-print-buffer', but prints just the current region.") S
LHL
(  \(interactive \(ps-print-preprint-region current-prefix-arg\)\)) S
LHL
(  \(ps-print-without-faces from to filename t\)\)) S
PHL
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-print-region-with-faces \(from to &optional filename\)) S
LHL
(  "Generate and print a PostScript image of the region.) S
LHL
(Like `ps-print-region', but includes font, color, and underline information in) S
LHL
(the generated image.  This command works only if you are using a window system,) S
LHL
(so it has a way to determine color values.") S
LHL
(  \(interactive \(ps-print-preprint-region current-prefix-arg\)\)) S
LHL
(  \(ps-print-with-faces from to filename t\)\)) S
PHL
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-spool-buffer \(\)) S
LHL
(  "Generate and spool a PostScript image of the buffer.) S
LHL
(Like `ps-print-buffer' except that the PostScript image is saved in a local) S
LHL
(buffer to be sent to the printer later.) S
PHL
LHL
(Use the command `ps-despool' to send the spooled images to the printer.") S
LHL
(  \(interactive\)) S
LHL
(  \(ps-spool-without-faces \(point-min\) \(point-max\)\)\)) S
PHL
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-spool-buffer-with-faces \(\)) S
LHL
(  "Generate and spool a PostScript image of the buffer.) S
LHL
(Like the command `ps-spool-buffer', but includes font, color, and underline) S
LHL
(information in the generated image.  This command works only if you are using) S
LHL
(a window system, so it has a way to determine color values.) S
PHL
LHL
(Use the command `ps-despool' to send the spooled images to the printer.") S
LHL
(  \(interactive\)) S
LHL
(  \(ps-spool-with-faces \(point-min\) \(point-max\)\)\)) S
PHL
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-spool-region \(from to\)) S
LHL
(  "Generate a PostScript image of the region and spool locally.) S
LHL
(Like `ps-spool-buffer', but spools just the current region.) S
PHL
LHL
(Use the command `ps-despool' to send the spooled images to the printer.") S
LHL
(  \(interactive "r"\)) S
LHL
(  \(ps-spool-without-faces from to t\)\)) S
PHL
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-spool-region-with-faces \(from to\)) S
LHL
(  "Generate a PostScript image of the region and spool locally.) S
LHL
(Like `ps-spool-region', but includes font, color, and underline information in) S
LHL
(the generated image.  This command works only if you are using a window system,) S
LHL
(so it has a way to determine color values.) S
PHL
LHL
(Use the command `ps-despool' to send the spooled images to the printer.") S
LHL
(  \(interactive "r"\)) S
LHL
(  \(ps-spool-with-faces from to t\)\)) S
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-despool \(&optional filename\)) S
LHL
(  "Send the spooled PostScript to the printer.) S
PHL
LHL
(Interactively, when you use a prefix argument \(\\\\[universal-argument]\), the command prompts the) S
LHL
(user for a file name, and saves the spooled PostScript image in that file) S
LHL
(instead of sending it to the printer.) S
PHL
LHL
(Noninteractively, the argument FILENAME is treated as follows: if it is nil,) S
LHL
(send the image to the printer.  If FILENAME is a string, save the PostScript) S
LHL
(image in a file with that name.") S
LHL
(  \(interactive \(list \(ps-print-preprint current-prefix-arg\)\)\)) S
LHL
(  \(ps-do-despool filename\)\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 51 79
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3601 def
/PageNumber 51 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3600 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
LHL
(;;;###autoload) S
LHL
(\(defun ps-line-lengths \(\)) S
LHL
(  "Display the correspondence between a line length and a font size.) S
LHL
(Done using the current ps-print setup.) S
LHL
(Try: pr -t file | awk \\\\='{printf \\"%3d %s\\n\\", length\($0\), $0}\\\\=' | sort -r | head") S
LHL
(  \(interactive\)) S
LHL
(  \(ps-line-lengths-internal\)\)) S
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-nb-pages-buffer \(nb-lines\)) S
LHL
(  "Display number of pages to print this buffer, for various font heights.) S
LHL
(The table depends on the current ps-print setup.") S
LHL
(  \(interactive \(ps-count-lines-preprint \(point-min\) \(point-max\)\)\)) S
LHL
(  \(ps-nb-pages nb-lines\)\)) S
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-nb-pages-region \(nb-lines\)) S
LHL
(  "Display number of pages to print the region, for various font heights.) S
LHL
(The table depends on the current ps-print setup.") S
LHL
(  \(interactive \(ps-count-lines-preprint \(mark\) \(point\)\)\)) S
LHL
(  \(ps-nb-pages nb-lines\)\)) S
PHL
LHL
(\(defvar ps-prefix-quote nil) S
LHL
(  "Used for `ps-print-quote' \(which see\)."\)) S
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-setup \(\)) S
LHL
(  "Return the current PostScript-generation setup.") S
LHL
(  \(let \(ps-prefix-quote\)) S
LHL
(    \(mapconcat) S
LHL
(     #'ps-print-quote) S
LHL
(     \(list) S
LHL
(      \(concat "\\n;;; \(" \(if \(featurep 'xemacs\) "XEmacs" "Emacs"\)) S
LHL
14 W
("\) ps-print version " ps-print-version "\\n"\)) S
LHL
(      ";; internal vars") S
LHL
(      \(ps-comment-string "emacs-version     " emacs-version\)) S
LHL
(      \(ps-comment-string "lpr-windows-system" lpr-windows-system\)) S
LHL
(      nil) S
LHL
(      '\(25 . ps-print-color-p\)) S
LHL
(      '\(25 . ps-lpr-command\)) S
LHL
(      '\(25 . ps-lpr-switches\)) S
LHL
(      '\(25 . ps-printer-name\)) S
LHL
(      '\(25 . ps-printer-name-option\)) S
LHL
(      '\(25 . ps-print-region-function\)) S
LHL
(      '\(25 . ps-manual-feed\)) S
LHL
(      '\(25 . ps-end-with-control-d\)) S
LHL
(      nil) S
LHL
(      '\(23 . ps-paper-type\)) S
LHL
(      '\(23 . ps-warn-paper-type\)) S
LHL
(      '\(23 . ps-landscape-mode\)) S
LHL
(      '\(23 . ps-print-upside-down\)) S
LHL
(      '\(23 . ps-number-of-columns\)) S
LHL
(      nil) S
LHL
(      '\(23 . ps-zebra-stripes\)) S
LHL
(      '\(23 . ps-zebra-stripe-height\)) S
LHL
(      '\(23 . ps-zebra-stripe-follow\)) S
LHL
(      '\(23 . ps-zebra-color\)) S
LHL
(      '\(23 . ps-line-number\)) S
LHL
(      '\(23 . ps-line-number-step\)) S
LHL
(      '\(23 . ps-line-number-start\)) S
LHL
(      nil) S
LHL
(      '\(17 . ps-razzle-dazzle\)) S
LHL
(      '\(17 . ps-default-bg\)) S
LHL
(      '\(17 . ps-default-fg\)) S
LHL
(      '\(17 . ps-fg-validate-p\)) S
LHL
(      '\(17 . ps-fg-list\)) S
LHL
(      nil) S
LHL
(      '\(23 . ps-use-face-background\)) S
LHL
(      nil) S
LHL
(      '\(28 . ps-print-control-characters\)) S
LHL
(      nil) S
EndPage
EndDSCPage
EndSheet

%%Page: 52 80
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3673 def
/PageNumber 52 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3672 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(      '\(26 . ps-print-background-image\)) S
LHL
(      nil) S
LHL
(      '\(25 . ps-print-background-text\)) S
LHL
(      nil) S
LHL
(      '\(29 . ps-error-handler-message\)) S
LHL
(      '\(29 . ps-user-defined-prologue\)) S
LHL
(      '\(29 . ps-print-prologue-header\)) S
LHL
(      '\(29 . ps-postscript-code-directory\)) S
LHL
(      '\(29 . ps-adobe-tag\)) S
LHL
(      nil) S
LHL
(      '\(30 . ps-left-margin\)) S
LHL
(      '\(30 . ps-right-margin\)) S
LHL
(      '\(30 . ps-inter-column\)) S
LHL
(      '\(30 . ps-bottom-margin\)) S
LHL
(      '\(30 . ps-top-margin\)) S
LHL
(      '\(30 . ps-print-only-one-header\)) S
LHL
(      '\(30 . ps-switch-header\)) S
LHL
(      '\(30 . ps-print-header\)) S
LHL
(      '\(30 . ps-header-lines\)) S
LHL
(      '\(30 . ps-header-offset\)) S
LHL
(      '\(30 . ps-header-line-pad\)) S
LHL
(      '\(30 . ps-print-header-frame\)) S
LHL
(      '\(30 . ps-header-frame-alist\)) S
LHL
(      '\(30 . ps-print-footer\)) S
LHL
(      '\(30 . ps-footer-lines\)) S
LHL
(      '\(30 . ps-footer-offset\)) S
LHL
(      '\(30 . ps-footer-line-pad\)) S
LHL
(      '\(30 . ps-print-footer-frame\)) S
LHL
(      '\(30 . ps-footer-frame-alist\)) S
LHL
(      '\(30 . ps-show-n-of-n\)) S
LHL
(      '\(30 . ps-spool-config\)) S
LHL
(      '\(30 . ps-spool-duplex\)) S
LHL
(      '\(30 . ps-spool-tumble\)) S
LHL
(      '\(30 . ps-banner-page-when-duplexing\)) S
LHL
(      '\(30 . ps-left-header\)) S
LHL
(      '\(30 . ps-right-header\)) S
LHL
(      '\(30 . ps-left-footer\)) S
LHL
(      '\(30 . ps-right-footer\)) S
LHL
(      nil) S
LHL
(      '\(23 . ps-n-up-printing\)) S
LHL
(      '\(23 . ps-n-up-margin\)) S
LHL
(      '\(23 . ps-n-up-border-p\)) S
LHL
(      '\(23 . ps-n-up-filling\)) S
LHL
(      nil) S
LHL
(      '\(26 . ps-multibyte-buffer\)) S
LHL
(      '\(26 . ps-font-family\)) S
LHL
(      '\(26 . ps-font-size\)) S
LHL
(      '\(26 . ps-header-font-family\)) S
LHL
(      '\(26 . ps-header-font-size\)) S
LHL
(      '\(26 . ps-header-title-font-size\)) S
LHL
(      '\(26 . ps-footer-font-family\)) S
LHL
(      '\(26 . ps-footer-font-size\)) S
LHL
(      '\(26 . ps-line-number-color\)) S
LHL
(      '\(26 . ps-line-number-font\)) S
LHL
(      '\(26 . ps-line-number-font-size\)) S
LHL
(      '\(26 . ps-line-spacing\)) S
LHL
(      '\(26 . ps-paragraph-spacing\)) S
LHL
(      '\(26 . ps-paragraph-regexp\)) S
LHL
(      '\(26 . ps-begin-cut-regexp\)) S
LHL
(      '\(26 . ps-end-cut-regexp\)) S
LHL
(      nil) S
LHL
(      '\(23 . ps-even-or-odd-pages\)) S
LHL
(      '\(23 . ps-selected-pages\)) S
LHL
(      '\(23 . ps-last-selected-pages\)) S
LHL
(      nil) S
LHL
(      '\(31 . ps-build-face-reference\)) S
LHL
(      '\(31 . ps-always-build-face-reference\)) S
LHL
(      nil) S
LHL
(      '\(20 . ps-auto-font-detect\)) S
LHL
(      '\(20 . ps-bold-faces\)) S
LHL
(      '\(20 . ps-italic-faces\)) S
LHL
(      '\(20 . ps-underlined-faces\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 53 81
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3745 def
/PageNumber 53 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3744 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(      '\(20 . ps-black-white-faces\)) S
LHL
(      "      \)\\n) S
LHL
(\\;; The following customized variables have long lists and are seldom modified:) S
LHL
(\\;;    ps-page-dimensions-database) S
LHL
(\\;;    ps-font-info-database) S
PHL
LHL
(\\;;; ps-print - end of settings\\n"\)) S
LHL
(     "\\n"\)\)\)) S
PHL
PHL
LHL
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;) S
LHL
(;; Utility functions and variables:) S
PHL
PHL
LHL
(\(defun ps-print-quote \(elt\)) S
LHL
(  "Quote ELT for printing \(used for showing settings\).) S
PHL
LHL
(If ELT is nil, return an empty string.) S
LHL
(If ELT is string, return it.) S
LHL
(Otherwise, ELT should be a cons \(LEN . SYM\) where SYM is a variable symbol and) S
LHL
(LEN is the field length where SYM name will be inserted.  The variable) S
LHL
(`ps-prefix-quote' is used to form the string, if `ps-prefix-quote' is nil, it's) S
LHL
(used \\"\(setq \\" as prefix; otherwise, it's used \\"      \\".  So, the string) S
LHL
(generated is:) S
PHL
LHL
(   * If `ps-prefix-quote' is nil:) S
LHL
(      \\"\(setq SYM-NAME   SYM-VALUE\\") S
LHL
13 W
(|<------->|) S
LHL
17 W
(LEN) S
PHL
LHL
(   * If `ps-prefix-quote' is non-nil:) S
LHL
(      \\"      SYM-NAME   SYM-VALUE\\") S
LHL
13 W
(|<------->|) S
LHL
17 W
(LEN) S
PHL
LHL
(If `ps-prefix-quote' is nil, it's set to t after generating string.") S
LHL
(  \(cond) S
LHL
(   \(\(stringp elt\) elt\)) S
LHL
(   \(\(and \(consp elt\) \(integerp \(car elt\)\)) S
LHL
9 W
(\(symbolp \(cdr elt\)\) \(boundp \(cdr elt\)\)\)) S
LHL
(    \(let* \(\(col \(car elt\)\)) S
LHL
11 W
(\(sym \(cdr elt\)\)) S
LHL
11 W
(\(key \(symbol-name sym\)\)) S
LHL
11 W
(\(len \(length key\)\)) S
LHL
11 W
(\(val \(symbol-value sym\)\)\)) S
LHL
(      \(concat \(if ps-prefix-quote) S
LHL
18 W
("      ") S
LHL
16 W
(\(setq ps-prefix-quote t\)) S
LHL
16 W
("\(setq "\)) S
LHL
14 W
(key) S
LHL
14 W
(\(if \(> col len\)) S
LHL
18 W
(\(make-string \(- col len\) ?\\s\)) S
LHL
16 W
(" "\)) S
LHL
14 W
(\(ps-value-string val\)\)\)\)) S
LHL
(   \(t ""\)) S
LHL
(   \)\)) S
PHL
PHL
LHL
(\(defun ps-value-string \(val\)) S
LHL
(  "Return a string representation of VAL.  Used by `ps-print-quote'.") S
LHL
(  \(cond \(\(null val\)) S
LHL
9 W
("nil"\)) S
LHL
8 W
(\(\(eq val t\)) S
LHL
9 W
("t"\)) S
LHL
8 W
(\(\(or \(symbolp val\) \(listp val\)\)) S
LHL
9 W
(\(format "'%S" val\)\)) S
LHL
8 W
(\(t) S
LHL
9 W
(\(format "%S" val\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-comment-string \(str value\)) S
LHL
(  "Return a comment string like \\";; STR = VALUE\\".") S
EndPage
EndDSCPage
EndSheet

%%Page: 54 82
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3817 def
/PageNumber 54 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3816 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  \(format ";; %s = %s" str \(ps-value-string value\)\)\)) S
PHL
PHL
LHL
(\(defun ps-value \(alist-sym key\)) S
LHL
(  "Return value from association list ALIST-SYM which car is `eq' to KEY.") S
LHL
(  \(cdr \(assq key \(symbol-value alist-sym\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-get \(alist-sym key\)) S
LHL
(  "Return element from association list ALIST-SYM which car is `eq' to KEY.") S
LHL
(  \(declare \(obsolete alist-get "25.1"\)\)) S
LHL
(  \(assq key \(symbol-value alist-sym\)\)\)) S
PHL
PHL
LHL
(\(defun ps-put \(alist-sym key value\)) S
LHL
(  "Store element \(KEY . VALUE\) into association list ALIST-SYM.) S
LHL
(If KEY already exists in ALIST-SYM, modify cdr to VALUE.) S
LHL
(It can be retrieved with `\(ps-get ALIST-SYM KEY\)'.") S
LHL
(  \(declare \(obsolete "use \(setf \(alist-get ..\) ..\) instead" "25.1"\)\)) S
LHL
(  \(let \(\(elt: \(assq key \(symbol-value alist-sym\)\)\)\) ; to avoid name conflict) S
LHL
(    \(if elt:) S
LHL
8 W
(\(setcdr elt: value\)) S
LHL
(      \(setq elt: \(cons key value\)\)) S
LHL
(      \(set alist-sym \(cons elt: \(symbol-value alist-sym\)\)\)\)) S
LHL
(    elt:\)\)) S
PHL
PHL
LHL
(\(defun ps-del \(alist-sym key\)) S
LHL
(  "Delete by side effect element KEY from association list ALIST-SYM.") S
LHL
(  \(declare \(obsolete "use \(setf \(alist-get k alist nil t\) nil\) instead" "25.1"\)\)) S
LHL
(  \(let \(\(a:list: \(symbol-value alist-sym\)\) ; to avoid name conflict) S
LHL
8 W
(old\)) S
LHL
(    \(while a:list:) S
LHL
(      \(if \(eq key \(car \(car a:list:\)\)\)) S
LHL
10 W
(\(progn) S
LHL
12 W
(\(if old) S
LHL
16 W
(\(setcdr old \(cdr a:list:\)\)) S
LHL
14 W
(\(set alist-sym \(cdr a:list:\)\)\)) S
LHL
12 W
(\(setq a:list: nil\)\)) S
LHL
8 W
(\(setq old     a:list:) S
LHL
14 W
(a:list: \(cdr a:list:\)\)\)\)\)) S
LHL
(  \(symbol-value alist-sym\)\)) S
PHL
PHL
LHL
(\(defun ps-time-stamp-locale-default \(\)) S
LHL
(  "Return the locale's \\"preferred\\" date as, for example, \\"06/18/01\\".") S
LHL
(  \(format-time-string "%x"\)\)) S
PHL
PHL
LHL
(\(defun ps-time-stamp-mon-dd-yyyy \(\)) S
LHL
(  "Return date as \\"Jun 18 2001\\".") S
LHL
(  \(format-time-string "%b %d %Y"\)\)) S
PHL
PHL
LHL
(\(defun ps-time-stamp-yyyy-mm-dd \(\)) S
LHL
(  "Return date as \\"2001-06-18\\" \(ISO date\).") S
LHL
(  \(format-time-string "%Y-%m-%d"\)\)) S
PHL
PHL
LHL
(;; Alias for `ps-time-stamp-yyyy-mm-dd' \(which see\).) S
LHL
(\(defalias 'ps-time-stamp-iso8601 'ps-time-stamp-yyyy-mm-dd\)) S
PHL
PHL
LHL
(\(defun ps-time-stamp-hh:mm:ss \(\)) S
LHL
(  "Return time as \\"17:28:31\\".") S
LHL
(  \(format-time-string "%T"\)\)) S
PHL
PHL
LHL
(\(defvar ps-print-color-scale 1.0\)) S
PHL
LHL
(\(defun ps-color-scale \(color\)) S
LHL
(  ;; Scale 16-bit X-COLOR-VALUE to PostScript color value in [0, 1] interval.) S
EndPage
EndDSCPage
EndSheet

%%Page: 55 83
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3889 def
/PageNumber 55 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3888 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  \(mapcar #'\(lambda \(value\) \(/ value ps-print-color-scale\)\)) S
LHL
10 W
(\(ps-color-values color\)\)\)) S
PHL
PHL
LHL
(\(defun ps-face-underlined-p \(face\)) S
LHL
(  \(or \(face-underline-p face\)) S
LHL
(      \(memq face ps-underlined-faces\)\)\)) S
PHL
PHL
LHL
(\(defun ps-prologue-file \(filenumber\)) S
LHL
(  "If prologue FILENUMBER exists and is readable, return contents as string.) S
PHL
LHL
(Note: No major/minor-mode is activated and no local variables are evaluated for) S
LHL
(      FILENUMBER, but proper EOL-conversion and character interpretation is) S
LHL
(      done!") S
LHL
(  \(let \(\(filename \(convert-standard-filename) S
LHL
19 W
(\(expand-file-name \(format "ps-prin%d.ps" filenumber\)) S
LHL
37 W
(ps-postscript-code-directory\)\)\)\)) S
LHL
(    \(if \(and \(file-exists-p filename\)) S
LHL
13 W
(\(file-readable-p filename\)\)) S
LHL
8 W
(\(with-temp-buffer) S
LHL
10 W
(\(insert-file-contents filename\)) S
LHL
10 W
(\(buffer-string\)\)) S
LHL
(      \(error "ps-print PostScript prologue `%s' file was not found") S
LHL
13 W
(filename\)\)\)\)) S
PHL
PHL
LHL
(\(defvar ps-mark-code-directory nil\)) S
PHL
LHL
(\(defvar ps-print-prologue-0 "") S
LHL
(  "ps-print PostScript error handler."\)) S
PHL
LHL
(\(defvar ps-print-prologue-1 "") S
LHL
(  "ps-print PostScript prologue."\)) S
PHL
LHL
(;; Start Editing Here:) S
PHL
LHL
(\(defvar ps-source-buffer nil\)) S
LHL
(\(defvar ps-spool-buffer-name "*PostScript*"\)) S
LHL
(\(defvar ps-spool-buffer nil\)) S
PHL
LHL
(\(defvar ps-output-head nil\)) S
LHL
(\(defvar ps-output-tail nil\)) S
PHL
LHL
(\(defvar ps-page-postscript 0\)) S
11 W
(; page number) S
LHL
(\(defvar ps-page-order 0\)) S
16 W
(; PostScript page counter) S
LHL
(\(defvar ps-page-sheet 0\)) S
16 W
(; sheet counter) S
LHL
(\(defvar ps-page-column 0\)) S
15 W
(; column counter) S
LHL
(\(defvar ps-page-printed 0\)) S
14 W
(; total pages printed) S
LHL
(\(defvar ps-page-n-up 0\)) S
17 W
(; n-up counter) S
LHL
(\(defvar ps-lines-printed 0\)) S
13 W
(; total lines printed) S
LHL
(\(defvar ps-showline-count 1\)) S
12 W
(; line number counter) S
LHL
(\(defvar ps-first-page nil\)) S
LHL
(\(defvar ps-last-page nil\)) S
LHL
(\(defvar ps-print-page-p t\)) S
PHL
LHL
(\(defvar ps-control-or-escape-regexp nil\)) S
LHL
(\(defvar ps-n-up-on nil\)) S
PHL
LHL
(\(defvar ps-background-pages nil\)) S
LHL
(\(defvar ps-background-all-pages nil\)) S
LHL
(\(defvar ps-background-text-count 0\)) S
LHL
(\(defvar ps-background-image-count 0\)) S
PHL
LHL
(\(defvar ps-current-font 0\)) S
LHL
(\(defvar ps-default-foreground nil\)) S
LHL
(\(defvar ps-default-background nil\)) S
LHL
(\(defvar ps-default-color nil\)) S
LHL
(\(defvar ps-current-color nil\)) S
LHL
(\(defvar ps-current-bg nil\)) S
LHL
(\(defvar ps-foreground-list nil\)) S
PHL
EndPage
EndDSCPage
EndSheet

%%Page: 56 84
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 3961 def
/PageNumber 56 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3960 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(\(defvar ps-zebra-stripe-full-p nil\)) S
LHL
(\(defvar ps-razchunk 0\)) S
PHL
LHL
(\(defvar ps-color-p nil\)) S
PHL
LHL
(;; These values determine how much print-height to deduct when headers/footers) S
LHL
(;; are turned on.  This is a pretty clumsy way of handling it, but it'll do for) S
LHL
(;; now.) S
PHL
LHL
(\(defvar ps-header-pad 0) S
LHL
(  "Vertical and horizontal space between the header frame and the text.) S
LHL
(This is in units of points \(1/72 inch\)."\)) S
PHL
LHL
(\(defvar ps-footer-pad 0) S
LHL
(  "Vertical and horizontal space between the footer frame and the text.) S
LHL
(This is in units of points \(1/72 inch\)."\)) S
PHL
LHL
(;; Define accessors to the dimensions list.) S
PHL
LHL
(\(defmacro ps-page-dimensions-get-width  \(dims\) `\(nth 0 ,dims\)\)) S
LHL
(\(defmacro ps-page-dimensions-get-height \(dims\) `\(nth 1 ,dims\)\)) S
LHL
(\(defmacro ps-page-dimensions-get-media  \(dims\) `\(nth 2 ,dims\)\)) S
PHL
LHL
(\(defvar ps-landscape-page-height nil\)) S
PHL
LHL
(\(defvar ps-print-width nil\)) S
LHL
(\(defvar ps-print-height nil\)) S
PHL
LHL
(\(defvar ps-height-remaining nil\)) S
LHL
(\(defvar ps-width-remaining nil\)) S
PHL
LHL
(\(defvar ps-font-size-internal nil\)) S
LHL
(\(defvar ps-header-font-size-internal nil\)) S
LHL
(\(defvar ps-header-title-font-size-internal nil\)) S
LHL
(\(defvar ps-footer-font-size-internal nil\)) S
LHL
(\(defvar ps-line-spacing-internal nil\)) S
LHL
(\(defvar ps-paragraph-spacing-internal nil\)) S
PHL
LHL
EndPage
EndDSCPage
EndSheet

%%Page: 57 85
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4000 def
/PageNumber 57 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
3999 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;) S
LHL
(;; Internal Variables) S
PHL
PHL
LHL
(\(defvar ps-black-white-faces-alist nil) S
LHL
(  "Alist of symbolic faces used for black/white PostScript printers.) S
LHL
(An element of this list has the same form as `ps-print-face-extension-alist') S
LHL
(\\\(which see\).) S
PHL
LHL
(Don't change this list directly; instead,) S
LHL
(use `ps-extend-face' and `ps-extend-face-list'.) S
LHL
(See documentation for `ps-extend-face' for valid extension symbol.) S
LHL
(See also documentation for `ps-print-color-p'."\)) S
PHL
PHL
LHL
(\(defvar ps-print-face-extension-alist nil) S
LHL
(  "Alist of symbolic faces *WITH* extension features \(box, outline, etc\).) S
LHL
(An element of this list has the following form:) S
PHL
LHL
(   \(FACE . [BITS FG BG]\)) S
PHL
LHL
(   FACE is a symbol denoting a face name) S
LHL
(   BITS is a bit vector, where each bit correspond) S
LHL
(      to a feature \(bold, underline, etc\)) S
LHL
(      \(see documentation for `ps-print-face-map-alist'\)) S
LHL
(   FG foreground color \(string or nil\)) S
LHL
(   BG background color \(string or nil\)) S
PHL
LHL
(Don't change this list directly; instead,) S
LHL
(use `ps-extend-face' and `ps-extend-face-list'.) S
LHL
(See documentation for `ps-extend-face' for valid extension symbol."\)) S
PHL
PHL
LHL
(\(defvar ps-print-face-alist nil) S
LHL
(  "Alist of symbolic faces *WITHOUT* extension features \(box, outline, etc\).) S
PHL
LHL
(An element of this list has the same form as an element of) S
LHL
(`ps-print-face-extension-alist'.) S
PHL
LHL
(Don't change this list directly; this list is used by `ps-face-attributes',) S
LHL
(`ps-map-face' and `ps-build-reference-face-lists'."\)) S
PHL
PHL
LHL
(\(defconst ps-print-face-map-alist) S
LHL
(  '\(\(bold        . 1\)) S
LHL
(    \(italic      . 2\)) S
LHL
(    \(underline   . 4\)) S
LHL
(    \(strikeout   . 8\)) S
LHL
(    \(overline    . 16\)) S
LHL
(    \(shadow      . 32\)) S
LHL
(    \(box         . 64\)) S
LHL
(    \(outline     . 128\)\)) S
LHL
(  "Alist of all features and the corresponding bit mask.) S
LHL
(Each symbol correspond to one bit in a bit vector."\)) S
PHL
LHL
EndPage
EndDSCPage
EndSheet

%%Page: 58 86
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4056 def
/PageNumber 58 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4055 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;) S
LHL
(;; Remapping Faces) S
PHL
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-extend-face-list \(face-extension-list &optional merge-p alist-sym\)) S
LHL
(  "Extend face in ALIST-SYM.) S
PHL
LHL
(If optional MERGE-P is non-nil, extensions in FACE-EXTENSION-LIST are merged) S
LHL
(with face extension in ALIST-SYM; otherwise, overrides.) S
PHL
LHL
(If optional ALIST-SYM is nil, `ps-print-face-extension-alist' is used;) S
LHL
(otherwise, it should be an alist symbol.) S
PHL
LHL
(The elements in FACE-EXTENSION-LIST are like those for `ps-extend-face'.) S
PHL
LHL
(See `ps-extend-face' for documentation.") S
LHL
(  \(while face-extension-list) S
LHL
(    \(ps-extend-face \(car face-extension-list\) merge-p alist-sym\)) S
LHL
(    \(setq face-extension-list \(cdr face-extension-list\)\)\)\)) S
PHL
PHL
LHL
(;;;###autoload) S
LHL
(\(defun ps-extend-face \(face-extension &optional merge-p alist-sym\)) S
LHL
(  "Extend face in ALIST-SYM.) S
PHL
LHL
(If optional MERGE-P is non-nil, extensions in FACE-EXTENSION list are merged) S
LHL
(with face extensions in ALIST-SYM; otherwise, overrides.) S
PHL
LHL
(If optional ALIST-SYM is nil, `ps-print-face-extension-alist' is used;) S
LHL
(otherwise, it should be an alist symbol.) S
PHL
LHL
(The elements of FACE-EXTENSION list have the form:) S
PHL
LHL
(   \(FACE-NAME FOREGROUND BACKGROUND EXTENSION...\)) S
PHL
LHL
(FACE-NAME is a face name symbol.) S
PHL
LHL
(FOREGROUND and BACKGROUND may be nil or a string that denotes the) S
LHL
(foreground and background colors respectively.) S
PHL
LHL
(EXTENSION is one of the following symbols:) S
LHL
(   bold      - use bold font.) S
LHL
(   italic    - use italic font.) S
LHL
(   underline - put a line under text.) S
LHL
(   strikeout - like underline, but the line is in middle of text.) S
LHL
(   overline  - like underline, but the line is over the text.) S
LHL
(   shadow    - text will have a shadow.) S
LHL
(   box       - text will be surrounded by a box.) S
LHL
(   outline   - print characters as hollow outlines.) S
PHL
LHL
(If EXTENSION is any other symbol, it is ignored.") S
LHL
(  \(or alist-sym) S
LHL
(      \(setq alist-sym 'ps-print-face-extension-alist\)\)) S
LHL
(  \(let* \(\(background  \(nth 2 face-extension\)\)) S
LHL
9 W
(\(foreground  \(nth 1 face-extension\)\)) S
LHL
9 W
(\(face-name   \(nth 0 face-extension\)\)) S
LHL
9 W
(\(ps-face     \(cdr \(assq face-name \(symbol-value alist-sym\)\)\)\)) S
LHL
9 W
(\(face-vector \(or ps-face \(vector 0 nil nil\)\)\)) S
LHL
9 W
(\(face-bit    \(ps-extension-bit face-extension\)\)\)) S
LHL
(    ;; extend face) S
LHL
(    \(aset face-vector 0 \(if merge-p) S
LHL
28 W
(\(logior \(aref face-vector 0\) face-bit\)) S
LHL
26 W
(face-bit\)\)) S
LHL
(    \(and \(or \(not merge-p\) \(and foreground \(stringp foreground\)\)\)) S
LHL
9 W
(\(aset face-vector 1 foreground\)\)) S
LHL
(    \(and \(or \(not merge-p\) \(and background \(stringp background\)\)\)) S
LHL
9 W
(\(aset face-vector 2 background\)\)) S
LHL
(    ;; if face does not exist, insert it) S
LHL
(    \(or ps-face) S
LHL
8 W
(\(set alist-sym \(cons \(cons face-name face-vector\)) S
LHL
29 W
(\(symbol-value alist-sym\)\)\)\)\)\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 59 87
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4128 def
/PageNumber 59 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4127 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
PHL
LHL
(\(defun ps-extension-bit \(face-extension\)) S
LHL
(  \(let \(\(face-bit 0\)\)) S
LHL
(    ;; map valid symbol extension to bit vector) S
LHL
(    \(setq face-extension \(cdr \(cdr face-extension\)\)\)) S
LHL
(    \(while \(setq face-extension \(cdr face-extension\)\)) S
LHL
(      \(setq face-bit \(logior face-bit) S
LHL
29 W
(\(or \(cdr \(assq \(car face-extension\)) S
LHL
44 W
(ps-print-face-map-alist\)\)) S
LHL
33 W
(0\)\)\)\)) S
LHL
(    face-bit\)\)) S
PHL
LHL
EndPage
EndDSCPage
EndSheet

%%Page: 60 88
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4142 def
/PageNumber 60 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4141 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;) S
LHL
(;; Adapted from font-lock: \(obsolete stuff\)) S
LHL
(;; Originally face attributes were specified via `font-lock-face-attributes'.) S
LHL
(;; Users then changed the default face attributes by setting that variable.) S
LHL
(;; However, we try and be back-compatible and respect its value if set except) S
LHL
(;; for faces where M-x customize has been used to save changes for the face.) S
PHL
PHL
LHL
(\(defun ps-font-lock-face-attributes \(\)) S
LHL
(  \(and \(boundp 'font-lock-mode\) \(symbol-value 'font-lock-mode\)) S
LHL
(       \(boundp 'font-lock-face-attributes\)) S
LHL
(       \(let \(\(face-attributes \(symbol-value 'font-lock-face-attributes\)\)\)) S
LHL
9 W
(\(while face-attributes) S
LHL
11 W
(\(let* \(\(face-attribute) S
LHL
19 W
(\(car \(prog1 face-attributes) S
LHL
26 W
(\(setq face-attributes \(cdr face-attributes\)\)\)\)\)) S
LHL
18 W
(\(face \(car face-attribute\)\)\)) S
LHL
13 W
(;; Rustle up a `defface' SPEC from a) S
LHL
13 W
(;; `font-lock-face-attributes' entry.) S
LHL
13 W
(\(unless \(get face 'saved-face\)) S
LHL
15 W
(\(let \(\(foreground \(nth 1 face-attribute\)\)) S
LHL
21 W
(\(background \(nth 2 face-attribute\)\)) S
LHL
21 W
(\(bold-p \(nth 3 face-attribute\)\)) S
LHL
21 W
(\(italic-p \(nth 4 face-attribute\)\)) S
LHL
21 W
(\(underline-p \(nth 5 face-attribute\)\)) S
LHL
21 W
(face-spec\)) S
LHL
17 W
(\(when foreground) S
LHL
19 W
(\(setq face-spec \(cons ':foreground) S
LHL
41 W
(\(cons foreground face-spec\)\)\)\)) S
LHL
17 W
(\(when background) S
LHL
19 W
(\(setq face-spec \(cons ':background) S
LHL
41 W
(\(cons background face-spec\)\)\)\)) S
LHL
17 W
(\(when bold-p) S
LHL
19 W
(\(setq face-spec \(append '\(:weight bold\) face-spec\)\)\)) S
LHL
17 W
(\(when italic-p) S
LHL
19 W
(\(setq face-spec \(append '\(:slant italic\) face-spec\)\)\)) S
LHL
17 W
(\(when underline-p) S
LHL
19 W
(\(setq face-spec \(append '\(:underline t\) face-spec\)\)\)) S
LHL
17 W
(\(custom-declare-face face \(list \(list t face-spec\)\) nil\)) S
LHL
17 W
(\)\)\)\)\)\)\)) S
PHL
LHL
EndPage
EndDSCPage
EndSheet

%%Page: 61 89
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4184 def
/PageNumber 61 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4183 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;) S
LHL
(;; Internal functions and variables) S
PHL
PHL
LHL
(\(defun ps-message-log-max \(\)) S
LHL
(  \(and \(not \(string= \(buffer-name\) "*Messages*"\)\)) S
LHL
(       \(boundp 'message-log-max\)) S
LHL
(       message-log-max\)\)) S
PHL
PHL
LHL
(\(defvar ps-print-hook nil\)) S
LHL
(\(defvar ps-print-begin-sheet-hook nil\)) S
LHL
(\(defvar ps-print-begin-page-hook nil\)) S
LHL
(\(defvar ps-print-begin-column-hook nil\)) S
PHL
PHL
LHL
(\(defun ps-print-without-faces \(from to &optional filename region-p\)) S
LHL
(  \(ps-spool-without-faces from to region-p\)) S
LHL
(  \(ps-do-despool filename\)\)) S
PHL
PHL
LHL
(\(defun ps-spool-without-faces \(from to &optional region-p\)) S
LHL
(  \(let \(\(message-log-max \(ps-message-log-max\)\)\)) S
1 W
(; to print *Messages* buffer) S
LHL
(    \(run-hooks 'ps-print-hook\)) S
LHL
(    \(ps-printing-region region-p from to\)) S
LHL
(    \(ps-generate \(current-buffer\) from to 'ps-generate-postscript\)\)\)) S
PHL
PHL
LHL
(\(defun ps-print-with-faces \(from to &optional filename region-p\)) S
LHL
(  \(ps-spool-with-faces from to region-p\)) S
LHL
(  \(ps-do-despool filename\)\)) S
PHL
PHL
LHL
(\(defun ps-spool-with-faces \(from to &optional region-p\)) S
LHL
(  \(let \(\(message-log-max \(ps-message-log-max\)\)\)) S
1 W
(; to print *Messages* buffer) S
LHL
(    \(run-hooks 'ps-print-hook\)) S
LHL
(    \(ps-printing-region region-p from to\)) S
LHL
(    \(ps-generate \(current-buffer\) from to 'ps-generate-postscript-with-faces\)\)\)) S
PHL
PHL
LHL
(\(defun ps-count-lines-preprint \(from to\)) S
LHL
(  \(or \(and from to\)) S
LHL
(      \(error "The mark is not set now"\)\)) S
LHL
(  \(let \(\(message-log-max \(ps-message-log-max\)\)\)) S
1 W
(; to count lines of *Messages*) S
LHL
(    \(list \(count-lines from to\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-count-lines \(from to\)) S
LHL
(  \(+ \(count-lines from to\)) S
LHL
(     \(save-excursion) S
LHL
(       \(goto-char to\)) S
LHL
(       \(if \(= \(current-column\) 0\) 1 0\)\)\)\)) S
PHL
PHL
LHL
(\(defvar ps-printing-region nil) S
LHL
(  "Variable used to indicate the region that ps-print is printing.) S
LHL
(It is a cons, the car of which is the line number where the region begins, and) S
LHL
(its cdr is the total number of lines in the buffer.  Formatting functions can) S
LHL
(use this information to print the original line number \(and not the number of) S
LHL
(lines printed\), and to indicate in the header that the printout is of a partial) S
LHL
(file."\)) S
PHL
PHL
LHL
(\(defvar ps-printing-region-p nil) S
LHL
(  "Non-nil means ps-print is printing a region."\)) S
PHL
PHL
LHL
(\(defun ps-printing-region \(region-p from to\)) S
LHL
(  \(setq ps-printing-region-p region-p) S
LHL
8 W
(ps-printing-region) S
LHL
8 W
(\(cons \(if region-p) S
LHL
18 W
(\(ps-count-lines \(point-min\) \(min from to\)\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 62 90
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4256 def
/PageNumber 62 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4255 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
16 W
(1\)) S
LHL
14 W
(\(ps-count-lines \(point-min\) \(point-max\)\)\)\)\)) S
PHL
LHL
EndPage
EndDSCPage
EndSheet

%%Page: 63 91
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4260 def
/PageNumber 63 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4259 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;) S
LHL
(;; Internal functions) S
PHL
PHL
LHL
(\(defsubst ps-font-alist \(font-sym\)) S
LHL
(  \(get font-sym 'fonts\)\)) S
PHL
LHL
(\(defun ps-font \(font-sym font-type\)) S
LHL
(  "Font family name for text of `font-type', when generating PostScript.") S
LHL
(  \(let* \(\(font-list \(ps-font-alist font-sym\)\)) S
LHL
9 W
(\(normal-font \(cdr \(assq 'normal font-list\)\)\)\)) S
LHL
(    \(while \(and font-list \(not \(eq font-type \(car \(car font-list\)\)\)\)\)) S
LHL
(      \(setq font-list \(cdr font-list\)\)\)) S
LHL
(    \(or \(cdr \(car font-list\)\) normal-font\)\)\)) S
PHL
LHL
(\(defsubst ps-fonts \(font-sym\)) S
LHL
(  \(mapcar 'cdr \(ps-font-alist font-sym\)\)\)) S
PHL
LHL
(\(defsubst ps-font-number \(font-sym font-type\)) S
LHL
(  \(or \(ps-alist-position font-type \(ps-font-alist font-sym\)\)) S
LHL
(      0\)\)) S
PHL
LHL
(\(defsubst ps-line-height \(font-sym\)) S
LHL
(  "The height of a line, for generating PostScript.) S
LHL
(This is the value that ps-print uses to determine the height,) S
LHL
(y-dimension, of the lines of text it has printed, and thus affects the) S
LHL
(point at which page-breaks are placed.) S
LHL
(The line-height is *not* the same as the point size of the font.") S
LHL
(  \(get font-sym 'line-height\)\)) S
PHL
LHL
(\(defsubst ps-title-line-height \(font-sym\)) S
LHL
(  "The height of a `title' line, for generating PostScript.) S
LHL
(This is the value that ps-print uses to determine the height,) S
LHL
(y-dimension, of the lines of text it has printed, and thus affects the) S
LHL
(point at which page-breaks are placed.) S
LHL
(The title-line-height is *not* the same as the point size of the font.") S
LHL
(  \(get font-sym 'title-line-height\)\)) S
PHL
LHL
(\(defsubst ps-space-width \(font-sym\)) S
LHL
(  "The width of a space character, for generating PostScript.) S
LHL
(This value is used in expanding tab characters.") S
LHL
(  \(get font-sym 'space-width\)\)) S
PHL
LHL
(\(defsubst ps-avg-char-width \(font-sym\)) S
LHL
(  "The average width, in points, of a character, for generating PostScript.) S
LHL
(This is the value that ps-print uses to determine the length,) S
LHL
(x-dimension, of the text it has printed, and thus affects the point at) S
LHL
(which long lines wrap around.") S
LHL
(  \(get font-sym 'avg-char-width\)\)) S
PHL
LHL
(\(defun ps-line-lengths-internal \(\)) S
LHL
(  "Display the correspondence between a line length and a font size.) S
LHL
(Done using the current ps-print setup.) S
LHL
(Try: pr -t file | awk \\\\='{printf \\"%3d %s\\n\\", length\($0\), $0}\\\\=' | sort -r | head") S
LHL
(  \(let* \(\(ps-font-size-internal) S
LHL
10 W
(\(or ps-font-size-internal) S
LHL
14 W
(\(ps-get-font-size 'ps-font-size\)\)\)) S
LHL
9 W
(\(ps-header-font-size-internal) S
LHL
10 W
(\(or ps-header-font-size-internal) S
LHL
14 W
(\(ps-get-font-size 'ps-header-font-size\)\)\)) S
LHL
9 W
(\(ps-footer-font-size-internal) S
LHL
10 W
(\(or ps-footer-font-size-internal) S
LHL
14 W
(\(ps-get-font-size 'ps-footer-font-size\)\)\)) S
LHL
9 W
(\(ps-header-title-font-size-internal) S
LHL
10 W
(\(or ps-header-title-font-size-internal) S
LHL
14 W
(\(ps-get-font-size 'ps-header-title-font-size\)\)\)) S
LHL
9 W
(\(buf \(get-buffer-create "*Line-lengths*"\)\)) S
LHL
9 W
(\(ifs ps-font-size-internal\)) S
4 W
(; initial font size) S
LHL
9 W
(\(print-width \(progn \(ps-get-page-dimensions\)) S
LHL
29 W
(ps-print-width\)\)) S
LHL
9 W
(\(icw \(ps-avg-char-width 'ps-font-for-text\)\) ; initial character width) S
LHL
9 W
(\(ps-setup \(ps-setup\)\)) S
10 W
(; setup for the current buffer) S
EndPage
EndDSCPage
EndSheet

%%Page: 64 92
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4332 def
/PageNumber 64 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4331 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
9 W
(\(fs-min 5\)) S
21 W
(; minimum font size) S
LHL
9 W
(cw-min) S
25 W
(; minimum character width) S
LHL
9 W
(nb-cpl-max) S
21 W
(; maximum nb of characters per line) S
LHL
9 W
(\(fs-max 14\)) S
20 W
(; maximum font size) S
LHL
9 W
(cw-max) S
25 W
(; maximum character width) S
LHL
9 W
(nb-cpl-min) S
21 W
(; minimum nb of characters per line) S
LHL
9 W
(fs) S
29 W
(; current font size) S
LHL
9 W
(cw) S
29 W
(; current character width) S
LHL
9 W
(nb-cpl) S
25 W
(; current nb of characters per line) S
LHL
9 W
(\)) S
LHL
(    \(setq cw-min     \(/ \(* icw fs-min\) ifs\)) S
LHL
10 W
(nb-cpl-max \(floor \(/ print-width cw-min\)\)) S
LHL
10 W
(cw-max     \(/ \(* icw fs-max\) ifs\)) S
LHL
10 W
(nb-cpl-min \(floor \(/ print-width cw-max\)\)) S
LHL
10 W
(nb-cpl     nb-cpl-min\)) S
LHL
(    \(set-buffer buf\)) S
LHL
(    \(goto-char \(point-max\)\)) S
LHL
(    \(or \(bobp\) \(insert "\\n" \(make-string 75 ?\\;\) "\\n"\)\)) S
LHL
(    \(insert ps-setup) S
LHL
12 W
("\\nnb char per line / font size\\n"\)) S
LHL
(    \(while \(<= nb-cpl nb-cpl-max\)) S
LHL
(      \(setq cw \(/ print-width \(float nb-cpl\)\)) S
LHL
12 W
(fs \(/ \(* ifs cw\) icw\)\)) S
LHL
(      \(insert \(format "%16d   %s\\n" nb-cpl fs\)\)) S
LHL
(      \(setq nb-cpl \(1+ nb-cpl\)\)\)) S
LHL
(    \(insert "\\n"\)) S
LHL
(    \(display-buffer buf 'not-this-window\)\)\)) S
PHL
LHL
(\(defun ps-nb-pages \(nb-lines\)) S
LHL
(  "Display correspondence between font size and the number of pages.) S
LHL
(The correspondence is based on having NB-LINES lines of text,) S
LHL
(and on the current ps-print setup.") S
LHL
(  \(let* \(\(ps-font-size-internal) S
LHL
10 W
(\(or ps-font-size-internal) S
LHL
14 W
(\(ps-get-font-size 'ps-font-size\)\)\)) S
LHL
9 W
(\(ps-header-font-size-internal) S
LHL
10 W
(\(or ps-header-font-size-internal) S
LHL
14 W
(\(ps-get-font-size 'ps-header-font-size\)\)\)) S
LHL
9 W
(\(ps-footer-font-size-internal) S
LHL
10 W
(\(or ps-footer-font-size-internal) S
LHL
14 W
(\(ps-get-font-size 'ps-footer-font-size\)\)\)) S
LHL
9 W
(\(ps-header-title-font-size-internal) S
LHL
10 W
(\(or ps-header-title-font-size-internal) S
LHL
14 W
(\(ps-get-font-size 'ps-header-title-font-size\)\)\)) S
LHL
9 W
(\(ps-line-spacing-internal) S
LHL
10 W
(\(or ps-line-spacing-internal) S
LHL
14 W
(\(ps-get-size ps-line-spacing "line spacing"\)\)\)) S
LHL
9 W
(\(buf \(get-buffer-create "*Nb-Pages*"\)\)) S
LHL
9 W
(\(ils ps-line-spacing-internal\) ; initial line spacing) S
LHL
9 W
(\(ifs ps-font-size-internal\)) S
4 W
(; initial font size) S
LHL
9 W
(\(page-height \(progn \(ps-get-page-dimensions\)) S
LHL
29 W
(ps-print-height\)\)) S
LHL
9 W
(\(ilh \(ps-line-height 'ps-font-for-text\)\) ; initial line height) S
LHL
9 W
(\(ps-setup \(ps-setup\)\)) S
10 W
(; setup for the current buffer) S
LHL
9 W
(\(fs-min 4\)) S
21 W
(; minimum font size) S
LHL
9 W
(lh-min) S
25 W
(; minimum line height) S
LHL
9 W
(nb-lpp-max) S
21 W
(; maximum nb of lines per page) S
LHL
9 W
(nb-page-min) S
20 W
(; minimum nb of pages) S
LHL
9 W
(\(fs-max 14\)) S
20 W
(; maximum font size) S
LHL
9 W
(lh-max) S
25 W
(; maximum line height) S
LHL
9 W
(nb-lpp-min) S
21 W
(; minimum nb of lines per page) S
LHL
9 W
(nb-page-max) S
20 W
(; maximum nb of pages) S
LHL
9 W
(fs) S
29 W
(; current font size) S
LHL
9 W
(lh) S
29 W
(; current line height) S
LHL
9 W
(nb-lpp) S
25 W
(; current nb of lines per page) S
LHL
9 W
(nb-page) S
24 W
(; current nb of pages) S
LHL
9 W
(\)) S
LHL
(    \(setq lh-min      \(/ \(- \(* \(+ ilh ils\) fs-min\) ils\) ifs\)) S
LHL
10 W
(nb-lpp-max  \(floor \(/ page-height lh-min\)\)) S
LHL
10 W
(nb-page-min \(ceiling \(/ \(float nb-lines\) nb-lpp-max\)\)) S
LHL
10 W
(lh-max      \(/ \(- \(* \(+ ilh ils\) fs-max\) ils\) ifs\)) S
LHL
10 W
(nb-lpp-min  \(floor \(/ page-height lh-max\)\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 65 93
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4404 def
/PageNumber 65 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4403 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
10 W
(nb-page-max \(ceiling \(/ \(float nb-lines\) nb-lpp-min\)\)) S
LHL
10 W
(nb-page     nb-page-min\)) S
LHL
(    \(set-buffer buf\)) S
LHL
(    \(goto-char \(point-max\)\)) S
LHL
(    \(or \(bobp\) \(insert "\\n" \(make-string 75 ?\\;\) "\\n"\)\)) S
LHL
(    \(insert ps-setup) S
LHL
12 W
(\(format "\\nThere are %d lines.\\n\\n" nb-lines\)) S
LHL
12 W
("nb page / font size\\n"\)) S
LHL
(    \(while \(<= nb-page nb-page-max\)) S
LHL
(      \(setq nb-lpp \(ceiling \(/ nb-lines \(float nb-page\)\)\)) S
LHL
12 W
(lh     \(/ page-height nb-lpp\)) S
LHL
12 W
(fs     \(/ \(* ifs lh\) ilh\)\)) S
LHL
(      \(insert \(format "%7d   %s\\n" nb-page fs\)\)) S
LHL
(      \(setq nb-page \(1+ nb-page\)\)\)) S
LHL
(    \(insert "\\n"\)) S
LHL
(    \(display-buffer buf 'not-this-window\)\)\)) S
PHL
LHL
(;; macros used in `ps-select-font') S
LHL
(\(defmacro ps-lookup \(key\) `\(cdr \(assq ,key font-entry\)\)\)) S
LHL
(\(defmacro ps-size-scale \(key\) `\(/ \(* \(ps-lookup ,key\) font-size\) size\)\)) S
PHL
LHL
(\(defun ps-select-font \(font-family sym font-size title-font-size\)) S
LHL
(  \(let \(\(font-entry \(cdr \(assq font-family ps-font-info-database\)\)\)\)) S
LHL
(    \(or font-entry) S
LHL
8 W
(\(error "Don't have data to scale font %s.  Known fonts families are %s") S
LHL
15 W
(font-family) S
LHL
15 W
(\(mapcar 'car ps-font-info-database\)\)\)) S
LHL
(    \(let \(\(size \(ps-lookup 'size\)\)\)) S
LHL
(      \(put sym 'fonts \(ps-lookup 'fonts\)\)) S
LHL
(      \(put sym 'space-width \(ps-size-scale 'space-width\)\)) S
LHL
(      \(put sym 'avg-char-width \(ps-size-scale 'avg-char-width\)\)) S
LHL
(      \(put sym 'line-height \(ps-size-scale 'line-height\)\)) S
LHL
(      \(put sym 'title-line-height) S
LHL
11 W
(\(/ \(* \(ps-lookup 'line-height\) title-font-size\) size\)\)\)\)\)) S
PHL
LHL
(\(defun ps-get-page-dimensions \(\)) S
LHL
(  \(let \(\(page-dimensions \(cdr \(assq ps-paper-type ps-page-dimensions-database\)\)\)) S
LHL
8 W
(page-width page-height\)) S
LHL
(    \(cond) S
LHL
(     \(\(null page-dimensions\)) S
LHL
(      \(error "`ps-paper-type' must be one of:\\n%s") S
LHL
13 W
(\(mapcar 'car ps-page-dimensions-database\)\)\)) S
LHL
(     \(\(< ps-number-of-columns 1\)) S
LHL
(      \(error "The number of columns %d should be positive") S
LHL
13 W
(ps-number-of-columns\)\)\)) S
PHL
LHL
(    \(ps-select-font ps-font-family 'ps-font-for-text) S
LHL
20 W
(ps-font-size-internal ps-font-size-internal\)) S
LHL
(    \(ps-select-font ps-header-font-family 'ps-font-for-header) S
LHL
20 W
(ps-header-font-size-internal) S
LHL
20 W
(ps-header-title-font-size-internal\)) S
LHL
(    \(ps-select-font ps-footer-font-family 'ps-font-for-footer) S
LHL
20 W
(ps-footer-font-size-internal ps-footer-font-size-internal\)) S
PHL
LHL
(    \(setq page-width  \(ps-page-dimensions-get-width  page-dimensions\)) S
LHL
10 W
(page-height \(ps-page-dimensions-get-height page-dimensions\)\)) S
PHL
LHL
(    ;; Landscape mode) S
LHL
(    \(if ps-landscape-mode) S
LHL
8 W
(;; exchange width and height) S
LHL
8 W
(\(setq page-width \(prog1 page-height \(setq page-height page-width\)\)\)\)) S
PHL
LHL
(    ;; It is used to get the lower right corner \(only in landscape mode\)) S
LHL
(    \(setq ps-landscape-page-height page-height\)) S
PHL
LHL
(    ;; | lm | text | ic | text | ic | text | rm |) S
LHL
(    ;; page-width == lm  +  n * pw  +  \(n - 1\) * ic  +  rm) S
LHL
(    ;; => pw == \(page-width - lm -rm - \(n - 1\) * ic\) / n) S
LHL
(    \(setq ps-print-width \(/ \(- page-width) S
LHL
31 W
(ps-left-margin ps-right-margin) S
LHL
31 W
(\(* \(1- ps-number-of-columns\) ps-inter-column\)\)) S
LHL
28 W
(ps-number-of-columns\)\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 66 94
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4476 def
/PageNumber 66 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4475 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    \(if \(<= ps-print-width 0\)) S
LHL
8 W
(\(error "Bad horizontal layout:) S
LHL
(page-width           == %s) S
LHL
(ps-left-margin       == %s) S
LHL
(ps-right-margin      == %s) S
LHL
(ps-inter-column      == %s) S
LHL
(ps-number-of-columns == %s) S
LHL
(| lm | text | ic | text | ic | text | rm |) S
LHL
(page-width == lm  +  n * print-width  +  \(n - 1\) * ic  +  rm) S
LHL
(=> print-width == %d !") S
LHL
15 W
(page-width) S
LHL
15 W
(ps-left-margin) S
LHL
15 W
(ps-right-margin) S
LHL
15 W
(ps-inter-column) S
LHL
15 W
(ps-number-of-columns) S
LHL
15 W
(ps-print-width\)\)) S
PHL
LHL
(    \(setq ps-print-height) S
LHL
10 W
(\(- page-height ps-bottom-margin ps-top-margin\)\)) S
LHL
(    \(if \(<= ps-print-height 0\)) S
LHL
8 W
(\(error "Bad vertical layout:) S
LHL
(ps-top-margin    == %s) S
LHL
(ps-bottom-margin == %s) S
LHL
(page-height == bm + print-height + tm) S
LHL
(=> print-height == %d !") S
LHL
15 W
(ps-top-margin) S
LHL
15 W
(ps-bottom-margin) S
LHL
15 W
(ps-print-height\)\)) S
LHL
(    ;; If headers are turned on, deduct the height of the header from the print) S
LHL
(    ;; height.) S
LHL
(    \(if ps-print-header) S
LHL
8 W
(\(setq ps-header-pad   \(* ps-header-line-pad) S
LHL
33 W
(\(ps-title-line-height 'ps-font-for-header\)\)) S
LHL
14 W
(ps-print-height \(- ps-print-height) S
LHL
33 W
(ps-header-offset) S
LHL
33 W
(ps-header-pad) S
LHL
33 W
(\(ps-title-line-height 'ps-font-for-header\)) S
LHL
33 W
(\(* \(ps-line-height 'ps-font-for-header\)) S
LHL
36 W
(\(1- ps-header-lines\)\)) S
LHL
33 W
(ps-header-pad\)\)\)) S
LHL
(    \(if \(<= ps-print-height 0\)) S
LHL
8 W
(\(error "Bad vertical layout \(header\):) S
LHL
(ps-top-margin    == %s) S
LHL
(ps-bottom-margin == %s) S
LHL
(ps-header-offset == %s) S
LHL
(ps-header-pad    == %s) S
LHL
(header-height    == %s) S
LHL
(page-height == bm + print-height + tm - ho - hh) S
LHL
(=> print-height == %d !") S
LHL
15 W
(ps-top-margin) S
LHL
15 W
(ps-bottom-margin) S
LHL
15 W
(ps-header-offset) S
LHL
15 W
(ps-header-pad) S
LHL
15 W
(\(+ ps-header-pad) S
LHL
18 W
(\(ps-title-line-height 'ps-font-for-header\)) S
LHL
18 W
(\(* \(ps-line-height 'ps-font-for-header\)) S
LHL
21 W
(\(1- ps-header-lines\)\)) S
LHL
18 W
(ps-header-pad\)) S
LHL
15 W
(ps-print-height\)\)) S
LHL
(    ;; If footers are turned on, deduct the height of the footer from the print) S
LHL
(    ;; height.) S
LHL
(    \(if ps-print-footer) S
LHL
8 W
(\(setq ps-footer-pad   \(* ps-footer-line-pad) S
LHL
33 W
(\(ps-title-line-height 'ps-font-for-footer\)\)) S
LHL
14 W
(ps-print-height \(- ps-print-height) S
LHL
33 W
(ps-footer-offset) S
LHL
33 W
(ps-footer-pad) S
LHL
33 W
(\(* \(ps-line-height 'ps-font-for-footer\)) S
LHL
36 W
(\(1- ps-footer-lines\)\)) S
LHL
33 W
(ps-footer-pad\)\)\)) S
LHL
(    \(if \(<= ps-print-height 0\)) S
LHL
8 W
(\(error "Bad vertical layout \(footer\):) S
EndPage
EndDSCPage
EndSheet

%%Page: 67 95
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4548 def
/PageNumber 67 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4547 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(ps-top-margin    == %s) S
LHL
(ps-bottom-margin == %s) S
LHL
(ps-footer-offset == %s) S
LHL
(ps-footer-pad    == %s) S
LHL
(footer-height    == %s) S
LHL
(page-height == bm + print-height + tm - fo - fh) S
LHL
(=> print-height == %d !") S
LHL
15 W
(ps-top-margin) S
LHL
15 W
(ps-bottom-margin) S
LHL
15 W
(ps-footer-offset) S
LHL
15 W
(ps-footer-pad) S
LHL
15 W
(\(+ ps-footer-pad) S
LHL
18 W
(\(* \(ps-line-height 'ps-font-for-footer\)) S
LHL
21 W
(\(1- ps-footer-lines\)\)) S
LHL
18 W
(ps-footer-pad\)) S
LHL
15 W
(ps-print-height\)\)) S
LHL
(    ;; ps-zebra-stripe-follow is `full' or `full-follow') S
LHL
(    \(if ps-zebra-stripe-full-p) S
LHL
8 W
(\(let* \(\(line-height \(ps-line-height 'ps-font-for-text\)\)) S
LHL
15 W
(\(zebra \(* \(+ line-height ps-line-spacing-internal\)) S
LHL
25 W
(ps-zebra-stripe-height\)\)\)) S
LHL
10 W
(\(setq ps-print-height \(- \(* \(floor ps-print-height zebra\) zebra\)) S
LHL
35 W
(line-height\)\)) S
LHL
10 W
(\(if \(<= ps-print-height 0\)) S
LHL
14 W
(\(error "Bad vertical layout \(full zebra stripe follow\):) S
LHL
(ps-zebra-stripe-follow == %s) S
LHL
(ps-zebra-stripe-height == %s) S
LHL
(font-text-height       == %s) S
LHL
(line-spacing           == %s) S
LHL
(page-height == \(\(floor print-height \(\(th + ls\) * zh\)\) * \(\(th + ls\) * zh\)\) - th) S
LHL
(=> print-height == %d !") S
LHL
21 W
(ps-zebra-stripe-follow) S
LHL
21 W
(ps-zebra-stripe-height) S
LHL
21 W
(\(ps-line-height 'ps-font-for-text\)) S
LHL
21 W
(ps-line-spacing-internal) S
LHL
21 W
(ps-print-height\)\)\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-print-preprint-region \(prefix\)) S
LHL
(  \(or \(ps-mark-active-p\)) S
LHL
(      \(error "The mark is not set now"\)\)) S
LHL
(  \(list \(point\) \(mark\) \(ps-print-preprint prefix\)\)\)) S
PHL
PHL
LHL
(\(defun ps-print-preprint \(prefix\)) S
LHL
(  \(and prefix) S
LHL
(       \(or \(numberp prefix\)) S
LHL
11 W
(\(listp prefix\)\)) S
LHL
(       \(let* \(\(name   \(concat \(file-name-nondirectory \(or \(buffer-file-name\)) S
LHL
58 W
(\(buffer-name\)\)\)) S
LHL
30 W
(".ps"\)\)) S
LHL
14 W
(\(prompt \(format "Save PostScript to file \(default %s\): " name\)\)) S
LHL
14 W
(\(res    \(read-file-name prompt default-directory name nil\)\)\)) S
LHL
9 W
(\(while \(cond \(\(file-directory-p res\)) S
LHL
23 W
(\(ding\)) S
LHL
23 W
(\(setq prompt "It's a directory"\)\)) S
LHL
22 W
(\(\(not \(file-writable-p res\)\)) S
LHL
23 W
(\(ding\)) S
LHL
23 W
(\(setq prompt "File is unwritable"\)\)) S
LHL
22 W
(\(\(file-exists-p res\)) S
LHL
23 W
(\(setq prompt "File exists"\)) S
LHL
23 W
(\(not \(y-or-n-p \(format-message) S
LHL
39 W
("File `%s' exists; overwrite? " res\)\)\)\)) S
LHL
22 W
(\(t nil\)\)) S
LHL
11 W
(\(setq res \(read-file-name) S
LHL
22 W
(\(format "%s; save PostScript to file: " prompt\)) S
LHL
22 W
(\(file-name-directory res\) nil nil) S
LHL
22 W
(\(file-name-nondirectory res\)\)\)\)) S
LHL
9 W
(\(if \(file-directory-p res\)) S
LHL
13 W
(\(expand-file-name name \(file-name-as-directory res\)\)) S
LHL
11 W
(res\)\)\)\)) S
PHL
EndPage
EndDSCPage
EndSheet

%%Page: 68 96
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4620 def
/PageNumber 68 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4619 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(;; The following functions implement a simple list-buffering scheme so) S
LHL
(;; that ps-print doesn't have to repeatedly switch between buffers) S
LHL
(;; while spooling.  The functions `ps-output' and `ps-output-string' build) S
LHL
(;; up the lists; the function `ps-flush-output' takes the lists and) S
LHL
(;; insert its contents into the spool buffer \(*PostScript*\).) S
PHL
LHL
(\(defvar ps-string-escape-codes) S
LHL
(  \(let \(\(table \(make-vector 256 nil\)\)) S
LHL
8 W
(\(char ?\\000\)\)) S
LHL
(    ;; control characters) S
LHL
(    \(while \(<= char ?\\037\)) S
LHL
(      \(aset table char \(format "\\\\%03o" char\)\)) S
LHL
(      \(setq char \(1+ char\)\)\)) S
LHL
(    ;; printable characters) S
LHL
(    \(while \(< char ?\\177\)) S
LHL
(      \(aset table char \(format "%c" char\)\)) S
LHL
(      \(setq char \(1+ char\)\)\)) S
LHL
(    ;; DEL and 8-bit characters) S
LHL
(    \(while \(<= char ?\\377\)) S
LHL
(      \(aset table char \(format "\\\\%o" char\)\)) S
LHL
(      \(setq char \(1+ char\)\)\)) S
LHL
(    ;; Override ASCII formatting characters with named escape code:) S
LHL
(    \(aset table ?\\n "\\\\n"\)) S
14 W
(; [NL] linefeed) S
LHL
(    \(aset table ?\\r "\\\\r"\)) S
14 W
(; [CR] carriage return) S
LHL
(    \(aset table ?\\t "\\\\t"\)) S
14 W
(; [HT] horizontal tab) S
LHL
(    \(aset table ?\\b "\\\\b"\)) S
14 W
(; [BS] backspace) S
LHL
(    \(aset table ?\\f "\\\\f"\)) S
14 W
(; [NP] form feed) S
LHL
(    ;; Escape PostScript escape and string delimiter characters:) S
LHL
(    \(aset table ?\\\\ "\\\\\\\\"\)) S
LHL
(    \(aset table ?\\\( "\\\\\("\)) S
LHL
(    \(aset table ?\\\) "\\\\\)"\)) S
LHL
(    table\)) S
LHL
(  "Vector used to map characters to PostScript string escape codes."\)) S
PHL
LHL
(\(defsubst ps-output-string-prim \(string\)) S
LHL
(  \(insert "\("\)) S
26 W
(;insert start-string delimiter) S
LHL
(  \(save-excursion) S
23 W
(;insert string) S
LHL
(    \(insert \(string-as-unibyte string\)\)\)) S
LHL
(  ;; Find and quote special characters as necessary for PS) S
LHL
(  ;; This skips everything except control chars, non-ASCII chars, \(, \) and \\.) S
LHL
(  \(while \(progn \(skip-chars-forward " -'*-[]-~"\) \(not \(eobp\)\)\)) S
LHL
(    \(let \(\(special \(following-char\)\)\)) S
LHL
(      \(delete-char 1\)) S
LHL
(      \(insert) S
LHL
(       \(if \(and \(<= 0 special\) \(<= special 255\)\)) S
LHL
11 W
(\(aref ps-string-escape-codes special\)) S
LHL
9 W
(;; insert hexadecimal representation if character code is out of range) S
LHL
9 W
(\(format "\\\\%04X" special\)) S
LHL
9 W
(\)\)\)\)) S
LHL
(  \(goto-char \(point-max\)\)) S
LHL
(  \(insert "\)"\)\)) S
25 W
(;insert end-string delimiter) S
PHL
LHL
(\(defsubst ps-init-output-queue \(\)) S
LHL
(  \(setq ps-output-head \(list ""\)) S
LHL
8 W
(ps-output-tail ps-output-head\)\)) S
PHL
PHL
LHL
(\(defun ps-selected-pages \(\)) S
LHL
(  \(while \(progn) S
LHL
11 W
(\(setq ps-first-page     \(car \(car ps-selected-pages\)\)) S
LHL
17 W
(ps-last-page      \(cdr \(car ps-selected-pages\)\)) S
LHL
17 W
(ps-selected-pages \(cdr ps-selected-pages\)\)) S
LHL
11 W
(\(and ps-selected-pages) S
LHL
16 W
(\(< ps-last-page ps-page-postscript\)\)\)\)\)) S
PHL
PHL
LHL
(\(defsubst ps-print-page-p \(\)) S
LHL
(  \(setq ps-print-page-p) S
LHL
8 W
(\(and \(cond \(\(null ps-first-page\)\)) S
LHL
19 W
(\(\(<= ps-page-postscript ps-last-page\)) S
LHL
20 W
(\(<= ps-first-page ps-page-postscript\)\)) S
LHL
19 W
(\(ps-selected-pages) S
EndPage
EndDSCPage
EndSheet

%%Page: 69 97
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4692 def
/PageNumber 69 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4691 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
20 W
(\(ps-selected-pages\)) S
LHL
20 W
(\(and \(<= ps-first-page ps-page-postscript\)) S
LHL
25 W
(\(<= ps-page-postscript ps-last-page\)\)\)) S
LHL
19 W
(\(t) S
LHL
20 W
(nil\)\)) S
LHL
13 W
(\(cond \(\(eq ps-even-or-odd-pages 'even-page\)) S
LHL
20 W
(\(= \(logand ps-page-postscript 1\) 0\)\)) S
LHL
19 W
(\(\(eq ps-even-or-odd-pages 'odd-page\)) S
LHL
20 W
(\(= \(logand ps-page-postscript 1\) 1\)\)) S
LHL
19 W
(\(t\)) S
LHL
19 W
(\)\)\)\)) S
PHL
PHL
LHL
(\(defsubst ps-print-sheet-p \(\)) S
LHL
(  \(setq ps-print-page-p) S
LHL
8 W
(\(cond \(\(eq ps-even-or-odd-pages 'even-sheet\)) S
LHL
15 W
(\(= \(logand ps-page-sheet 1\) 0\)\)) S
LHL
14 W
(\(\(eq ps-even-or-odd-pages 'odd-sheet\)) S
LHL
15 W
(\(= \(logand ps-page-sheet 1\) 1\)\)) S
LHL
14 W
(\(t\)) S
LHL
14 W
(\)\)\)) S
PHL
PHL
LHL
(\(defun ps-output \(&rest args\)) S
LHL
(  \(when ps-print-page-p) S
LHL
(    \(setcdr ps-output-tail args\)) S
LHL
(    \(while \(cdr ps-output-tail\)) S
LHL
(      \(setq ps-output-tail \(cdr ps-output-tail\)\)\)\)\)) S
PHL
LHL
(\(defun ps-output-string \(string\)) S
LHL
(  \(ps-output t string\)\)) S
PHL
LHL
(;; Output strings in the list ARGS in the PostScript prologue part.) S
LHL
(\(defun ps-output-prologue \(args\)) S
LHL
(  \(ps-output 'prologue \(if \(stringp args\) \(list args\) args\)\)\)) S
PHL
LHL
(\(defun ps-flush-output \(\)) S
LHL
(  \(with-current-buffer ps-spool-buffer) S
LHL
(    \(goto-char \(point-max\)\)) S
LHL
(    \(while ps-output-head) S
LHL
(      \(let \(\(it \(car ps-output-head\)\)\)) S
LHL
8 W
(\(cond) S
LHL
9 W
(\(\(eq t it\)) S
LHL
10 W
(\(setq ps-output-head \(cdr ps-output-head\)\)) S
LHL
10 W
(\(ps-output-string-prim \(car ps-output-head\)\)\)) S
LHL
9 W
(\(\(eq 'prologue it\)) S
LHL
10 W
(\(setq ps-output-head \(cdr ps-output-head\)\)) S
LHL
10 W
(\(save-excursion) S
LHL
12 W
(\(search-backward "\\nBeginDoc"\)) S
LHL
12 W
(\(forward-char 1\)) S
LHL
12 W
(\(apply 'insert \(car ps-output-head\)\)\)\)) S
LHL
9 W
(\(t) S
LHL
10 W
(\(insert it\)\)\)\)) S
LHL
(      \(setq ps-output-head \(cdr ps-output-head\)\)\)\)) S
LHL
(  \(ps-init-output-queue\)\)) S
PHL
LHL
(\(defun ps-insert-file \(fname\)) S
LHL
(  \(ps-flush-output\)) S
LHL
(  \(with-current-buffer ps-spool-buffer) S
LHL
(    \(goto-char \(point-max\)\)) S
LHL
(    \(insert-file-contents fname\)\)\)) S
PHL
LHL
(;; These functions insert the arrays that define the contents of the headers.) S
PHL
LHL
(\(defvar ps-encode-header-string-function nil\)) S
PHL
LHL
(\(defun ps-generate-header-line \(fonttag &optional content\)) S
LHL
(  \(ps-output " [" fonttag " "\)) S
LHL
(  \(cond) S
LHL
(   ;; Literal strings should be output as is -- the string must contain its own) S
LHL
(   ;; PS string delimiters, '\(' and '\)', if necessary.) S
LHL
(   \(\(stringp content\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 70 98
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4764 def
/PageNumber 70 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4763 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    \(if \(functionp ps-encode-header-string-function\)) S
LHL
(        \(dolist \(elem \(funcall ps-encode-header-string-function) S
LHL
(                               content fonttag\)\)) S
LHL
10 W
(\(ps-output elem\)\)) S
LHL
(      \(ps-output content\)\)\)) S
PHL
LHL
(   ;; Functions are called -- they should return strings; they will be inserted) S
LHL
(   ;; as strings and the PS string delimiters added.) S
LHL
(   \(\(functionp content\)) S
LHL
(    \(if \(functionp ps-encode-header-string-function\)) S
LHL
8 W
(\(dolist \(l \(funcall ps-encode-header-string-function) S
LHL
28 W
(\(funcall content\) fonttag\)\)) S
LHL
10 W
(\(ps-output-string l\)\)) S
LHL
(      \(ps-output-string \(funcall content\)\)\)\)) S
PHL
LHL
(   ;; Variables will have their contents inserted.  They should contain) S
LHL
(   ;; strings, and will be inserted as strings.) S
LHL
(   \(\(and \(symbolp content\) \(boundp content\)\)) S
LHL
(    \(if \(fboundp ps-encode-header-string-function\)) S
LHL
8 W
(\(dolist \(l \(funcall ps-encode-header-string-function) S
LHL
(                            \(symbol-value content\) fonttag\)\)) S
LHL
10 W
(\(ps-output-string l\)\)) S
LHL
(      \(ps-output-string \(symbol-value content\)\)\)\)) S
PHL
LHL
(   ;; Anything else will get turned into an empty string.) S
LHL
(   \(t) S
LHL
(    \(ps-output-string ""\)\)\)) S
LHL
(  \(ps-output "]\\n"\)\)) S
PHL
LHL
(\(defun ps-generate-header \(name fonttag0 fonttag1 contents\)) S
LHL
(  \(ps-output "/" name "[\\n"\)) S
LHL
(  \(and contents \(> ps-header-lines 0\)) S
LHL
(       \(let \(\(count 1\)\)) S
LHL
9 W
(\(ps-generate-header-line fonttag0 \(car contents\)\)) S
LHL
9 W
(\(while \(and \(< count ps-header-lines\)) S
LHL
21 W
(\(setq contents \(cdr contents\)\)\)) S
LHL
11 W
(\(ps-generate-header-line fonttag1 \(car contents\)\)) S
LHL
11 W
(\(setq count \(1+ count\)\)\)\)\)) S
LHL
(  \(ps-output "]def\\n"\)\)) S
PHL
PHL
LHL
(\(defun ps-output-boolean \(name bool\)) S
LHL
(  \(ps-output \(format "/%s %s def\\n" name \(if bool "true" "false"\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-output-frame-properties \(name alist\)) S
LHL
(  \(ps-output "/" name " [") S
LHL
13 W
(\(ps-format-color \(cdr \(assq 'fore-color alist\)\) 0.0\)) S
LHL
13 W
(\(ps-format-color \(cdr \(assq 'back-color alist\)\) 0.9\)) S
LHL
13 W
(\(ps-float-format \(or \(cdr \(assq 'border-width alist\)\) 0.4\)\)) S
LHL
13 W
(\(ps-format-color \(cdr \(assq 'border-color alist\)\) 0.0\)) S
LHL
13 W
(\(ps-format-color \(cdr \(assq 'shadow-color alist\)\) 0.0\)) S
LHL
13 W
("]def\\n"\)\)) S
PHL
PHL
LHL
(\(defun ps-background-pages \(page-list func\)) S
LHL
(  \(if page-list) S
LHL
(      \(mapcar) S
LHL
(       #'\(lambda \(pages\)) S
LHL
11 W
(\(let \(\(start \(if \(consp pages\) \(car pages\) pages\)\)) S
LHL
17 W
(\(end   \(if \(consp pages\) \(cdr pages\) pages\)\)\)) S
LHL
13 W
(\(and \(integerp start\) \(integerp end\) \(<= start end\)) S
LHL
18 W
(\(add-to-list 'ps-background-pages \(vector start end func\)\)\)\)\)) S
LHL
(       page-list\)) S
LHL
(    \(setq ps-background-all-pages \(cons func ps-background-all-pages\)\)\)\)) S
PHL
PHL
LHL
(\(defconst ps-boundingbox-re) S
LHL
(  "^%%BoundingBox:\\) S
LHL
(\\\\s-+\\\\\([0-9.]+\\\\\)\\\\s-+\\\\\([0-9.]+\\\\\)\\\\s-+\\\\\([0-9.]+\\\\\)\\\\s-+\\\\\([0-9.]+\\\\\)"\)) S
PHL
PHL
EndPage
EndDSCPage
EndSheet

%%Page: 71 99
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4836 def
/PageNumber 71 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4835 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(\(defun ps-get-boundingbox \(\)) S
LHL
(  \(with-current-buffer ps-spool-buffer) S
LHL
(    \(save-excursion) S
LHL
(      \(if \(re-search-forward ps-boundingbox-re nil t\)) S
LHL
10 W
(\(vector \(string-to-number) S
5 W
(; lower x) S
LHL
19 W
(\(buffer-substring \(match-beginning 1\) \(match-end 1\)\)\)) S
LHL
18 W
(\(string-to-number) S
5 W
(; lower y) S
LHL
19 W
(\(buffer-substring \(match-beginning 2\) \(match-end 2\)\)\)) S
LHL
18 W
(\(string-to-number) S
5 W
(; upper x) S
LHL
19 W
(\(buffer-substring \(match-beginning 3\) \(match-end 3\)\)\)) S
LHL
18 W
(\(string-to-number) S
5 W
(; upper y) S
LHL
19 W
(\(buffer-substring \(match-beginning 4\) \(match-end 4\)\)\)\)) S
LHL
8 W
(\(vector 0 0 0 0\)\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-float-format \(value &optional default\)) S
LHL
(  \(let \(\(literal \(or value default\)\)\)) S
LHL
(    \(cond \(\(null literal\)) S
LHL
11 W
(" "\)) S
LHL
10 W
(\(\(numberp literal\)) S
LHL
12 W
(\(format ps-float-format \(* literal 1.0\)\)\) ; force float number) S
LHL
10 W
(\(t) S
LHL
11 W
(\(format "%s " literal\)\)) S
LHL
10 W
(\)\)\)) S
PHL
PHL
LHL
(\(defun ps-background-text \(\)) S
LHL
(  \(mapcar) S
LHL
(   #'\(lambda \(text\)) S
LHL
(       \(setq ps-background-text-count \(1+ ps-background-text-count\)\)) S
LHL
(       \(ps-output \(format "/ShowBackText-%d{\\n" ps-background-text-count\)\)) S
LHL
(       \(ps-output-string \(nth 0 text\)\)) S
2 W
(; text) S
LHL
(       \(ps-output) S
LHL
8 W
("\\n") S
LHL
8 W
(\(ps-float-format \(nth 4 text\) 200.0\) ; font size) S
LHL
8 W
(\(format "/%s " \(or \(nth 3 text\) "Times-Roman"\)\) ; font name) S
LHL
8 W
(\(ps-float-format \(nth 6 text\)) S
LHL
25 W
("PrintHeight PrintPageWidth atan"\) ; rotation) S
LHL
8 W
(\(ps-float-format \(nth 5 text\) 0.85\) ; gray) S
LHL
8 W
(\(ps-float-format \(nth 1 text\) "0"\) ; x position) S
LHL
8 W
(\(ps-float-format \(nth 2 text\) "0"\) ; y position) S
LHL
8 W
("\\nShowBackText}def\\n"\)) S
LHL
(       \(ps-background-pages \(nthcdr 7 text\) ; page list) S
LHL
28 W
(\(format "ShowBackText-%d\\n") S
LHL
36 W
(ps-background-text-count\)\)\)) S
LHL
(   ps-print-background-text\)\)) S
PHL
PHL
LHL
(\(defun ps-background-image \(\)) S
LHL
(  \(mapcar) S
LHL
(   #'\(lambda \(image\)) S
LHL
(       \(let \(\(image-file \(expand-file-name \(nth 0 image\)\)\)\)) S
LHL
9 W
(\(when \(file-readable-p image-file\)) S
LHL
11 W
(\(setq ps-background-image-count \(1+ ps-background-image-count\)\)) S
LHL
11 W
(\(ps-output) S
LHL
12 W
(\(format "/ShowBackImage-%d{\\n--back-- ") S
LHL
20 W
(ps-background-image-count\)) S
LHL
12 W
(\(ps-float-format \(nth 5 image\) 0.0\) ; rotation) S
LHL
12 W
(\(ps-float-format \(nth 3 image\) 1.0\) ; x scale) S
LHL
12 W
(\(ps-float-format \(nth 4 image\) 1.0\) ; y scale) S
LHL
12 W
(\(ps-float-format \(nth 1 image\) ; x position) S
LHL
29 W
("PrintPageWidth 2 div"\)) S
LHL
12 W
(\(ps-float-format \(nth 2 image\) ; y position) S
LHL
29 W
("PrintHeight 2 div BottomMargin add"\)) S
LHL
12 W
("\\nBeginBackImage\\n"\)) S
LHL
11 W
(\(ps-insert-file image-file\)) S
LHL
11 W
(;; coordinate adjustment to center image) S
LHL
11 W
(;; around x and y position) S
LHL
11 W
(\(let \(\(box \(ps-get-boundingbox\)\)\)) S
LHL
13 W
(\(with-current-buffer ps-spool-buffer) S
LHL
15 W
(\(save-excursion) S
LHL
17 W
(\(if \(re-search-backward "^--back--" nil t\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 72 100
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4908 def
/PageNumber 72 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4907 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
21 W
(\(replace-match) S
LHL
22 W
(\(format "%s %s") S
LHL
30 W
(\(ps-float-format) S
LHL
31 W
(\(- \(+ \(/ \(- \(aref box 2\) \(aref box 0\)\) 2.0\)) S
LHL
37 W
(\(aref box 0\)\)\)\)) S
LHL
30 W
(\(ps-float-format) S
LHL
31 W
(\(- \(+ \(/ \(- \(aref box 3\) \(aref box 1\)\) 2.0\)) S
LHL
37 W
(\(aref box 1\)\)\)\)\)) S
LHL
22 W
(t\)\)\)\)\)) S
LHL
11 W
(\(ps-output "\\nEndBackImage}def\\n"\)) S
LHL
11 W
(\(ps-background-pages \(nthcdr 6 image\) ; page list) S
LHL
32 W
(\(format "ShowBackImage-%d\\n") S
LHL
40 W
(ps-background-image-count\)\)\)\)\)) S
LHL
(   ps-print-background-image\)\)) S
PHL
PHL
LHL
(\(defun ps-background \(page-number\)) S
LHL
(  \(let \(has-local-background\)) S
LHL
(    \(mapc #'\(lambda \(range\)) S
LHL
14 W
(\(and \(<= \(aref range 0\) page-number\)) S
LHL
19 W
(\(<= page-number \(aref range 1\)\)) S
LHL
19 W
(\(if has-local-background) S
LHL
23 W
(\(ps-output \(aref range 2\)\)) S
LHL
21 W
(\(setq has-local-background t\)) S
LHL
21 W
(\(ps-output "/printLocalBackground{\\n") S
LHL
32 W
(\(aref range 2\)\)\)\)\)) S
LHL
10 W
(ps-background-pages\)) S
LHL
(    \(and has-local-background \(ps-output "}def\\n"\)\)\)\)) S
PHL
PHL
LHL
(;; Return a list of the distinct elements of LIST.) S
LHL
(;; Elements are compared with `equal'.) S
LHL
(\(defun ps-remove-duplicates \(list\)) S
LHL
(  \(let \(new \(tail list\)\)) S
LHL
(    \(while tail) S
LHL
(      \(or \(member \(car tail\) new\)) S
LHL
10 W
(\(setq new \(cons \(car tail\) new\)\)\)) S
LHL
(      \(setq tail \(cdr tail\)\)\)) S
LHL
(    \(nreverse new\)\)\)) S
PHL
PHL
LHL
(;; Find the first occurrence of ITEM in LIST.) S
LHL
(;; Return the index of the matching item, or nil if not found.) S
LHL
(;; Elements are compared with `eq'.) S
LHL
(\(defun ps-alist-position \(item list\)) S
LHL
(  \(let \(\(tail list\) \(index 0\) found\)) S
LHL
(    \(while tail) S
LHL
(      \(if \(setq found \(eq \(car \(car tail\)\) item\)\)) S
LHL
10 W
(\(setq tail nil\)) S
LHL
8 W
(\(setq index \(1+ index\)) S
LHL
14 W
(tail \(cdr tail\)\)\)\)) S
LHL
(    \(and found index\)\)\)) S
PHL
PHL
LHL
(\(defconst ps-n-up-database) S
LHL
(  '\(\(a4) S
LHL
(     \(1   nil 1  1  0\)) S
LHL
(     \(2   t   1  2  0\)) S
LHL
(     \(4   nil 2  2  0\)) S
LHL
(     \(6   t   2  3  1\)) S
LHL
(     \(8   t   2  4  0\)) S
LHL
(     \(9   nil 3  3  0\)) S
LHL
(     \(12  t   3  4  2\)) S
LHL
(     \(16  nil 4  4  0\)) S
LHL
(     \(18  t   3  6  0\)) S
LHL
(     \(20  nil 5  4  1\)) S
LHL
(     \(25  nil 5  5  0\)) S
LHL
(     \(30  nil 6  5  1\)) S
LHL
(     \(32  t   4  8  0\)) S
LHL
(     \(36  nil 6  6  0\)) S
LHL
(     \(42  nil 7  6  1\)) S
LHL
(     \(49  nil 7  7  0\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 73 101
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 4980 def
/PageNumber 73 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
4979 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(     \(50  t   5  10 0\)) S
LHL
(     \(56  nil 8  7  1\)) S
LHL
(     \(64  nil 8  8  0\)) S
LHL
(     \(72  nil 9  8  1\)) S
LHL
(     \(81  nil 9  9  0\)) S
LHL
(     \(90  nil 10 9  1\)) S
LHL
(     \(100 nil 10 10 0\)\)) S
LHL
(    \(a3) S
LHL
(     \(1   nil 1  1  0\)) S
LHL
(     \(2   t   1  2  0\)) S
LHL
(     \(4   nil 2  2  0\)) S
LHL
(     \(6   t   2  3  1\)) S
LHL
(     \(8   t   2  4  0\)) S
LHL
(     \(9   nil 3  3  0\)) S
LHL
(     \(12  nil 4  3  1\)) S
LHL
(     \(16  nil 4  4  0\)) S
LHL
(     \(18  t   3  6  0\)) S
LHL
(     \(20  nil 5  4  1\)) S
LHL
(     \(25  nil 5  5  0\)) S
LHL
(     \(30  nil 6  5  1\)) S
LHL
(     \(32  t   4  8  0\)) S
LHL
(     \(36  nil 6  6  0\)) S
LHL
(     \(42  nil 7  6  1\)) S
LHL
(     \(49  nil 7  7  0\)) S
LHL
(     \(50  t   5  10 0\)) S
LHL
(     \(56  nil 8  7  1\)) S
LHL
(     \(64  nil 8  8  0\)) S
LHL
(     \(72  nil 9  8  1\)) S
LHL
(     \(81  nil 9  9  0\)) S
LHL
(     \(90  nil 10 9  1\)) S
LHL
(     \(100 nil 10 10 0\)\)) S
LHL
(    \(letter) S
LHL
(     \(1   nil 1  1  0\)) S
LHL
(     \(2   t   1  2  0\)) S
18 W
(; adjusted by PostScript code) S
LHL
(     \(4   nil 2  2  0\)) S
LHL
(     \(6   t   2  3  0\)) S
LHL
(     \(9   nil 3  3  0\)) S
LHL
(     \(12  nil 4  3  1\)) S
LHL
(     \(16  nil 4  4  0\)) S
LHL
(     \(20  nil 5  4  1\)) S
LHL
(     \(25  nil 5  5  0\)) S
LHL
(     \(30  nil 6  5  1\)) S
LHL
(     \(36  nil 6  6  0\)) S
LHL
(     \(40  t   5  8  0\)) S
LHL
(     \(42  nil 7  6  1\)) S
LHL
(     \(49  nil 7  7  0\)) S
LHL
(     \(56  nil 8  7  1\)) S
LHL
(     \(64  nil 8  8  0\)) S
LHL
(     \(72  nil 9  8  1\)) S
LHL
(     \(81  nil 9  9  0\)) S
LHL
(     \(90  nil 10 9  1\)) S
LHL
(     \(100 nil 10 10 0\)\)) S
LHL
(    \(legal) S
LHL
(     \(1   nil 1  1  0\)) S
LHL
(     \(2   t   1  2  0\)) S
LHL
(     \(4   nil 2  2  0\)) S
LHL
(     \(6   nil 3  2  1\)) S
LHL
(     \(9   nil 3  3  0\)) S
LHL
(     \(10  t   2  5  0\)) S
LHL
(     \(12  nil 4  3  1\)) S
LHL
(     \(16  nil 4  4  0\)) S
LHL
(     \(20  nil 5  4  1\)) S
LHL
(     \(25  nil 5  5  0\)) S
LHL
(     \(30  nil 6  5  1\)) S
LHL
(     \(36  nil 6  6  0\)) S
LHL
(     \(42  nil 7  6  1\)) S
LHL
(     \(49  nil 7  7  0\)) S
LHL
(     \(56  nil 8  7  1\)) S
LHL
(     \(64  nil 8  8  0\)) S
LHL
(     \(70  t   5  14 0\)) S
LHL
(     \(72  nil 9  8  1\)) S
LHL
(     \(81  nil 9  9  0\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 74 102
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5052 def
/PageNumber 74 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5051 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(     \(90  nil 10 9  1\)) S
LHL
(     \(100 nil 10 10 0\)\)) S
LHL
(    \(letter-small) S
LHL
(     \(1   nil 1  1  0\)) S
LHL
(     \(2   t   1  2  0\)) S
18 W
(; adjusted by PostScript code) S
LHL
(     \(4   nil 2  2  0\)) S
LHL
(     \(6   t   2  3  0\)) S
LHL
(     \(9   nil 3  3  0\)) S
LHL
(     \(12  t   3  4  1\)) S
LHL
(     \(15  t   3  5  0\)) S
LHL
(     \(16  nil 4  4  0\)) S
LHL
(     \(20  nil 5  4  1\)) S
LHL
(     \(25  nil 5  5  0\)) S
LHL
(     \(28  t   4  7  0\)) S
LHL
(     \(30  nil 6  5  1\)) S
LHL
(     \(36  nil 6  6  0\)) S
LHL
(     \(40  t   5  8  0\)) S
LHL
(     \(42  nil 7  6  1\)) S
LHL
(     \(49  nil 7  7  0\)) S
LHL
(     \(56  nil 8  7  1\)) S
LHL
(     \(60  t   6  10 0\)) S
LHL
(     \(64  nil 8  8  0\)) S
LHL
(     \(72  ni  9  8  1\)) S
LHL
(     \(81  nil 9  9  0\)) S
LHL
(     \(84  t   7  12 0\)) S
LHL
(     \(90  nil 10 9  1\)) S
LHL
(     \(100 nil 10 10 0\)\)) S
LHL
(    \(tabloid) S
LHL
(     \(1   nil 1  1  0\)) S
LHL
(     \(2   t   1  2  0\)) S
LHL
(     \(4   nil 2  2  0\)) S
LHL
(     \(6   t   2  3  1\)) S
LHL
(     \(8   t   2  4  0\)) S
LHL
(     \(9   nil 3  3  0\)) S
LHL
(     \(12  nil 4  3  1\)) S
LHL
(     \(16  nil 4  4  0\)) S
LHL
(     \(20  nil 5  4  1\)) S
LHL
(     \(25  nil 5  5  0\)) S
LHL
(     \(30  nil 6  5  1\)) S
LHL
(     \(36  nil 6  6  0\)) S
LHL
(     \(42  nil 7  6  1\)) S
LHL
(     \(49  nil 7  7  0\)) S
LHL
(     \(56  nil 8  7  1\)) S
LHL
(     \(64  nil 8  8  0\)) S
LHL
(     \(72  nil 9  8  1\)) S
LHL
(     \(81  nil 9  9  0\)) S
LHL
(     \(84  t   6  14 0\)) S
LHL
(     \(90  nil 10 9  1\)) S
LHL
(     \(100 nil 10 10 0\)\)) S
LHL
(    ;; Ledger paper size is a special case, it is the only paper size where the) S
LHL
(    ;; normal size is landscaped, that is, the height is smaller than width.) S
LHL
(    ;; So, we use the special value `pag' in the `landscape' field.) S
LHL
(    \(ledger) S
LHL
(     \(1   nil 1  1  0\)) S
LHL
(     \(2   pag 1  2  0\)) S
LHL
(     \(4   nil 2  2  0\)) S
LHL
(     \(6   pag 2  3  1\)) S
LHL
(     \(8   pag 2  4  0\)) S
LHL
(     \(9   nil 3  3  0\)) S
LHL
(     \(12  nil 4  3  1\)) S
LHL
(     \(16  nil 4  4  0\)) S
LHL
(     \(20  nil 5  4  1\)) S
LHL
(     \(25  nil 5  5  0\)) S
LHL
(     \(30  nil 6  5  1\)) S
LHL
(     \(36  nil 6  6  0\)) S
LHL
(     \(42  nil 7  6  1\)) S
LHL
(     \(49  nil 7  7  0\)) S
LHL
(     \(56  nil 8  7  1\)) S
LHL
(     \(64  nil 8  8  0\)) S
LHL
(     \(72  nil 9  8  1\)) S
LHL
(     \(81  nil 9  9  0\)) S
LHL
(     \(84  pag 6  14 0\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 75 103
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5124 def
/PageNumber 75 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5123 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(     \(90  nil 10 9  1\)) S
LHL
(     \(100 nil 10 10 0\)\)) S
LHL
(    \(statement) S
LHL
(     \(1   nil 1  1  0\)) S
LHL
(     \(2   t   1  2  0\)) S
LHL
(     \(4   nil 2  2  0\)) S
LHL
(     \(6   nil 3  2  1\)) S
LHL
(     \(9   nil 3  3  0\)) S
LHL
(     \(10  t   2  5  0\)) S
LHL
(     \(12  nil 4  3  1\)) S
LHL
(     \(16  nil 4  4  0\)) S
LHL
(     \(20  nil 5  4  1\)) S
LHL
(     \(21  t   3  7  0\)) S
LHL
(     \(25  nil 5  5  0\)) S
LHL
(     \(30  nil 6  5  1\)) S
LHL
(     \(36  nil 6  6  0\)) S
LHL
(     \(40  t   4  10 0\)) S
LHL
(     \(42  nil 7  6  1\)) S
LHL
(     \(49  nil 7  7  0\)) S
LHL
(     \(56  nil 8  7  1\)) S
LHL
(     \(60  t   5  12 0\)) S
LHL
(     \(64  nil 8  8  0\)) S
LHL
(     \(72  nil 9  8  1\)) S
LHL
(     \(81  nil 9  9  0\)) S
LHL
(     \(90  nil 10 9  1\)) S
LHL
(     \(100 nil 10 10 0\)\)) S
LHL
(    \(executive) S
LHL
(     \(1   nil 1  1  0\)) S
LHL
(     \(2   t   1  2  0\)) S
18 W
(; adjusted by PostScript code) S
LHL
(     \(4   nil 2  2  0\)) S
LHL
(     \(6   t   2  3  0\)) S
LHL
(     \(9   nil 3  3  0\)) S
LHL
(     \(12  nil 4  3  1\)) S
LHL
(     \(16  nil 4  4  0\)) S
LHL
(     \(20  nil 5  4  1\)) S
LHL
(     \(25  nil 5  5  0\)) S
LHL
(     \(28  t   4  7  0\)) S
LHL
(     \(30  nil 6  5  1\)) S
LHL
(     \(36  nil 6  6  0\)) S
LHL
(     \(42  nil 7  6  1\)) S
LHL
(     \(45  t   5  9  0\)) S
LHL
(     \(49  nil 7  7  0\)) S
LHL
(     \(56  nil 8  7  1\)) S
LHL
(     \(60  t   6  10 0\)) S
LHL
(     \(64  nil 8  8  0\)) S
LHL
(     \(72  nil 9  8  1\)) S
LHL
(     \(81  nil 9  9  0\)) S
LHL
(     \(84  t   7  12 0\)) S
LHL
(     \(90  nil 10 9  1\)) S
LHL
(     \(100 nil 10 10 0\)\)) S
LHL
(    \(a4small) S
LHL
(     \(1   nil 1  1  0\)) S
LHL
(     \(2   t   1  2  0\)) S
LHL
(     \(4   nil 2  2  0\)) S
LHL
(     \(6   t   2  3  1\)) S
LHL
(     \(8   t   2  4  0\)) S
LHL
(     \(9   nil 3  3  0\)) S
LHL
(     \(12  nil 4  3  1\)) S
LHL
(     \(16  nil 4  4  0\)) S
LHL
(     \(18  t   3  6  0\)) S
LHL
(     \(20  nil 5  4  1\)) S
LHL
(     \(25  nil 5  5  0\)) S
LHL
(     \(30  nil 6  5  1\)) S
LHL
(     \(32  t   4  8  0\)) S
LHL
(     \(36  nil 6  6  0\)) S
LHL
(     \(42  nil 7  6  1\)) S
LHL
(     \(49  nil 7  7  0\)) S
LHL
(     \(50  t   5  10 0\)) S
LHL
(     \(56  nil 8  7  1\)) S
LHL
(     \(64  nil 8  8  0\)) S
LHL
(     \(72  nil 9  8  1\)) S
LHL
(     \(78  t   6  13 0\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 76 104
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5196 def
/PageNumber 76 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5195 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(     \(81  nil 9  9  0\)) S
LHL
(     \(90  nil 10 9  1\)) S
LHL
(     \(100 nil 10 10 0\)\)) S
LHL
(    \(b4) S
LHL
(     \(1   nil 1  1  0\)) S
LHL
(     \(2   t   1  2  0\)) S
LHL
(     \(4   nil 2  2  0\)) S
LHL
(     \(6   t   2  3  1\)) S
LHL
(     \(8   t   2  4  0\)) S
LHL
(     \(9   nil 3  3  0\)) S
LHL
(     \(12  nil 4  3  1\)) S
LHL
(     \(16  nil 4  4  0\)) S
LHL
(     \(18  t   3  6  0\)) S
LHL
(     \(20  nil 5  4  1\)) S
LHL
(     \(25  nil 5  5  0\)) S
LHL
(     \(30  nil 6  5  1\)) S
LHL
(     \(32  t   4  8  0\)) S
LHL
(     \(36  nil 6  6  0\)) S
LHL
(     \(42  nil 7  6  1\)) S
LHL
(     \(49  nil 7  7  0\)) S
LHL
(     \(50  t   5  10 0\)) S
LHL
(     \(56  nil 8  7  1\)) S
LHL
(     \(64  nil 8  8  0\)) S
LHL
(     \(72  nil 9  8  1\)) S
LHL
(     \(81  nil 9  9  0\)) S
LHL
(     \(90  nil 10 9  1\)) S
LHL
(     \(100 nil 10 10 0\)\)) S
LHL
(    \(b5) S
LHL
(     \(1   nil 1  1  0\)) S
LHL
(     \(2   t   1  2  0\)) S
LHL
(     \(4   nil 2  2  0\)) S
LHL
(     \(6   t   2  3  1\)) S
LHL
(     \(8   t   2  4  0\)) S
LHL
(     \(9   nil 3  3  0\)) S
LHL
(     \(12  nil 4  3  1\)) S
LHL
(     \(16  nil 4  4  0\)) S
LHL
(     \(18  t   3  6  0\)) S
LHL
(     \(20  nil 5  4  1\)) S
LHL
(     \(25  nil 5  5  0\)) S
LHL
(     \(30  nil 6  5  1\)) S
LHL
(     \(32  t   4  8  0\)) S
LHL
(     \(36  nil 6  6  0\)) S
LHL
(     \(42  nil 7  6  1\)) S
LHL
(     \(49  nil 7  7  0\)) S
LHL
(     \(50  t   5  10 0\)) S
LHL
(     \(56  nil 8  7  1\)) S
LHL
(     \(64  nil 8  8  0\)) S
LHL
(     \(72  nil 9  8  0\)) S
LHL
(     \(81  nil 9  9  0\)) S
LHL
(     \(90  nil 10 9  1\)) S
LHL
(     \(98  t   7  14 0\)) S
LHL
(     \(100 nil 10 10 0\)\)\)) S
LHL
(  "Alist which is the page matrix database used for N-up printing.) S
PHL
LHL
(Each element has the following form:) S
PHL
LHL
(   \(PAGE) S
LHL
(    \(MAX LANDSCAPE LINES COLUMNS COL-MISSING\)) S
LHL
(    ...\)) S
PHL
LHL
(Where:) S
LHL
(PAGE is the page size used \(see `ps-paper-type'\).) S
LHL
(MAX is the maximum elements of this page matrix.) S
LHL
(LANDSCAPE specifies if page matrix is landscaped, has the following valid) S
LHL
10 W
(values:) S
LHL
12 W
(nil   the sheet is in portrait mode.) S
LHL
12 W
(t     the sheet is in landscape mode.) S
LHL
12 W
(pag   the sheet is in portrait mode and page is in landscape mode.) S
LHL
(LINES is the number of lines of page matrix.) S
LHL
(COLUMNS is the number of columns of page matrix.) S
LHL
(COL-MISSING is the number of columns missing to fill the sheet."\)) S
PHL
EndPage
EndDSCPage
EndSheet

%%Page: 77 105
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5268 def
/PageNumber 77 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5267 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
LHL
(\(defmacro ps-n-up-landscape \(mat\) `\(nth 1 ,mat\)\)) S
LHL
(\(defmacro ps-n-up-lines     \(mat\) `\(nth 2 ,mat\)\)) S
LHL
(\(defmacro ps-n-up-columns   \(mat\) `\(nth 3 ,mat\)\)) S
LHL
(\(defmacro ps-n-up-missing   \(mat\) `\(nth 4 ,mat\)\)) S
PHL
PHL
LHL
(\(defun ps-n-up-printing \(\)) S
LHL
(  ;; force `ps-n-up-printing' be in range 1 to 100.) S
LHL
(  \(setq ps-n-up-printing \(max \(min ps-n-up-printing 100\) 1\)\)) S
LHL
(  ;; find suitable page matrix for a given `ps-paper-type'.) S
LHL
(  \(let \(\(the-list \(cdr \(assq ps-paper-type ps-n-up-database\)\)\)\)) S
LHL
(    \(and the-list) S
LHL
9 W
(\(while \(> ps-n-up-printing \(caar the-list\)\)) S
LHL
11 W
(\(setq the-list \(cdr the-list\)\)\)\)) S
LHL
(    \(or \(car the-list\)) S
LHL
8 W
('\(1 nil 1 1 0\)\)\)\)) S
PHL
PHL
LHL
(\(defconst ps-n-up-filling-database) S
LHL
(  '\(\(left-top) S
LHL
(     "PageWidth") S
24 W
(; N-Up-XColumn) S
LHL
(     "0") S
32 W
(; N-Up-YColumn) S
LHL
(     "N-Up-End 1 sub PageWidth mul neg" ; N-Up-XLine) S
LHL
(     "LandscapePageHeight neg") S
10 W
(; N-Up-YLine) S
LHL
(     "N-Up-Lines") S
23 W
(; N-Up-Repeat) S
LHL
(     "N-Up-Columns") S
21 W
(; N-Up-End) S
LHL
(     "0") S
32 W
(; N-Up-XStart) S
LHL
(     "0"\)) S
31 W
(; N-Up-YStart) S
LHL
(    \(left-bottom) S
LHL
(     "PageWidth") S
24 W
(; N-Up-XColumn) S
LHL
(     "0") S
32 W
(; N-Up-YColumn) S
LHL
(     "N-Up-End 1 sub PageWidth mul neg" ; N-Up-XLine) S
LHL
(     "LandscapePageHeight") S
14 W
(; N-Up-YLine) S
LHL
(     "N-Up-Lines") S
23 W
(; N-Up-Repeat) S
LHL
(     "N-Up-Columns") S
21 W
(; N-Up-End) S
LHL
(     "0") S
32 W
(; N-Up-XStart) S
LHL
(     "N-Up-Repeat 1 sub LandscapePageHeight mul neg"\) ; N-Up-YStart) S
LHL
(    \(right-top) S
LHL
(     "PageWidth neg") S
20 W
(; N-Up-XColumn) S
LHL
(     "0") S
32 W
(; N-Up-YColumn) S
LHL
(     "N-Up-End 1 sub PageWidth mul") S
5 W
(; N-Up-XLine) S
LHL
(     "LandscapePageHeight neg") S
10 W
(; N-Up-YLine) S
LHL
(     "N-Up-Lines") S
23 W
(; N-Up-Repeat) S
LHL
(     "N-Up-Columns") S
21 W
(; N-Up-End) S
LHL
(     "N-Up-End 1 sub PageWidth mul") S
5 W
(; N-Up-XStart) S
LHL
(     "0"\)) S
31 W
(; N-Up-YStart) S
LHL
(    \(right-bottom) S
LHL
(     "PageWidth neg") S
20 W
(; N-Up-XColumn) S
LHL
(     "0") S
32 W
(; N-Up-YColumn) S
LHL
(     "N-Up-End 1 sub PageWidth mul") S
5 W
(; N-Up-XLine) S
LHL
(     "LandscapePageHeight") S
14 W
(; N-Up-YLine) S
LHL
(     "N-Up-Lines") S
23 W
(; N-Up-Repeat) S
LHL
(     "N-Up-Columns") S
21 W
(; N-Up-End) S
LHL
(     "N-Up-End 1 sub PageWidth mul") S
5 W
(; N-Up-XStart) S
LHL
(     "N-Up-Repeat 1 sub LandscapePageHeight mul neg"\) ; N-Up-YStart) S
LHL
(    \(top-left) S
LHL
(     "0") S
32 W
(; N-Up-XColumn) S
LHL
(     "LandscapePageHeight neg") S
10 W
(; N-Up-YColumn) S
LHL
(     "PageWidth") S
24 W
(; N-Up-XLine) S
LHL
(     "N-Up-End 1 sub LandscapePageHeight mul" ; N-Up-YLine) S
LHL
(     "N-Up-Columns") S
21 W
(; N-Up-Repeat) S
LHL
(     "N-Up-Lines") S
23 W
(; N-Up-End) S
LHL
(     "0") S
32 W
(; N-Up-XStart) S
LHL
(     "0"\)) S
31 W
(; N-Up-YStart) S
LHL
(    \(bottom-left) S
LHL
(     "0") S
32 W
(; N-Up-XColumn) S
LHL
(     "LandscapePageHeight") S
14 W
(; N-Up-YColumn) S
LHL
(     "PageWidth") S
24 W
(; N-Up-XLine) S
LHL
(     "N-Up-End 1 sub LandscapePageHeight mul neg" ; N-Up-YLine) S
LHL
(     "N-Up-Columns") S
21 W
(; N-Up-Repeat) S
LHL
(     "N-Up-Lines") S
23 W
(; N-Up-End) S
EndPage
EndDSCPage
EndSheet

%%Page: 78 106
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5340 def
/PageNumber 78 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5339 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(     "0") S
32 W
(; N-Up-XStart) S
LHL
(     "N-Up-End 1 sub LandscapePageHeight mul neg"\) ; N-Up-YStart) S
LHL
(    \(top-right) S
LHL
(     "0") S
32 W
(; N-Up-XColumn) S
LHL
(     "LandscapePageHeight neg") S
10 W
(; N-Up-YColumn) S
LHL
(     "PageWidth neg") S
20 W
(; N-Up-XLine) S
LHL
(     "N-Up-End 1 sub LandscapePageHeight mul" ; N-Up-YLine) S
LHL
(     "N-Up-Columns") S
21 W
(; N-Up-Repeat) S
LHL
(     "N-Up-Lines") S
23 W
(; N-Up-End) S
LHL
(     "N-Up-Repeat 1 sub PageWidth mul") S
2 W
(; N-Up-XStart) S
LHL
(     "0"\)) S
31 W
(; N-Up-YStart) S
LHL
(    \(bottom-right) S
LHL
(     "0") S
32 W
(; N-Up-XColumn) S
LHL
(     "LandscapePageHeight") S
14 W
(; N-Up-YColumn) S
LHL
(     "PageWidth neg") S
20 W
(; N-Up-XLine) S
LHL
(     "N-Up-End 1 sub LandscapePageHeight mul neg" ; N-Up-YLine) S
LHL
(     "N-Up-Columns") S
21 W
(; N-Up-Repeat) S
LHL
(     "N-Up-Lines") S
23 W
(; N-Up-End) S
LHL
(     "N-Up-Repeat 1 sub PageWidth mul") S
2 W
(; N-Up-XStart) S
LHL
(     "N-Up-End 1 sub LandscapePageHeight mul neg"\)\) ; N-Up-YStart) S
LHL
(  "Alist for n-up printing initializations.) S
PHL
LHL
(Each element has the following form:) S
PHL
LHL
(   \(KIND XCOL YCOL XLIN YLIN REPEAT END XSTART YSTART\)) S
PHL
LHL
(Where:) S
LHL
(KIND is a valid value of the variable `ps-n-up-filling'.) S
LHL
(XCOL YCOL are the relative position for the next column.) S
LHL
(XLIN YLIN are the relative position for the beginning of next line.) S
LHL
(REPEAT is the number of repetitions for external loop.) S
LHL
(END is the number of repetitions for internal loop and also the number) S
LHL
(    of pages in a row.) S
LHL
(XSTART YSTART are the relative position for the first page in a sheet."\)) S
PHL
PHL
LHL
(\(defun ps-n-up-filling \(\)) S
LHL
(  \(cdr \(or \(assq ps-n-up-filling ps-n-up-filling-database\)) S
LHL
11 W
(\(assq 'left-top ps-n-up-filling-database\)\)\)\)) S
PHL
PHL
LHL
(\(defmacro ps-n-up-xcolumn \(init\) `\(nth 0 ,init\)\)) S
LHL
(\(defmacro ps-n-up-ycolumn \(init\) `\(nth 1 ,init\)\)) S
LHL
(\(defmacro ps-n-up-xline) S
3 W
(\(init\) `\(nth 2 ,init\)\)) S
LHL
(\(defmacro ps-n-up-yline) S
3 W
(\(init\) `\(nth 3 ,init\)\)) S
LHL
(\(defmacro ps-n-up-repeat  \(init\) `\(nth 4 ,init\)\)) S
LHL
(\(defmacro ps-n-up-end) S
5 W
(\(init\) `\(nth 5 ,init\)\)) S
LHL
(\(defmacro ps-n-up-xstart  \(init\) `\(nth 6 ,init\)\)) S
LHL
(\(defmacro ps-n-up-ystart  \(init\) `\(nth 7 ,init\)\)) S
PHL
PHL
LHL
(\(defconst ps-error-handler-alist) S
LHL
(  '\(\(none             . 0\)) S
LHL
(    \(paper            . 1\)) S
LHL
(    \(system           . 2\)) S
LHL
(    \(paper-and-system . 3\)\)) S
LHL
(  "Alist for error handler message."\)) S
PHL
PHL
LHL
(\(defconst ps-zebra-stripe-alist) S
LHL
(  '\(\(follow      . 1\)) S
LHL
(    \(full        . 2\)) S
LHL
(    \(full-follow . 3\)\)) S
LHL
(  "Alist for zebra stripe continuation."\)) S
PHL
PHL
LHL
(\(defun ps-begin-file \(\)) S
LHL
(  \(setq ps-page-order 0) S
LHL
8 W
(ps-page-printed 0) S
LHL
8 W
(ps-background-text-count 0) S
LHL
8 W
(ps-background-image-count 0) S
LHL
8 W
(ps-background-pages nil) S
EndPage
EndDSCPage
EndSheet

%%Page: 79 107
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5412 def
/PageNumber 79 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5411 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
8 W
(ps-background-all-pages nil\)) S
PHL
LHL
(  \(let \(\(dimensions \(cdr \(assq ps-paper-type ps-page-dimensions-database\)\)\)) S
LHL
8 W
(\(tumble \(if ps-landscape-mode \(not ps-spool-tumble\) ps-spool-tumble\)\)) S
LHL
8 W
(\(n-up \(ps-n-up-printing\)\)) S
LHL
8 W
(\(n-up-filling \(ps-n-up-filling\)\)\)) S
LHL
(    \(and ps-n-up-on \(setq tumble \(not tumble\)\)\)) S
LHL
(    \(ps-output) S
LHL
(     ps-adobe-tag) S
LHL
(     "%%Title: " \(buffer-name\)) S
10 W
(; Take job name from name of) S
LHL
40 W
(; first buffer printed) S
LHL
(     "\\n%%Creator: ps-print v" ps-print-version) S
LHL
(     "\\n%%For: " \(user-full-name\)       ;FIXME: may need encoding!) S
LHL
(     "\\n%%CreationDate: " \(format-time-string "%T %b %d %Y"\) ;FIXME: encoding!) S
LHL
(     "\\n%%Orientation: ") S
LHL
(     \(if ps-landscape-mode "Landscape" "Portrait"\)) S
LHL
(     "\\n%%DocumentNeededResources: font Times-Roman Times-Italic\\n%%+ font ") S
LHL
(     \(mapconcat 'identity) S
LHL
16 W
(\(ps-remove-duplicates) S
LHL
17 W
(\(append \(ps-fonts 'ps-font-for-text\)) S
LHL
25 W
(\(list \(ps-font 'ps-font-for-header 'normal\)) S
LHL
31 W
(\(ps-font 'ps-font-for-header 'bold\)) S
LHL
31 W
(\(ps-font 'ps-font-for-footer 'normal\)) S
LHL
31 W
(\(ps-font 'ps-font-for-footer 'bold\)\)\)\)) S
LHL
16 W
("\\n%%+ font "\)) S
LHL
(     "\\n%%DocumentSuppliedResources: procset PSPrintUserDefinedPrologue-" \(user-login-name\) " 0 0) S
SL
(") S
LHL
(     "\\n%%DocumentMedia: " \(ps-page-dimensions-get-media dimensions\)) S
LHL
(     \(format " %d" \(round \(ps-page-dimensions-get-width dimensions\)\)\)) S
LHL
(     \(format " %d" \(round \(ps-page-dimensions-get-height dimensions\)\)\)) S
LHL
(     " 0 \(\) \(\)\\n%%PageOrder: Ascend\\n%%Pages: \(atend\)\\n%%Requirements:") S
LHL
(     \(if ps-spool-duplex) S
LHL
9 W
(\(if tumble " duplex\(tumble\)\\n" " duplex\\n"\)) S
LHL
(       "\\n"\)\)) S
PHL
LHL
(    \(ps-insert-string ps-print-prologue-header\)) S
PHL
LHL
(    \(ps-output "%%EndComments\\n%%BeginDefaults\\n%%PageMedia: ") S
LHL
15 W
(\(ps-page-dimensions-get-media dimensions\)) S
LHL
15 W
("\\n%%EndDefaults\\n\\n%%BeginProlog\\n\\n") S
LHL
15 W
("/languagelevel where{pop}{/languagelevel 1 def}ifelse\\n") S
LHL
15 W
(\(format "/ErrorMessage  %s def\\n\\n") S
LHL
23 W
(\(or \(cdr \(assoc ps-error-handler-message) S
LHL
39 W
(ps-error-handler-alist\)\)) S
LHL
27 W
(1\)\)) S
10 W
(; send to paper) S
LHL
15 W
(ps-print-prologue-0) S
LHL
15 W
("\\n%%BeginResource: procset PSPrintUserDefinedPrologue-" \(user-login-name\) " 0 0\\n) S
SL
(\\n"\)) S
PHL
LHL
(    \(ps-insert-string ps-user-defined-prologue\)) S
PHL
LHL
(    \(ps-output "\\n%%EndResource\\n\\n"\)) S
PHL
LHL
(    \(ps-output-boolean "LandscapeMode      ") S
LHL
23 W
(\(or ps-landscape-mode) S
LHL
27 W
(\(eq \(ps-n-up-landscape n-up\) 'pag\)\)\)) S
LHL
(    \(ps-output-boolean "UpsideDown         " ps-print-upside-down\)) S
LHL
(    \(ps-output \(format "/NumberOfColumns     %d def\\n" ps-number-of-columns\)) S
PHL
LHL
15 W
(\(format "/LandscapePageHeight %s def\\n" ps-landscape-page-height\)) S
LHL
15 W
(\(format "/PrintPageWidth      %s def\\n") S
LHL
23 W
(\(- \(* \(+ ps-print-width ps-inter-column\)) S
LHL
29 W
(ps-number-of-columns\)) S
LHL
26 W
(ps-inter-column\)\)) S
LHL
15 W
(\(format "/PrintWidth   %s def\\n" ps-print-width\)) S
LHL
15 W
(\(format "/PrintHeight  %s def\\n" ps-print-height\)) S
PHL
LHL
15 W
(\(format "/LeftMargin   %s def\\n" ps-left-margin\)) S
LHL
15 W
(\(format "/RightMargin  %s def\\n" ps-right-margin\)) S
LHL
15 W
(\(format "/InterColumn  %s def\\n" ps-inter-column\)) S
PHL
LHL
15 W
(\(format "/BottomMargin %s def\\n" ps-bottom-margin\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 80 108
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5482 def
/PageNumber 80 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5483 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
15 W
(\(format "/TopMargin    %s def\\n" ps-top-margin\) ; not used) S
LHL
15 W
(\(format "/HeaderOffset %s def\\n" ps-header-offset\)) S
LHL
15 W
(\(format "/HeaderPad    %s def\\n" ps-header-pad\)) S
LHL
15 W
(\(format "/FooterOffset %s def\\n" ps-footer-offset\)) S
LHL
15 W
(\(format "/FooterPad    %s def\\n" ps-footer-pad\)) S
LHL
15 W
(\(format "/FooterLines  %s def\\n" ps-footer-lines\)\)) S
PHL
LHL
(    \(ps-output-boolean "ShowNofN          " ps-show-n-of-n\)) S
LHL
(    \(ps-output-boolean "SwitchHeader      " \(if \(eq ps-switch-header 'duplex\)) S
LHL
48 W
(ps-spool-duplex) S
LHL
46 W
(ps-switch-header\)\)) S
LHL
(    \(ps-output-boolean "PrintOnlyOneHeader" ps-print-only-one-header\)) S
LHL
(    \(ps-output-boolean "PrintHeader       " ps-print-header\)) S
LHL
(    \(ps-output-boolean "PrintHeaderFrame  " ps-print-header-frame\)) S
LHL
(    \(ps-output-frame-properties "HeaderFrameProperties" ps-header-frame-alist\)) S
LHL
(    \(ps-output-boolean "PrintFooter       " ps-print-footer\)) S
LHL
(    \(ps-output-boolean "PrintFooterFrame  " ps-print-footer-frame\)) S
LHL
(    \(ps-output-frame-properties "FooterFrameProperties" ps-footer-frame-alist\)) S
PHL
LHL
(    \(let \(\(line-height \(ps-line-height 'ps-font-for-text\)\)\)) S
LHL
(      \(ps-output \(format "/LineSpacing      %s def\\n" ps-line-spacing-internal\)) S
LHL
17 W
(\(format "/ParagraphSpacing %s def\\n") S
LHL
25 W
(ps-paragraph-spacing-internal\)) S
LHL
17 W
(\(format "/LineHeight       %s def\\n" line-height\)) S
LHL
17 W
(\(format "/LinesPerColumn   %d def\\n") S
LHL
25 W
(\(let \(\(height \(+ line-height) S
LHL
42 W
(ps-line-spacing-internal\)\)\)) S
LHL
27 W
(\(round \(/ \(+ ps-print-height) S
LHL
40 W
(\(* height 0.45\)\)) S
LHL
37 W
(height\)\)\)\)\)\)) S
PHL
LHL
(    \(ps-output-boolean "WarnPaperSize   " ps-warn-paper-type\)) S
LHL
(    \(ps-output-boolean "Zebra           " ps-zebra-stripes\)) S
LHL
(    \(ps-output-boolean "PrintLineNumber " ps-line-number\)) S
LHL
(    \(ps-output-boolean "SyncLineZebra   " \(not \(integerp ps-line-number-step\)\)\)) S
LHL
(    \(ps-output \(format "/ZebraFollow      %d def\\n") S
LHL
23 W
(\(or \(cdr \(assq ps-zebra-stripe-follow) S
LHL
38 W
(ps-zebra-stripe-alist\)\)) S
LHL
27 W
(0\)\)) S
LHL
15 W
(\(format "/PrintLineStep    %d def\\n") S
LHL
23 W
(\(if \(integerp ps-line-number-step\)) S
LHL
27 W
(ps-line-number-step) S
LHL
25 W
(ps-zebra-stripe-height\)\)) S
LHL
15 W
(\(format "/PrintLineStart   %d def\\n" ps-line-number-start\)) S
LHL
15 W
("/LineNumberColor  ") S
LHL
15 W
(\(ps-format-color ps-line-number-color 0.0\)) S
LHL
15 W
(\(format "def\\n/ZebraHeight      %d def\\n") S
LHL
23 W
(ps-zebra-stripe-height\)) S
LHL
15 W
("/ZebraColor       ") S
LHL
15 W
(\(ps-format-color ps-zebra-color 0.95\)) S
LHL
15 W
("def\\n"\)) S
LHL
(    \(ps-output "/BackgroundColor  ") S
LHL
15 W
(\(ps-format-color ps-default-background 1.0\)) S
LHL
15 W
("def\\n"\)) S
LHL
(    \(ps-output "/UseSetpagedevice ") S
LHL
15 W
(\(if \(eq ps-spool-config 'setpagedevice\)) S
LHL
19 W
("/setpagedevice where{pop languagelevel 2 eq}{false}ifelse") S
LHL
17 W
("false"\)) S
LHL
15 W
(" def\\n\\n/PageWidth ") S
LHL
15 W
("PrintPageWidth LeftMargin add RightMargin add def\\n\\n") S
LHL
15 W
(\(format "/N-Up           %d def\\n" ps-n-up-printing\)\)) S
LHL
(    \(ps-output-boolean "N-Up-Landscape" \(eq \(ps-n-up-landscape n-up\) t\)\)) S
LHL
(    \(ps-output-boolean "N-Up-Border   " ps-n-up-border-p\)) S
LHL
(    \(ps-output \(format "/N-Up-Lines     %d def\\n" \(ps-n-up-lines n-up\)\)) S
LHL
15 W
(\(format "/N-Up-Columns   %d def\\n" \(ps-n-up-columns n-up\)\)) S
LHL
15 W
(\(format "/N-Up-Missing   %d def\\n" \(ps-n-up-missing n-up\)\)) S
LHL
15 W
(\(format "/N-Up-Margin    %s def\\n" ps-n-up-margin\)) S
LHL
15 W
("/N-Up-Repeat    ") S
LHL
15 W
(\(if ps-landscape-mode) S
LHL
19 W
(\(ps-n-up-end     n-up-filling\)) S
LHL
17 W
(\(ps-n-up-repeat  n-up-filling\)\)) S
LHL
15 W
(" def\\n/N-Up-End       ") S
EndPage
EndDSCPage
EndSheet

%%Page: 81 109
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5554 def
/PageNumber 81 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5555 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
15 W
(\(if ps-landscape-mode) S
LHL
19 W
(\(ps-n-up-repeat  n-up-filling\)) S
LHL
17 W
(\(ps-n-up-end     n-up-filling\)\)) S
LHL
15 W
(" def\\n/N-Up-XColumn   " \(ps-n-up-xcolumn n-up-filling\)) S
LHL
15 W
(" def\\n/N-Up-YColumn   " \(ps-n-up-ycolumn n-up-filling\)) S
LHL
15 W
(" def\\n/N-Up-XLine     " \(ps-n-up-xline   n-up-filling\)) S
LHL
15 W
(" def\\n/N-Up-YLine     " \(ps-n-up-yline   n-up-filling\)) S
LHL
15 W
(" def\\n/N-Up-XStart    " \(ps-n-up-xstart  n-up-filling\)) S
LHL
15 W
(" def\\n/N-Up-YStart    " \(ps-n-up-ystart  n-up-filling\) " def\\n"\)) S
PHL
LHL
(    \(ps-background-text\)) S
LHL
(    \(ps-background-image\)) S
LHL
(    \(setq ps-background-all-pages \(nreverse ps-background-all-pages\)) S
LHL
10 W
(ps-background-pages \(nreverse ps-background-pages\)\)) S
PHL
LHL
(    \(ps-output "\\n" ps-print-prologue-1) S
LHL
15 W
("\\n/printGlobalBackground{\\n"\)) S
LHL
(    \(mapc 'ps-output ps-background-all-pages\)) S
LHL
(    \(ps-output) S
LHL
(     "}def\\n/printLocalBackground{\\n}def\\n") S
LHL
(     "\\n%%EndProlog\\n\\n%%BeginSetup\\n") S
LHL
(     "\\n%%IncludeResource: font Times-Roman") S
LHL
(     "\\n%%IncludeResource: font Times-Italic") S
LHL
(     "\\n%%IncludeResource: font ") S
LHL
(     \(mapconcat 'identity) S
LHL
16 W
(\(ps-remove-duplicates) S
LHL
17 W
(\(append \(ps-fonts 'ps-font-for-text\)) S
LHL
25 W
(\(list \(ps-font 'ps-font-for-header 'normal\)) S
LHL
31 W
(\(ps-font 'ps-font-for-header 'bold\)) S
LHL
31 W
(\(ps-font 'ps-font-for-footer 'normal\)) S
LHL
31 W
(\(ps-font 'ps-font-for-footer 'bold\)\)\)\)) S
LHL
16 W
("\\n%%IncludeResource: font "\)) S
LHL
(     ;; Header/line number fonts) S
LHL
(     \(format "\\n/h0 %s\(%s\)cvn DefFont\\n" ; /h0 14/Helvetica-Bold DefFont) S
LHL
13 W
(ps-header-title-font-size-internal) S
LHL
13 W
(\(ps-font 'ps-font-for-header 'bold\)\)) S
LHL
(     \(format "/h1 %s\(%s\)cvn DefFont\\n") S
2 W
(; /h1 12/Helvetica DefFont) S
LHL
13 W
(ps-header-font-size-internal) S
LHL
13 W
(\(ps-font 'ps-font-for-header 'normal\)\)) S
LHL
(     \(format "/L0 %s\(%s\)cvn DefFont\\n") S
2 W
(; /L0 6/Times-Italic DefFont) S
LHL
13 W
(\(ps-get-font-size 'ps-line-number-font-size\)) S
LHL
13 W
(ps-line-number-font\)) S
LHL
(     \(format "/H0 %s\(%s\)cvn DefFont\\n") S
2 W
(; /H0 12/Helvetica DefFont) S
LHL
13 W
(ps-footer-font-size-internal) S
LHL
13 W
(\(ps-font 'ps-font-for-footer 'normal\)\)) S
LHL
(     "\\n\\n% ---- These lines must be kept together because...) S
PHL
LHL
(/h0 F) S
LHL
(/HeaderTitleLineHeight FontHeight def) S
PHL
LHL
(/h1 F) S
LHL
(/HeaderLineHeight FontHeight def) S
LHL
(/HeaderDescent    Descent def) S
PHL
LHL
(/H0 F) S
LHL
(/FooterLineHeight FontHeight def) S
LHL
(/FooterDescent    Descent def) S
PHL
LHL
(% ---- ...because `F' has a side-effect on `FontHeight' and `Descent'\\n\\n"\)) S
PHL
LHL
(    ;; Text fonts) S
LHL
(    \(let \(\(font \(ps-font-alist 'ps-font-for-text\)\)) S
LHL
10 W
(\(i 0\)\)) S
LHL
(      \(while font) S
LHL
8 W
(\(ps-output \(format "/f%d %s\(%s\)cvn DefFont\\n") S
LHL
27 W
(i) S
LHL
27 W
(ps-font-size-internal) S
LHL
27 W
(\(ps-font 'ps-font-for-text \(car \(car font\)\)\)\)\)) S
LHL
8 W
(\(setq font \(cdr font\)) S
LHL
14 W
(i \(1+ i\)\)\)\)) S
PHL
LHL
(    \(let \(\(font-entry \(cdr \(assq ps-font-family ps-font-info-database\)\)\)\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 82 110
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5626 def
/PageNumber 82 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5627 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(      \(ps-output \(format "/SpaceWidthRatio %f def\\n") S
LHL
25 W
(\(/ \(ps-lookup 'space-width\) \(ps-lookup 'size\)\)\)\)\)) S
PHL
LHL
(    \(unless \(eq ps-spool-config 'lpr-switches\)) S
LHL
(      \(ps-output "\\n%%BeginFeature: *Duplex ") S
LHL
17 W
(\(ps-boolean-capitalized ps-spool-duplex\)) S
LHL
17 W
(" *Tumble ") S
LHL
17 W
(\(ps-boolean-capitalized tumble\)) S
LHL
17 W
("\\nUseSetpagedevice\\n{BMark/Duplex ") S
LHL
17 W
(\(ps-boolean-constant ps-spool-duplex\)) S
LHL
17 W
("/Tumble ") S
LHL
17 W
(\(ps-boolean-constant tumble\)) S
LHL
17 W
(" EMark setpagedevice}\\n{statusdict begin ") S
LHL
17 W
(\(ps-boolean-constant ps-spool-duplex\)) S
LHL
17 W
(" setduplexmode ") S
LHL
17 W
(\(ps-boolean-constant tumble\)) S
LHL
17 W
(" settumble end}ifelse\\n%%EndFeature\\n"\)\)\)) S
LHL
(  \(ps-output "\\n%%BeginFeature: *ManualFeed ") S
LHL
13 W
(\(ps-boolean-capitalized ps-manual-feed\)) S
LHL
13 W
("\\nBMark /ManualFeed ") S
LHL
13 W
(\(ps-boolean-constant ps-manual-feed\)) S
LHL
13 W
(" EMark setpagedevice\\n%%EndFeature\\n\\nBeginDoc\\n%%EndSetup\\n"\)) S
LHL
(  \(and ps-banner-page-when-duplexing) S
LHL
(       \(ps-output "\\n%%Page: banner 0\\nsave showpage restore\\n"\)\)\)) S
PHL
PHL
LHL
(\(defun ps-format-color \(color &optional default\)) S
LHL
(  \(let \(\(the-color \(if \(stringp color\)) S
LHL
23 W
(\(ps-color-scale color\)) S
LHL
21 W
(color\)\)\)) S
LHL
(    \(if \(and the-color \(listp the-color\)\)) S
LHL
8 W
(\(concat "[") S
LHL
16 W
(\(format ps-color-format) S
LHL
24 W
(\(* \(nth 0 the-color\) 1.0\) ; force float number) S
LHL
24 W
(\(* \(nth 1 the-color\) 1.0\) ; force float number) S
LHL
24 W
(\(* \(nth 2 the-color\) 1.0\)\) ; force float number) S
LHL
16 W
("] "\)) S
LHL
(      \(ps-float-format \(if \(numberp the-color\) the-color default\)\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-insert-string \(prologue\)) S
LHL
(  \(let \(\(str \(if \(functionp prologue\)) S
LHL
17 W
(\(funcall prologue\)) S
LHL
15 W
(prologue\)\)\)) S
LHL
(    \(and \(stringp str\)) S
LHL
9 W
(\(ps-output str\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-boolean-capitalized \(bool\)) S
LHL
(  \(if bool "True" "False"\)\)) S
PHL
PHL
LHL
(\(defun ps-boolean-constant \(bool\)) S
LHL
(  \(if bool "true" "false"\)\)) S
PHL
PHL
LHL
(\(defun ps-header-dirpart \(\)) S
LHL
(  \(let \(\(fname \(buffer-file-name\)\)\)) S
LHL
(    \(if fname) S
LHL
8 W
(\(if \(string-equal \(buffer-name\) \(file-name-nondirectory fname\)\)) S
LHL
12 W
(\(abbreviate-file-name \(file-name-directory fname\)\)) S
LHL
10 W
(fname\)) S
LHL
(      ""\)\)\)) S
PHL
PHL
LHL
(\(defun ps-get-buffer-name \(\)) S
LHL
(  \(cond) S
LHL
(   ;; Indulge Jim this little easter egg:) S
LHL
(   \(\(string= \(buffer-name\) "ps-print.el"\)) S
LHL
(    "Hey, Cool!  It's ps-print.el!!!"\)) S
LHL
(   ;; Indulge Jack this other little easter egg:) S
LHL
(   \(\(string= \(buffer-name\) "sokoban.el"\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 83 111
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5698 def
/PageNumber 83 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5699 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    "Super! C'est sokoban.el!"\)) S
LHL
(   \(t \(concat) S
LHL
(       \(and ps-printing-region-p "Subset of: "\)) S
LHL
(       \(buffer-name\)) S
LHL
(       \(and \(buffer-modified-p\) " \(unsaved\)"\)\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-get-size \(size mess &optional arg\)) S
LHL
(  \(let \(\(siz \(cond \(\(numberp size\)) S
LHL
20 W
(size\)) S
LHL
19 W
(\(\(and \(consp size\)) S
LHL
25 W
(\(numberp \(car size\)\)) S
LHL
25 W
(\(numberp \(cdr size\)\)\)) S
LHL
20 W
(\(if ps-landscape-mode) S
LHL
24 W
(\(car size\)) S
LHL
22 W
(\(cdr size\)\)\)) S
LHL
19 W
(\(t) S
LHL
20 W
(-1\)\)\)\)) S
LHL
(    \(and \(< siz 0\)) S
LHL
9 W
(\(error "Invalid %s `%S'%s") S
LHL
16 W
(mess size) S
LHL
16 W
(\(if arg) S
LHL
20 W
(\(format-message " for `%S'" arg\)) S
LHL
18 W
(""\)\)\)) S
LHL
(    siz\)\)) S
PHL
PHL
LHL
(\(defun ps-get-font-size \(font-sym\)) S
LHL
(  \(ps-get-size \(symbol-value font-sym\) "font size" font-sym\)\)) S
PHL
PHL
LHL
(\(defun ps-rgb-color \(color unspecified default\)) S
LHL
(  \(cond) S
LHL
(   ;; \(float float float\) ==> \(R G B\)) S
LHL
(   \(\(and color \(listp color\) \(= \(length color\) 3\)) S
LHL
9 W
(\(let \(\(cl color\)) S
LHL
15 W
(\(ok t\) e\)) S
LHL
11 W
(\(while \(and ok cl\)) S
LHL
13 W
(\(setq e  \(car cl\)) S
LHL
19 W
(cl \(cdr cl\)) S
LHL
19 W
(ok \(and \(floatp e\) \(<= 0.0 e\) \(<= e 1.0\)\)\)\)) S
LHL
11 W
(ok\)\)) S
LHL
(    color\)) S
LHL
(   ;; float ==> 0.0 = black .. 1.0 = white) S
LHL
(   \(\(and \(floatp color\) \(<= 0.0 color\) \(<= color 1.0\)\)) S
LHL
(    \(list color color color\)\)) S
LHL
(   ;; "colorName" but different from "unspecified-[bf]g") S
LHL
(   \(\(and \(stringp color\) \(not \(string= color unspecified\)\)\)) S
LHL
(    \(ps-color-scale color\)\)) S
LHL
(   ;; ok, use the default) S
LHL
(   \(t) S
LHL
(    \(list default default default\)\)\)\)) S
PHL
LHL
(\(defvar ps-basic-plot-string-function 'ps-basic-plot-string\)) S
PHL
LHL
(\(defun ps-begin-job \(genfunc\)) S
LHL
(  ;; prologue files) S
LHL
(  \(or \(equal ps-mark-code-directory ps-postscript-code-directory\)) S
LHL
(      \(setq ps-print-prologue-0    \(ps-prologue-file 0\)) S
LHL
12 W
(ps-print-prologue-1    \(ps-prologue-file 1\)) S
LHL
12 W
(ps-mark-code-directory ps-postscript-code-directory\)\)) S
LHL
(  ;; selected pages) S
LHL
(  \(let \(new page\)) S
LHL
(    \(while ps-selected-pages) S
LHL
(      \(setq page              \(car ps-selected-pages\)) S
LHL
12 W
(ps-selected-pages \(cdr ps-selected-pages\)\)) S
LHL
(      \(cond \(\(integerp page\)) S
LHL
13 W
(\(and \(> page 0\)) S
LHL
18 W
(\(setq new \(cons \(cons page page\) new\)\)\)\)) S
LHL
12 W
(\(\(consp page\)) S
LHL
13 W
(\(and \(integerp \(car page\)\) \(integerp \(cdr page\)\)) S
LHL
18 W
(\(> \(car page\) 0\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 84 112
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5770 def
/PageNumber 84 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5771 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
18 W
(\(<= \(car page\) \(cdr page\)\)) S
LHL
18 W
(\(setq new \(cons page new\)\)\)\)\)\)) S
LHL
(    \(setq ps-selected-pages      \(sort new #'\(lambda \(one other\)) S
LHL
47 W
(\(< \(car one\) \(car other\)\)\)\)) S
LHL
10 W
(ps-last-selected-pages ps-selected-pages) S
LHL
10 W
(ps-first-page          nil) S
LHL
10 W
(ps-last-page           nil\)\)) S
LHL
(  ;; face background) S
LHL
(  \(or \(listp ps-use-face-background\)) S
LHL
(      \(setq ps-use-face-background t\)\)) S
LHL
(  ;; line number) S
LHL
(  \(and \(integerp ps-line-number-step\)) S
LHL
(       \(<= ps-line-number-step 0\)) S
LHL
(       \(setq ps-line-number-step 1\)\)) S
LHL
(  \(setq ps-n-up-on           \(> ps-n-up-printing 1\)) S
LHL
8 W
(ps-line-number-start \(max 1 \(min ps-line-number-start) S
LHL
41 W
(\(if \(integerp ps-line-number-step\)) S
LHL
45 W
(ps-line-number-step) S
LHL
43 W
(ps-zebra-stripe-height\)\)\)\)) S
LHL
(  ;; spooling buffer) S
LHL
(  \(with-current-buffer ps-spool-buffer) S
LHL
(    \(goto-char \(point-max\)\)) S
LHL
(    \(and \(re-search-backward "^%%Trailer$" nil t\)) S
LHL
9 W
(\(delete-region \(match-beginning 0\) \(point-max\)\)\)\)) S
LHL
(  ;; miscellaneous) S
LHL
(  \(setq ps-zebra-stripe-full-p \(memq ps-zebra-stripe-follow) S
LHL
37 W
('\(full full-follow\)\)) S
LHL
8 W
(ps-page-postscript 0) S
LHL
8 W
(ps-page-sheet 0) S
LHL
8 W
(ps-page-n-up 0) S
LHL
8 W
(ps-page-column 0) S
LHL
8 W
(ps-lines-printed 0) S
LHL
8 W
(ps-print-page-p t) S
LHL
8 W
(ps-showline-count \(car ps-printing-region\)) S
LHL
8 W
(ps-line-spacing-internal      \(ps-get-size ps-line-spacing) S
LHL
51 W
("line spacing"\)) S
LHL
8 W
(ps-paragraph-spacing-internal \(ps-get-size ps-paragraph-spacing) S
LHL
51 W
("paragraph spacing"\)) S
LHL
8 W
(ps-font-size-internal        \(ps-get-font-size 'ps-font-size\)) S
LHL
8 W
(ps-header-font-size-internal \(ps-get-font-size 'ps-header-font-size\)) S
LHL
8 W
(ps-header-title-font-size-internal) S
LHL
8 W
(\(ps-get-font-size 'ps-header-title-font-size\)) S
LHL
8 W
(ps-footer-font-size-internal \(ps-get-font-size 'ps-footer-font-size\)) S
LHL
8 W
(ps-control-or-escape-regexp) S
LHL
8 W
(\(cond \(\(eq ps-print-control-characters '8-bit\)) S
LHL
15 W
(\(string-as-unibyte "[\\000-\\037\\177-\\377]"\)\)) S
LHL
14 W
(\(\(eq ps-print-control-characters 'control-8-bit\)) S
LHL
15 W
(\(string-as-unibyte "[\\000-\\037\\177-\\237]"\)\)) S
LHL
14 W
(\(\(eq ps-print-control-characters 'control\)) S
LHL
15 W
("[\\000-\\037\\177]"\)) S
LHL
14 W
(\(t "[\\t\\n\\f]"\)\)) S
LHL
8 W
(;; Set the color scale.  We do it here instead of in the defvar so) S
LHL
8 W
(;; that ps-print can be dumped into emacs.  This expression can't be) S
LHL
8 W
(;; evaluated at dump-time because X isn't initialized.) S
LHL
8 W
(ps-color-p            \(and ps-print-color-p \(ps-color-device\)\)) S
LHL
8 W
(ps-print-color-scale  \(if ps-color-p) S
LHL
34 W
(\(float \(car \(ps-color-values "white"\)\)\)) S
LHL
32 W
(1.0\)) S
LHL
8 W
(ps-default-background \(ps-rgb-color) S
LHL
31 W
(\(cond) S
LHL
32 W
(\(\(or \(member ps-print-color-p) S
LHL
45 W
('\(nil black-white\)\)) S
LHL
37 W
(\(eq genfunc 'ps-generate-postscript\)\)) S
LHL
33 W
(nil\)) S
LHL
32 W
(\(\(eq ps-default-bg 'frame-parameter\)) S
LHL
33 W
(\(ps-frame-parameter nil 'background-color\)\)) S
LHL
32 W
(\(\(eq ps-default-bg t\)) S
LHL
33 W
(\(ps-face-background-name 'default\)\)) S
LHL
32 W
(\(t) S
LHL
33 W
(ps-default-bg\)\)) S
LHL
31 W
("unspecified-bg") S
LHL
31 W
(1.0\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 85 113
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5842 def
/PageNumber 85 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5843 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
8 W
(ps-default-foreground \(ps-rgb-color) S
LHL
31 W
(\(cond) S
LHL
32 W
(\(\(or \(member ps-print-color-p) S
LHL
45 W
('\(nil black-white\)\)) S
LHL
37 W
(\(eq genfunc 'ps-generate-postscript\)\)) S
LHL
33 W
(nil\)) S
LHL
32 W
(\(\(eq ps-default-fg 'frame-parameter\)) S
LHL
33 W
(\(ps-frame-parameter nil 'foreground-color\)\)) S
LHL
32 W
(\(\(eq ps-default-fg t\)) S
LHL
33 W
(\(ps-face-foreground-name 'default\)\)) S
LHL
32 W
(\(t) S
LHL
33 W
(ps-default-fg\)\)) S
LHL
31 W
("unspecified-fg") S
LHL
31 W
(0.0\)) S
LHL
8 W
(ps-foreground-list    \(mapcar) S
LHL
31 W
(#'\(lambda \(arg\)) S
LHL
35 W
(\(ps-rgb-color arg "unspecified-fg" 0.0\)\)) S
LHL
31 W
(\(append \(and \(not \(member ps-print-color-p) S
LHL
57 W
('\(nil black-white\)\)\)) S
LHL
44 W
(ps-fg-list\)) S
LHL
39 W
(\(list ps-default-foreground) S
LHL
45 W
("black"\)\)\)) S
LHL
8 W
(ps-default-color      \(and \(not \(member ps-print-color-p) S
LHL
48 W
('\(nil black-white\)\)\)) S
LHL
35 W
(ps-default-foreground\)) S
LHL
8 W
(ps-current-color      ps-default-color) S
LHL
8 W
(;; Set up default functions.) S
LHL
8 W
(;; They may be overridden by ps-mule-begin-job.) S
LHL
8 W
(ps-basic-plot-string-function    'ps-basic-plot-string) S
LHL
8 W
(ps-encode-header-string-function nil\)) S
LHL
(  ;; initialize page dimensions) S
LHL
(  \(ps-get-page-dimensions\)) S
LHL
(  ;; final check) S
LHL
(  \(unless \(listp ps-lpr-switches\)) S
LHL
(    \(error "`ps-lpr-switches' value should be a list"\)\)) S
LHL
(  \(and ps-color-p) S
LHL
(       \(equal ps-default-background ps-default-foreground\)) S
LHL
(       \(error) S
LHL
8 W
(\(concat) S
LHL
9 W
("`ps-default-fg' and `ps-default-bg' have the same color.\\n") S
LHL
9 W
("Text won't appear on page.  Please, check these variables."\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-page-number \(\)) S
LHL
(  \(if ps-print-only-one-header) S
LHL
(      \(1+ \(/ \(1- ps-page-column\) ps-number-of-columns\)\)) S
LHL
(    ps-page-column\)\)) S
PHL
PHL
LHL
(\(defsubst ps-end-page \(\)) S
LHL
(  \(ps-output "EndPage\\nEndDSCPage\\n"\)\)) S
PHL
PHL
LHL
(\(defsubst ps-next-page \(\)) S
LHL
(  \(ps-end-page\)) S
LHL
(  \(ps-flush-output\)) S
LHL
(  \(ps-begin-page\)\)) S
PHL
PHL
LHL
(\(defun ps-end-sheet \(\)) S
LHL
(  \(and ps-print-page-p \(> ps-page-sheet 0\)) S
LHL
(       \(ps-output "EndSheet\\n"\)\)\)) S
PHL
PHL
LHL
(\(defun ps-header-sheet \(\)) S
LHL
(  ;; Print only when a new sheet begins.) S
LHL
(  \(ps-end-sheet\)) S
LHL
(  \(setq ps-page-sheet \(1+ ps-page-sheet\)\)) S
LHL
(  \(when \(ps-print-sheet-p\)) S
LHL
(    \(setq ps-page-order \(1+ ps-page-order\)\)) S
LHL
(    \(ps-output \(if ps-n-up-on) S
LHL
19 W
(\(format "\\n%%%%Page: \(%d \\\\\(%d\\\\\)\) %d\\n") S
EndPage
EndDSCPage
EndSheet

%%Page: 86 114
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5914 def
/PageNumber 86 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5915 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
27 W
(ps-page-order ps-page-postscript ps-page-order\)) S
LHL
17 W
(\(format "\\n%%%%Page: %d %d\\n") S
LHL
25 W
(ps-page-postscript ps-page-order\)\)) S
LHL
15 W
(;; spooling needs to redefine Lines and PageCount on each page) S
LHL
15 W
("/Lines 0 def\\n/PageCount 0 def\\n") S
LHL
15 W
(\(format "%d BeginSheet\\nBeginDSCPage\\n") S
LHL
23 W
(ps-n-up-printing\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-header-page \(\)) S
LHL
(  ;; set total line and page number when printing has finished) S
LHL
(  ;; \(see `ps-generate'\)) S
LHL
(  \(if \(zerop \(mod ps-page-column ps-number-of-columns\)\)) S
LHL
(      \(progn) S
LHL
8 W
(\(setq ps-page-postscript \(1+ ps-page-postscript\)\)) S
LHL
8 W
(\(when \(ps-print-page-p\)) S
LHL
10 W
(\(ps-print-sheet-p\)) S
LHL
10 W
(\(if \(zerop \(mod ps-page-n-up ps-n-up-printing\)\)) S
LHL
14 W
(;; Print only when a new sheet begins.) S
LHL
14 W
(\(progn) S
LHL
16 W
(\(ps-header-sheet\)) S
LHL
16 W
(\(run-hooks 'ps-print-begin-sheet-hook\)\)) S
LHL
12 W
(;; Print only when a new page begins.) S
LHL
12 W
(\(ps-output "BeginDSCPage\\n"\)) S
LHL
12 W
(\(run-hooks 'ps-print-begin-page-hook\)\)) S
LHL
10 W
(\(ps-background ps-page-postscript\)) S
LHL
10 W
(\(setq ps-page-n-up \(1+ ps-page-n-up\)\)) S
LHL
10 W
(\(and ps-print-page-p) S
LHL
15 W
(\(setq ps-page-printed \(1+ ps-page-printed\)\)\)\)\)) S
LHL
(    ;; Print only when a new column begins.) S
LHL
(    \(ps-output "BeginDSCPage\\n"\)) S
LHL
(    \(run-hooks 'ps-print-begin-column-hook\)\)) S
LHL
(  \(setq ps-page-column \(1+ ps-page-column\)\)\)) S
PHL
LHL
(\(defun ps-begin-page \(\)) S
LHL
(  \(setq ps-width-remaining  ps-print-width) S
LHL
8 W
(ps-height-remaining ps-print-height\)) S
PHL
LHL
(  \(ps-header-page\)) S
PHL
LHL
(  \(ps-output \(format "/LineNumber %d def\\n" ps-showline-count\)) S
LHL
13 W
(\(format "/PageNumber %d def\\n" \(ps-page-number\)\)\)) S
PHL
LHL
(  \(when ps-print-header) S
LHL
(    \(ps-generate-header "HeaderLinesLeft"  "/h0" "/h1" ps-left-header\)) S
LHL
(    \(ps-generate-header "HeaderLinesRight" "/h0" "/h1" ps-right-header\)) S
LHL
(    \(ps-output \(format "%d SetHeaderLines\\n" ps-header-lines\)\)\)) S
PHL
LHL
(  \(when ps-print-footer) S
LHL
(    \(ps-generate-header "FooterLinesLeft"  "/H0" "/H0" ps-left-footer\)) S
LHL
(    \(ps-generate-header "FooterLinesRight" "/H0" "/H0" ps-right-footer\)) S
LHL
(    \(ps-output \(format "%d SetFooterLines\\n" ps-footer-lines\)\)\)) S
PHL
LHL
(  \(ps-output \(number-to-string ps-lines-printed\) " BeginPage\\n"\)) S
LHL
(  \(ps-set-font  ps-current-font\)) S
LHL
(  \(ps-set-bg    ps-current-bg\)) S
LHL
(  \(ps-set-color ps-current-color\)\)) S
PHL
LHL
(\(defsubst ps-skip-newline \(limit\)) S
LHL
(  \(setq ps-showline-count \(1+ ps-showline-count\)) S
LHL
8 W
(ps-lines-printed  \(1+ ps-lines-printed\)\)) S
LHL
(  \(and \(< \(point\) limit\)) S
LHL
(       \(forward-char 1\)\)\)) S
PHL
LHL
(\(defsubst ps-next-line \(\)) S
LHL
(  \(setq ps-showline-count \(1+ ps-showline-count\)) S
LHL
8 W
(ps-lines-printed  \(1+ ps-lines-printed\)\)) S
LHL
(  \(let* \(\(paragraph-p \(and ps-paragraph-regexp) S
LHL
27 W
(\(looking-at ps-paragraph-regexp\)\)\)) S
LHL
9 W
(\(lh \(+ \(ps-line-height 'ps-font-for-text\)) S
LHL
16 W
(\(if paragraph-p) S
LHL
20 W
(ps-paragraph-spacing-internal) S
EndPage
EndDSCPage
EndSheet

%%Page: 87 115
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 5986 def
/PageNumber 87 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
5987 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
18 W
(ps-line-spacing-internal\)\)\)\)) S
LHL
(    \(if \(< ps-height-remaining lh\)) S
LHL
8 W
(\(ps-next-page\)) S
LHL
(      \(setq ps-width-remaining  ps-print-width) S
LHL
12 W
(ps-height-remaining \(- ps-height-remaining lh\)\)) S
LHL
(      \(ps-output \(if paragraph-p "PHL\\n" "LHL\\n"\)\)\)\)\)) S
PHL
LHL
(\(defun ps-continue-line \(\)) S
LHL
(  \(setq ps-lines-printed \(1+ ps-lines-printed\)\)) S
LHL
(  \(let \(\(lh \(+ \(ps-line-height 'ps-font-for-text\) ps-line-spacing-internal\)\)\)) S
LHL
(    \(if \(< ps-height-remaining lh\)) S
LHL
8 W
(\(ps-next-page\)) S
LHL
(      \(setq ps-width-remaining  ps-print-width) S
LHL
12 W
(ps-height-remaining \(- ps-height-remaining lh\)\)) S
LHL
(      \(ps-output "SL\\n"\)\)\)\)) S
PHL
LHL
(\(defun ps-find-wrappoint \(from to char-width\)) S
LHL
(  \(let \(\(avail \(truncate \(/ ps-width-remaining char-width\)\)\)) S
LHL
8 W
(\(todo \(- to from\)\)\)) S
LHL
(    \(if \(< todo avail\)) S
LHL
8 W
(\(cons to \(* todo char-width\)\)) S
LHL
(      \(cons \(+ from avail\) ps-width-remaining\)\)\)\)) S
PHL
LHL
(\(defun ps-basic-plot-str \(from to string\)) S
LHL
(  \(let* \(\(wrappoint \(ps-find-wrappoint from to) S
LHL
39 W
(\(ps-avg-char-width 'ps-font-for-text\)\)\)) S
LHL
9 W
(\(to \(car wrappoint\)\)) S
LHL
9 W
(\(str \(substring string from to\)\)\)) S
LHL
(    \(ps-output-string str\)) S
LHL
(    \(ps-output " S\\n"\)) S
LHL
(    wrappoint\)\)) S
PHL
LHL
(\(defun ps-basic-plot-string \(from to &optional _bg-color\)) S
LHL
(  \(let* \(\(wrappoint \(ps-find-wrappoint from to) S
LHL
39 W
(\(ps-avg-char-width 'ps-font-for-text\)\)\)) S
LHL
9 W
(\(to \(car wrappoint\)\)) S
LHL
9 W
(\(string \(buffer-substring-no-properties from to\)\)\)) S
LHL
(    \(ps-output-string string\)) S
LHL
(    \(ps-output " S\\n"\)) S
LHL
(    wrappoint\)\)) S
PHL
LHL
(\(defun ps-basic-plot-whitespace \(from to &optional _bg-color\)) S
LHL
(  \(let* \(\(wrappoint \(ps-find-wrappoint from to) S
LHL
39 W
(\(ps-space-width 'ps-font-for-text\)\)\)) S
LHL
9 W
(\(to \(car wrappoint\)\)\)) S
LHL
(    \(ps-output \(format "%d W\\n" \(- to from\)\)\)) S
LHL
(    wrappoint\)\)) S
PHL
LHL
(\(defun ps-plot \(plotfunc from to &optional bg-color\)) S
LHL
(  \(while \(< from to\)) S
LHL
(    \(let* \(\(wrappoint \(funcall plotfunc from to bg-color\)\)) S
LHL
11 W
(\(plotted-to \(car wrappoint\)\)) S
LHL
11 W
(\(plotted-width \(cdr wrappoint\)\)\)) S
LHL
(      \(setq from plotted-to) S
LHL
12 W
(ps-width-remaining \(- ps-width-remaining plotted-width\)\)) S
LHL
(      \(if \(< from to\)) S
LHL
10 W
(\(ps-continue-line\)\)\)\)) S
LHL
(  \(if ps-razzle-dazzle) S
LHL
(      \(let* \(\(q-todo \(- \(point-max\) \(point-min\)\)\)) S
LHL
13 W
(\(q-done \(- \(point\) \(point-min\)\)\)) S
LHL
13 W
(\(chunkfrac \(/ q-todo 8\)\)) S
LHL
13 W
(\(chunksize \(min chunkfrac 1000\)\)\)) S
LHL
8 W
(\(if \(> \(- q-done ps-razchunk\) chunksize\)) S
LHL
12 W
(\(progn) S
LHL
14 W
(\(setq ps-razchunk q-done\)) S
LHL
14 W
(\(message "Formatting...%3d%%") S
LHL
23 W
(\(floor \(* 100.0 q-done\) q-todo\)\)\)\)\)\)\)) S
PHL
LHL
(\(defvar ps-last-font nil\)) S
PHL
LHL
(\(defun ps-set-font \(font\)) S
LHL
(  \(setq ps-last-font \(format "f%d" \(setq ps-current-font font\)\)\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 88 116
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 6058 def
/PageNumber 88 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
6059 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  \(ps-output \(format "/%s F\\n" ps-last-font\)\)\)) S
PHL
LHL
(\(defun ps-set-bg \(color\)) S
LHL
(  \(if \(setq ps-current-bg color\)) S
LHL
(      \(ps-output \(format ps-color-format) S
LHL
25 W
(\(nth 0 color\) \(nth 1 color\) \(nth 2 color\)\)) S
LHL
17 W
(" true BG\\n"\)) S
LHL
(    \(ps-output "false BG\\n"\)\)\)) S
PHL
LHL
(\(defun ps-set-color \(color\)) S
LHL
(  \(setq ps-current-color \(or color ps-default-foreground\)\)) S
LHL
(  \(ps-output \(format ps-color-format) S
LHL
21 W
(\(nth 0 ps-current-color\)) S
LHL
21 W
(\(nth 1 ps-current-color\) \(nth 2 ps-current-color\)\)) S
LHL
13 W
(" FG\\n"\)\)) S
PHL
PHL
LHL
(\(defsubst ps-plot-string \(string\)) S
LHL
(  \(ps-plot 'ps-basic-plot-str 0 \(length string\) string\)\)) S
PHL
PHL
LHL
(\(defvar ps-current-effect 0\)) S
PHL
LHL
(\(defvar ps-print-translation-table) S
LHL
(  \(let \(\(tbl \(make-char-table 'translation-table nil\)\)\)) S
LHL
(    \(if \(and \(boundp 'ucs-mule-8859-to-mule-unicode\)) S
LHL
11 W
(\(char-table-p ucs-mule-8859-to-mule-unicode\)\)) S
LHL
8 W
(\(map-char-table) S
LHL
9 W
(#'\(lambda \(k v\)) S
LHL
13 W
(\(if \(and v \(eq \(char-charset v\) 'latin-iso8859-1\) \(/= k v\)\)) S
LHL
17 W
(\(aset tbl k v\)\)\)) S
LHL
9 W
(ucs-mule-8859-to-mule-unicode\)\)) S
LHL
(    tbl\)) S
LHL
(  "Translation table for PostScript printing.) S
LHL
(The default value is a table that translates non-Latin-1 Latin characters) S
LHL
(to the equivalent Latin-1 characters."\)) S
PHL
LHL
(\(defun ps-plot-region \(from to font &optional fg-color bg-color effects\)) S
LHL
(  \(or \(equal font ps-current-font\)) S
LHL
(      \(ps-set-font font\)\)) S
PHL
LHL
(  ;; Specify a foreground color only if:) S
LHL
(  ;;    one's specified,) S
LHL
(  ;;    it's different than the background \(if `ps-fg-validate-p' is non-nil\)) S
LHL
(  ;;    and it's different than the current.) S
LHL
(  \(let \(\(fg \(or fg-color ps-default-foreground\)\)\)) S
LHL
(    \(if ps-fg-validate-p) S
LHL
8 W
(\(let \(\(bg \(or bg-color ps-default-background\)\)) S
LHL
14 W
(\(el ps-foreground-list\)\)) S
LHL
10 W
(\(while \(and el \(equal fg bg\)\)) S
LHL
12 W
(\(setq fg \(car el\)) S
LHL
18 W
(el \(cdr el\)\)\)\)\)) S
LHL
(    \(or \(equal fg ps-current-color\)) S
LHL
8 W
(\(ps-set-color fg\)\)\)) S
PHL
LHL
(  \(or \(equal bg-color ps-current-bg\)) S
LHL
(      \(ps-set-bg bg-color\)\)) S
PHL
LHL
(  ;; Specify effects \(underline, overline, box, etc.\)) S
LHL
(  \(cond) S
LHL
(   \(\(not \(integerp effects\)\)) S
LHL
(    \(ps-output "0 EF\\n"\)) S
LHL
(    \(setq ps-current-effect 0\)\)) S
LHL
(   \(\(/= effects ps-current-effect\)) S
LHL
(    \(ps-output \(number-to-string effects\) " EF\\n"\)) S
LHL
(    \(setq ps-current-effect effects\)\)\)) S
PHL
LHL
(  ;; Starting at the beginning of the specified region...) S
LHL
(  \(save-excursion) S
LHL
(    \(goto-char from\)) S
PHL
LHL
(    ;; ...break the region up into chunks separated by tabs, linefeeds,) S
EndPage
EndDSCPage
EndSheet

%%Page: 89 117
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 6130 def
/PageNumber 89 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
6131 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(    ;; formfeeds, control characters, and plot each chunk.) S
LHL
(    \(while \(< from to\)) S
LHL
(      ;; skip lines between cut markers) S
LHL
(      \(and ps-begin-cut-regexp ps-end-cut-regexp) S
LHL
11 W
(\(looking-at ps-begin-cut-regexp\)) S
LHL
11 W
(\(progn) S
LHL
13 W
(\(goto-char \(match-end 0\)\)) S
LHL
13 W
(\(and \(re-search-forward ps-end-cut-regexp to 'noerror\)) S
LHL
18 W
(\(= \(following-char\) ?\\n\)) S
LHL
18 W
(\(forward-char 1\)\)) S
LHL
13 W
(\(setq from \(point\)\)\)\)) S
LHL
(      \(if \(re-search-forward ps-control-or-escape-regexp to t\)) S
LHL
10 W
(;; region with some control characters or some multi-byte characters) S
LHL
10 W
(\(let* \(\(match-point \(match-beginning 0\)\)) S
LHL
17 W
(\(match       \(char-after match-point\)\)\)) S
LHL
12 W
(\(when \(< from match-point\)) S
LHL
14 W
(\(ps-plot ps-basic-plot-string-function) S
LHL
23 W
(from match-point bg-color\)\)) S
LHL
12 W
(\(cond) S
LHL
13 W
(\(\(= match ?\\t\)) S
13 W
(; tab) S
LHL
14 W
(\(let \(\(linestart \(line-beginning-position\)\)\)) S
LHL
16 W
(\(forward-char -1\)) S
LHL
16 W
(\(setq from \(+ linestart \(current-column\)\)\)) S
LHL
16 W
(\(when \(re-search-forward "[ \\t]+" to t\)) S
LHL
18 W
(\(ps-plot 'ps-basic-plot-whitespace) S
LHL
27 W
(from \(+ linestart \(current-column\)\)) S
LHL
27 W
(bg-color\)\)\)\)) S
PHL
LHL
13 W
(\(\(= match ?\\n\)) S
13 W
(; newline) S
LHL
14 W
(\(if \(looking-at "\\f[^\\n]"\)) S
LHL
18 W
(;; \\n\\ftext\\n ==>> next page, but keep line counting!!) S
LHL
18 W
(\(progn) S
LHL
20 W
(\(ps-skip-newline to\)) S
LHL
20 W
(\(ps-next-page\)\)) S
LHL
16 W
(;; \\n\\f\\n     ==>> it'll be handled by form feed) S
LHL
16 W
(;; \\ntext\\n   ==>> next line) S
LHL
16 W
(\(ps-next-line\)\)\)) S
PHL
LHL
13 W
(\(\(= match ?\\f\)) S
13 W
(; form feed) S
LHL
14 W
(;; do not skip page if previous character is NEWLINE and) S
LHL
14 W
(;; it is a beginning of page.) S
LHL
14 W
(\(unless \(and \(equal \(char-after \(1- match-point\)\) ?\\n\)) S
LHL
27 W
(\(= ps-height-remaining ps-print-height\)\)) S
LHL
16 W
(;; \\f\\n ==>> skip \\n, but keep line counting!!) S
LHL
16 W
(\(and \(equal \(following-char\) ?\\n\)) S
LHL
21 W
(\(ps-skip-newline to\)\)) S
LHL
16 W
(\(ps-next-page\)\)\)) S
PHL
LHL
13 W
(\(t) S
25 W
(; characters from 127 to 255) S
LHL
14 W
(\(ps-control-character match\)\)\)) S
LHL
12 W
(\(setq from \(point\)\)\)) S
LHL
8 W
(;; region without control characters) S
LHL
8 W
(\(ps-plot ps-basic-plot-string-function from to bg-color\)) S
LHL
8 W
(\(setq from to\)\)\)\)\)) S
PHL
LHL
(\(defvar ps-string-control-codes) S
LHL
(  \(let \(\(table \(make-vector 256 nil\)\)) S
LHL
8 W
(\(char ?\\000\)\)) S
LHL
(    ;; control character) S
LHL
(    \(while \(<= char ?\\037\)) S
LHL
(      \(aset table char \(format "^%c" \(+ char ?@\)\)\)) S
LHL
(      \(setq char \(1+ char\)\)\)) S
LHL
(    ;; printable character) S
LHL
(    \(while \(< char ?\\177\)) S
LHL
(      \(aset table char \(format "%c" char\)\)) S
LHL
(      \(setq char \(1+ char\)\)\)) S
LHL
(    ;; DEL) S
LHL
(    \(aset table char "^?"\)) S
LHL
(    ;; 8-bit character) S
LHL
(    \(while \(<= \(setq char \(1+ char\)\) ?\\377\)) S
LHL
(      \(aset table char \(format "\\\\%o" char\)\)\)) S
LHL
(    table\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 90 118
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 6202 def
/PageNumber 90 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
6203 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(  "Vector used to map characters to a printable string."\)) S
PHL
LHL
(\(defun ps-control-character \(char\)) S
LHL
(  \(let* \(\(str \(aref ps-string-control-codes char\)\)) S
LHL
9 W
(\(from \(1- \(point\)\)\)) S
LHL
9 W
(\(len \(length str\)\)) S
LHL
9 W
(\(to \(+ from len\)\)) S
LHL
9 W
(\(char-width \(ps-avg-char-width 'ps-font-for-text\)\)) S
LHL
9 W
(\(wrappoint \(ps-find-wrappoint from to char-width\)\)\)) S
LHL
(    \(if \(< \(car wrappoint\) to\)) S
LHL
8 W
(\(ps-continue-line\)\)) S
LHL
(    \(setq ps-width-remaining \(- ps-width-remaining \(* len char-width\)\)\)) S
LHL
(    \(ps-output-string str\)) S
LHL
(    \(ps-output " S\\n"\)\)\)) S
PHL
PHL
LHL
(\(defsubst ps-face-foreground-color-p \(attr\)) S
LHL
(  \(memq attr '\(foreground-color :foreground\)\)\)) S
PHL
PHL
LHL
(\(defsubst ps-face-background-color-p \(attr\)) S
LHL
(  \(memq attr '\(background-color :background\)\)\)) S
PHL
PHL
LHL
(\(defsubst ps-face-color-p \(attr\)) S
LHL
(  \(memq attr '\(foreground-color :foreground background-color :background\)\)\)) S
PHL
PHL
LHL
(\(defun ps-face-extract-color \(face-attrs\)) S
LHL
(  \(let \(\(color \(cdr face-attrs\)\)\)) S
LHL
(    \(if \(listp color\)) S
LHL
8 W
(\(car color\)) S
LHL
(      color\)\)\)) S
PHL
PHL
LHL
(\(defun ps-face-attributes \(face\)) S
LHL
(  "Return face attribute vector.) S
PHL
LHL
(If FACE is not in `ps-print-face-extension-alist' or in) S
LHL
(`ps-print-face-alist', insert it on `ps-print-face-alist' and) S
LHL
(return the attribute vector.) S
PHL
LHL
(If FACE is not a valid face name, use default face.") S
LHL
(  \(and \(stringp face\) \(facep face\) \(setq face \(intern face\)\)\)) S
LHL
(  \(cond) S
LHL
(   \(ps-black-white-faces-alist) S
LHL
(    \(or \(and \(symbolp face\)) S
LHL
13 W
(\(cdr \(assq face ps-black-white-faces-alist\)\)\)) S
LHL
8 W
(\(vector 0 nil nil\)\)\)) S
LHL
(   \(\(symbolp face\)) S
LHL
(    \(cdr \(or \(assq face ps-print-face-extension-alist\)) S
LHL
13 W
(\(assq face ps-print-face-alist\)) S
LHL
13 W
(\(let* \(\(the-face \(if \(facep face\) face 'default\)\)) S
LHL
20 W
(\(new-face \(ps-screen-to-bit-face the-face\)\)\)) S
LHL
15 W
(\(or \(and \(eq the-face 'default\)) S
LHL
24 W
(\(assq the-face ps-print-face-alist\)\)) S
LHL
19 W
(\(setq ps-print-face-alist) S
LHL
25 W
(\(cons new-face ps-print-face-alist\)\)\)) S
LHL
15 W
(new-face\)\)\)\)) S
LHL
(   \(\(ps-face-foreground-color-p \(car face\)\)) S
LHL
(    \(vector 0 \(ps-face-extract-color face\) nil\)\)) S
LHL
(   \(\(ps-face-background-color-p \(car face\)\)) S
LHL
(    \(vector 0 nil \(ps-face-extract-color face\)\)\)) S
LHL
(   \(t) S
LHL
(    \(vector 0 nil nil\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-face-background \(face background\)) S
LHL
(  \(and \(cond \(\(eq ps-use-face-background t\)\)) S
5 W
(; always) S
LHL
13 W
(\(\(null ps-use-face-background\) nil\) ; never) S
LHL
13 W
(;; ps-user-face-background is a symbol face list) S
LHL
13 W
(\(\(symbolp face\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 91 119
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 6274 def
/PageNumber 91 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
6275 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
14 W
(\(memq face ps-use-face-background\)\)) S
LHL
13 W
(\(\(listp face\)) S
LHL
14 W
(\(or \(ps-face-color-p \(car face\)\)) S
LHL
18 W
(\(let \(ok\)) S
LHL
20 W
(\(while face) S
LHL
22 W
(\(if \(or \(memq \(car face\) ps-use-face-background\)) S
LHL
30 W
(\(ps-face-color-p \(car face\)\)\)) S
LHL
26 W
(\(setq face nil) S
LHL
32 W
(ok   t\)) S
LHL
24 W
(\(setq face \(cdr face\)\)\)\)) S
LHL
20 W
(ok\)\)\)) S
LHL
13 W
(\(t) S
LHL
14 W
(nil\)) S
LHL
13 W
(\)) S
LHL
(       background\)\)) S
PHL
PHL
LHL
(\(defun ps-face-attribute-list \(face-or-list\)) S
LHL
(  \(cond) S
LHL
(   ;; simple face) S
LHL
(   \(\(not \(listp face-or-list\)\)) S
LHL
(    \(ps-face-attributes face-or-list\)\)) S
LHL
(   ;; only foreground color, not a `real' face) S
LHL
(   \(\(ps-face-foreground-color-p \(car face-or-list\)\)) S
LHL
(    \(vector 0 \(ps-face-extract-color face-or-list\) nil\)\)) S
LHL
(   ;; only background color, not a `real' face) S
LHL
(   \(\(ps-face-background-color-p \(car face-or-list\)\)) S
LHL
(    \(vector 0 nil \(ps-face-extract-color face-or-list\)\)\)) S
LHL
(   ;; Anonymous face.) S
LHL
(   \(\(keywordp \(car face-or-list\)\)) S
LHL
(    \(vector 0 \(plist-get face-or-list :foreground\)) S
LHL
12 W
(\(plist-get face-or-list :background\)\)\)) S
LHL
(   ;; list of faces) S
LHL
(   \(t) S
LHL
(    \(let \(\(effects 0\)) S
LHL
10 W
(foreground background face-attr face\)) S
LHL
(      \(while face-or-list) S
LHL
8 W
(\(setq face         \(car face-or-list\)) S
LHL
14 W
(face-or-list \(cdr face-or-list\)) S
LHL
14 W
(face-attr    \(ps-face-attributes face\)) S
LHL
14 W
(effects      \(logior effects \(aref face-attr 0\)\)\)) S
LHL
8 W
(\(or foreground \(setq foreground \(aref face-attr 1\)\)\)) S
LHL
8 W
(\(or background) S
LHL
12 W
(\(setq background \(ps-face-background face \(aref face-attr 2\)\)\)\)\)) S
LHL
(      \(vector effects foreground background\)\)\)\)\)) S
PHL
PHL
LHL
(\(defconst ps-font-type \(vector nil 'bold 'italic 'bold-italic\)\)) S
PHL
PHL
LHL
(\(defun ps-plot-with-face \(from to face\)) S
LHL
(  \(cond) S
LHL
(   \(\(null face\)) S
25 W
(; print text with null face) S
LHL
(    \(ps-plot-region from to 0\)\)) S
LHL
(   \(\(eq face 'emacs--invisible--face\)\)) S
2 W
(; skip invisible text!!!) S
LHL
(   \(t) S
35 W
(; otherwise, text has a valid face) S
LHL
(    \(let* \(\(face-bit   \(ps-face-attribute-list face\)\)) S
LHL
11 W
(\(effect     \(aref face-bit 0\)\)) S
LHL
11 W
(\(foreground \(aref face-bit 1\)\)) S
LHL
11 W
(\(background \(ps-face-background face \(aref face-bit 2\)\)\)) S
LHL
11 W
(\(fg-color \(if \(and ps-color-p foreground\)) S
LHL
25 W
(\(ps-color-scale foreground\)) S
LHL
23 W
(ps-default-color\)\)) S
LHL
11 W
(\(bg-color \(and ps-color-p background) S
LHL
26 W
(\(ps-color-scale background\)\)\)\)) S
LHL
(      \(ps-plot-region) S
LHL
(       from to) S
LHL
(       \(ps-font-number 'ps-font-for-text) S
LHL
23 W
(\(or \(aref ps-font-type \(logand effect 3\)\)) S
LHL
27 W
(face\)\)) S
LHL
(       fg-color bg-color \(lsh effect -2\)\)\)\)\)) S
LHL
(  \(goto-char to\)\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 92 120
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 6346 def
/PageNumber 92 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
6347 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
PHL
LHL
(;; Ensure that face-list is fbound.) S
LHL
(\(or \(fboundp 'face-list\) \(defalias 'face-list 'list-faces\)\)) S
PHL
PHL
LHL
(\(defun ps-build-reference-face-lists \(\)) S
LHL
(  ;; Ensure that face database is updated with faces on) S
LHL
(  ;; `font-lock-face-attributes' \(obsolete stuff\)) S
LHL
(  \(ps-font-lock-face-attributes\)) S
LHL
(  ;; Now, rebuild reference face lists) S
LHL
(  \(setq ps-print-face-alist nil\)) S
LHL
(  \(if ps-auto-font-detect) S
LHL
(      \(mapc 'ps-map-face \(face-list\)\)) S
LHL
(    \(mapc 'ps-set-face-bold ps-bold-faces\)) S
LHL
(    \(mapc 'ps-set-face-italic ps-italic-faces\)) S
LHL
(    \(mapc 'ps-set-face-underline ps-underlined-faces\)\)) S
LHL
(  \(setq ps-build-face-reference nil\)\)) S
PHL
PHL
LHL
(\(defun ps-set-face-bold \(face\)) S
LHL
(  \(ps-set-face-attribute face 1\)\)) S
PHL
LHL
(\(defun ps-set-face-italic \(face\)) S
LHL
(  \(ps-set-face-attribute face 2\)\)) S
PHL
LHL
(\(defun ps-set-face-underline \(face\)) S
LHL
(  \(ps-set-face-attribute face 4\)\)) S
PHL
PHL
LHL
(\(defun ps-set-face-attribute \(face effect\)) S
LHL
(  \(let \(\(face-bit \(cdr \(ps-map-face face\)\)\)\)) S
LHL
(    \(aset face-bit 0 \(logior \(aref face-bit 0\) effect\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-map-face \(face\)) S
LHL
(  \(let* \(\(face-map \(ps-screen-to-bit-face face\)\)) S
LHL
9 W
(\(ps-face-bit \(cdr \(assq \(car face-map\) ps-print-face-alist\)\)\)\)) S
LHL
(    \(if ps-face-bit) S
LHL
8 W
(;; if face exists, merge both) S
LHL
8 W
(\(let \(\(face-bit \(cdr face-map\)\)\)) S
LHL
10 W
(\(aset ps-face-bit 0 \(logior \(aref ps-face-bit 0\) \(aref face-bit 0\)\)\)) S
LHL
10 W
(\(or \(aref ps-face-bit 1\) \(aset ps-face-bit 1 \(aref face-bit 1\)\)\)) S
LHL
10 W
(\(or \(aref ps-face-bit 2\) \(aset ps-face-bit 2 \(aref face-bit 2\)\)\)\)) S
LHL
(      ;; if face does not exist, insert it) S
LHL
(      \(setq ps-print-face-alist \(cons face-map ps-print-face-alist\)\)\)) S
LHL
(    face-map\)\)) S
PHL
PHL
LHL
(\(defun ps-screen-to-bit-face \(face\)) S
LHL
(  \(cons face) S
LHL
8 W
(\(vector \(logior \(if \(ps-face-bold-p face\)       1 0\)  ; bold) S
LHL
24 W
(\(if \(ps-face-italic-p face\)     2 0\)  ; italic) S
LHL
24 W
(\(if \(ps-face-underlined-p face\) 4 0\)  ; underline) S
LHL
24 W
(\(if \(ps-face-strikeout-p face\)  8 0\)  ; strikeout) S
LHL
24 W
(\(if \(ps-face-overline-p face\)  16 0\)  ; overline) S
LHL
24 W
(\(if \(ps-face-box-p face\)       64 0\)\) ; box) S
LHL
16 W
(\(ps-face-foreground-name face\)) S
LHL
16 W
(\(ps-face-background-name face\)\)\)\)) S
PHL
PHL
LHL
(\(declare-function jit-lock-fontify-now "jit-lock" \(&optional start end\)\)) S
LHL
(\(declare-function lazy-lock-fontify-region "lazy-lock" \(beg end\)\)) S
PHL
LHL
(;; to avoid compilation gripes) S
LHL
(\(defun ps-print-ensure-fontified \(start end\)) S
LHL
(  \(cond \(\(and \(boundp 'jit-lock-mode\) \(symbol-value 'jit-lock-mode\)\)) S
LHL
9 W
(\(jit-lock-fontify-now start end\)\)) S
LHL
8 W
(\(\(and \(boundp 'lazy-lock-mode\) \(symbol-value 'lazy-lock-mode\)\)) S
LHL
9 W
(\(lazy-lock-fontify-region start end\)\)\)\)) S
PHL
PHL
EndPage
EndDSCPage
EndSheet

%%Page: 93 121
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 6418 def
/PageNumber 93 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
6419 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(\(defun ps-generate-postscript-with-faces \(from to\)) S
LHL
(  ;; Some initialization...) S
LHL
(  \(setq ps-current-effect 0\)) S
PHL
LHL
(  ;; Build the reference lists of faces if necessary.) S
LHL
(  \(when \(or ps-always-build-face-reference) S
LHL
12 W
(ps-build-face-reference\)) S
LHL
(    \(message "Collecting face information..."\)) S
LHL
(    \(ps-build-reference-face-lists\)\)) S
PHL
LHL
(  ;; Black/white printer.) S
LHL
(  \(setq ps-black-white-faces-alist nil\)) S
LHL
(  \(and \(eq ps-print-color-p 'black-white\)) S
LHL
(       \(ps-extend-face-list ps-black-white-faces nil) S
LHL
28 W
('ps-black-white-faces-alist\)\)) S
PHL
LHL
(  ;; Generate some PostScript.) S
LHL
(  \(save-restriction) S
LHL
(    \(narrow-to-region from to\)) S
LHL
(    \(ps-print-ensure-fontified from to\)) S
LHL
(    \(deactivate-mark\)                   ;bug#16866.) S
LHL
(    \(ps-generate-postscript-with-faces1 from to\)\)\)) S
PHL
LHL
(\(defun ps-generate-postscript \(from to\)) S
LHL
(  \(ps-plot-region from to 0\)\)) S
PHL
LHL
(;; These are autoloaded, but ps-mule generates autoloads at the end of) S
LHL
(;; this file, so they are unknown at this point when compiling.) S
LHL
(\(declare-function ps-mule-initialize "ps-mule" \(\)\)) S
LHL
(\(declare-function ps-mule-begin-job  "ps-mule" \(from to\)\)) S
LHL
(\(declare-function ps-mule-end-job    "ps-mule" \(\)\)) S
PHL
LHL
(\(defun ps-generate \(buffer from to genfunc\)) S
LHL
(  \(save-excursion) S
LHL
(    \(let \(\(from \(min to from\)\)) S
LHL
10 W
(\(to \(max to from\)\)) S
LHL
10 W
(;; This avoids trouble if chars with read-only properties) S
LHL
10 W
(;; are copied into ps-spool-buffer.) S
LHL
10 W
(\(inhibit-read-only t\)\)) S
LHL
(      \(save-restriction) S
LHL
8 W
(\(narrow-to-region from to\)) S
LHL
8 W
(\(and ps-razzle-dazzle) S
LHL
13 W
(\(message "Formatting...%3d%%" \(setq ps-razchunk 0\)\)\)) S
LHL
8 W
(\(setq ps-source-buffer buffer) S
LHL
14 W
(ps-spool-buffer \(get-buffer-create ps-spool-buffer-name\)\)) S
LHL
8 W
(\(ps-init-output-queue\)) S
LHL
8 W
(\(let \(safe-marker completed-safely needs-begin-file\)) S
LHL
10 W
(\(unwind-protect) S
LHL
14 W
(\(progn) S
LHL
16 W
(\(set-buffer ps-spool-buffer\)) S
LHL
16 W
(\(set-buffer-multibyte nil\)) S
PHL
LHL
16 W
(;; Get a marker and make it point to the current end of the) S
LHL
16 W
(;; buffer,  If an error occurs, we'll delete everything from) S
LHL
16 W
(;; the end of this marker onwards.) S
LHL
16 W
(\(setq safe-marker \(make-marker\)\)) S
LHL
16 W
(\(set-marker safe-marker \(point-max\)\)) S
PHL
LHL
16 W
(\(goto-char \(point-min\)\)) S
LHL
16 W
(\(or \(looking-at \(regexp-quote ps-adobe-tag\)\)) S
LHL
20 W
(\(setq needs-begin-file t\)\)) S
PHL
LHL
16 W
(\(set-buffer ps-source-buffer\)) S
LHL
16 W
(\(save-excursion) S
LHL
18 W
(\(let \(\(ps-print-page-p t\)) S
LHL
24 W
(ps-even-or-odd-pages\)) S
LHL
20 W
(\(ps-begin-job genfunc\)) S
LHL
20 W
(\(when needs-begin-file) S
LHL
22 W
(\(ps-begin-file\)) S
LHL
22 W
(\(ps-mule-initialize\)\)) S
LHL
20 W
(\(ps-mule-begin-job from to\)) S
LHL
20 W
(\(ps-selected-pages\)\)\)) S
EndPage
EndDSCPage
EndSheet

%%Page: 94 122
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 6490 def
/PageNumber 94 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
6491 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
16 W
(\(ps-begin-page\)) S
LHL
16 W
(\(funcall genfunc from to\)) S
LHL
16 W
(\(ps-end-page\)) S
LHL
16 W
(\(ps-mule-end-job\)) S
LHL
16 W
(\(ps-end-job needs-begin-file\)) S
PHL
LHL
16 W
(;; Setting this variable tells the unwind form that the) S
LHL
16 W
(;; the PostScript was generated without error.) S
LHL
16 W
(\(setq completed-safely t\)\)) S
PHL
LHL
12 W
(;; Unwind form: If some bad mojo occurred while generating) S
LHL
12 W
(;; PostScript, delete all the PostScript that was generated.) S
LHL
12 W
(;; This protects the previously spooled files from getting) S
LHL
12 W
(;; corrupted.) S
LHL
12 W
(\(and \(markerp safe-marker\) \(not completed-safely\)) S
LHL
17 W
(\(progn) S
LHL
19 W
(\(set-buffer ps-spool-buffer\)) S
LHL
19 W
(\(delete-region \(marker-position safe-marker\) \(point-max\)\)\)\)\)\)) S
PHL
LHL
8 W
(\(and ps-razzle-dazzle \(message "Formatting...done"\)\)\)\)\)\)) S
PHL
PHL
LHL
(\(defun ps-end-job \(needs-begin-file\)) S
LHL
(  \(let \(\(ps-print-page-p t\)\)) S
LHL
(    \(ps-flush-output\)) S
LHL
(    \(save-excursion) S
LHL
(      \(let \(\(pages-per-sheet \(mod ps-page-printed ps-n-up-printing\)\)) S
LHL
12 W
(\(total-lines \(cdr ps-printing-region\)\)) S
LHL
12 W
(\(total-pages \(ps-page-number\)\)\)) S
LHL
8 W
(\(set-buffer ps-spool-buffer\)) S
LHL
8 W
(\(let \(case-fold-search\)) S
LHL
10 W
(;; Back to the PS output buffer to set the last page n-up printing) S
LHL
10 W
(\(goto-char \(point-max\)\)) S
LHL
10 W
(\(and \(> pages-per-sheet 0\)) S
LHL
15 W
(\(re-search-backward "^[0-9]+ BeginSheet$" nil t\)) S
LHL
15 W
(\(replace-match \(format "%d BeginSheet" pages-per-sheet\) t\)\)) S
LHL
10 W
(;; Back to the PS output buffer to set the page count) S
LHL
10 W
(\(goto-char \(point-min\)\)) S
LHL
10 W
(\(while \(re-search-forward "^/Lines 0 def\\n/PageCount 0 def$" nil t\)) S
LHL
12 W
(\(replace-match \(format "/Lines %d def\\n/PageCount %d def") S
LHL
35 W
(total-lines total-pages\) t\)\)\)\)\)) S
LHL
(    ;; Set dummy page) S
LHL
(    \(and ps-spool-duplex \(= \(mod ps-page-order 2\) 1\)) S
LHL
9 W
(\(let \(\(ps-n-up-printing 0\)\)) S
LHL
11 W
(\(ps-header-sheet\)) S
LHL
11 W
(\(ps-output "/PrintHeader false def\\n/ColumnIndex 0 def\\n") S
LHL
22 W
("/PrintLineNumber false def\\n") S
LHL
22 W
(\(number-to-string ps-lines-printed\) " BeginPage\\n"\)) S
LHL
11 W
(\(ps-end-page\)\)\)) S
LHL
(    ;; Set end of PostScript file) S
LHL
(    \(ps-end-sheet\)) S
LHL
(    \(ps-output "\\n%%Trailer\\n%%Pages: ") S
LHL
15 W
(\(number-to-string) S
LHL
16 W
(\(if \(and needs-begin-file) S
LHL
25 W
(ps-banner-page-when-duplexing\)) S
LHL
20 W
(\(1+ ps-page-order\)) S
LHL
18 W
(ps-page-order\)\)) S
LHL
15 W
("\\n\\nEndDoc\\n\\n%%EOF\\n"\)) S
LHL
(    \(and ps-end-with-control-d) S
LHL
9 W
(\(ps-output "\\C-d"\)\)) S
LHL
(    \(ps-flush-output\)\)) S
LHL
(  ;; disable selected pages) S
LHL
(  \(setq ps-selected-pages nil\)\)) S
PHL
PHL
LHL
(;; Permit dynamic evaluation at print time of `ps-lpr-switches'.) S
LHL
(\(defun ps-do-despool \(filename\)) S
LHL
(  \(if \(or \(not \(boundp 'ps-spool-buffer\)\)) S
LHL
10 W
(\(not \(symbol-value 'ps-spool-buffer\)\)\)) S
LHL
(      \(message "No spooled PostScript to print"\)) S
LHL
(    \(if filename) S
LHL
8 W
(\(save-excursion) S
EndPage
EndDSCPage
EndSheet

%%Page: 95 123
/Lines 6596 def
/PageCount 95 def
1 BeginSheet
BeginDSCPage
/LineNumber 6562 def
/PageNumber 95 def
/HeaderLinesLeft[
 [/h0 (ps-print.el.gz)]
 [/h1 (/usr/local/share/emacs/26.1/lisp/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
6563 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
10 W
(\(and ps-razzle-dazzle \(message "Saving..."\)\)) S
LHL
10 W
(\(set-buffer ps-spool-buffer\)) S
LHL
10 W
(\(setq filename \(expand-file-name filename\)\)) S
LHL
10 W
(\(let \(\(coding-system-for-write 'raw-text-unix\)\)) S
LHL
12 W
(\(write-region \(point-min\) \(point-max\) filename\)\)) S
LHL
10 W
(\(and ps-razzle-dazzle \(message "Wrote %s" filename\)\)\)) S
LHL
(      ;; Else, spool to the printer) S
LHL
(      \(with-current-buffer ps-spool-buffer) S
LHL
8 W
(\(let* \(\(coding-system-for-write 'raw-text-unix\)) S
LHL
15 W
(\(printer-name \(or ps-printer-name printer-name\)\)) S
LHL
(               \(lpr-printer-switch ps-printer-name-option\)) S
LHL
(               \(print-region-function ps-print-region-function\)) S
LHL
(               \(lpr-command ps-lpr-command\)\)) S
LHL
(          \(lpr-print-region \(point-min\) \(point-max\) ps-lpr-switches nil\)\)\)\)) S
LHL
(    \(kill-buffer ps-spool-buffer\)\)\)) S
PHL
LHL
(\(defun ps-kill-emacs-check \(\)) S
LHL
(  \(let \(\(ps-buffer \(get-buffer ps-spool-buffer-name\)\)\)) S
LHL
(    \(and \(buffer-live-p ps-buffer\)) S
LHL
9 W
(\(buffer-modified-p ps-buffer\)) S
LHL
9 W
(\(y-or-n-p "Unprinted PostScript waiting; print now? "\)) S
LHL
9 W
(\(ps-despool\)\)\)) S
LHL
(  \(let \(\(ps-buffer \(get-buffer ps-spool-buffer-name\)\)\)) S
LHL
(    \(and \(buffer-live-p ps-buffer\)) S
LHL
9 W
(\(buffer-modified-p ps-buffer\)) S
LHL
9 W
(\(not \(yes-or-no-p "Unprinted PostScript waiting; exit anyway? "\)\)) S
LHL
9 W
(\(error "Unprinted PostScript"\)\)\)\)) S
PHL
LHL
(\(unless noninteractive) S
LHL
(  \(add-hook 'kill-emacs-hook #'ps-kill-emacs-check\)\)) S
PHL
LHL
(\(provide 'ps-print\)) S
PHL
LHL
(;;; ps-print.el ends here) S
PHL
EndPage
EndDSCPage
EndSheet


%%Page: 1 124
/Lines 262 def
/PageCount 4 def
1 BeginSheet
BeginDSCPage
/LineNumber 1 def
/PageNumber 1 def
/HeaderLinesLeft[
 [/h0 (digsim.lhs)]
 [/h1 (/mnt/c/Users/FordRL/Documents/2019/03-04/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
0 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
0 EF
(Digsim Build5 --- Bouncing ball) S
LHL
(===============================) S
PHL
LHL
(This models a bouncing ball.) S
PHL
LHL
(> import Numeric         \(showFFloat\)) S
LHL
(> import Data.List       \(sortBy,intercalate\)) S
LHL
(> import Data.List.Split \(splitOn,splitWhen\)) S
LHL
(> import Data.Ord        \(comparing\)) S
LHL
(> import Data.Char       \(toLower\)) S
PHL
LHL
(> main :: IO \(\)) S
LHL
(> main = do inputs <- readFile "input.dat") S
LHL
(>           mapM_ output $ digsim inputs) S
LHL
(>   where output ? = writeFile \(_output ?\) \(_result ?\)) S
PHL
LHL
(> digsim :: String -> [?]) S
LHL
(> digsim = map driver . configurations) S
PHL
LHL
(> driver :: ? -> ?) S
LHL
(> driver =  step . calc . initialize . setup_driver . set_defaults) S
LHL
(>   where redo \(b,?\) = if b then differential_equations ? else ?) S
LHL
(>         step = until _done \(calc . advance_states\)) S
LHL
(>         calc = redo . process_events . differential_equations) S
PHL
LHL
(> type State  = Float -> ? -> ?) S
LHL
(> type States = [State]) S
PHL
LHL
(> data Event = Event { _etime :: Float) S
LHL
(>                    , _ename :: String) S
LHL
(>                    , _efunc :: ? -> ?) S
LHL
(>                    }) S
LHL
(> type Events   = [Event]) S
LHL
(> instance Show Event where show event  = show \(_etime event\) ++ " " ++ show \(_ename event\)) S
PHL
LHL
(> type SetCards = [\(String,String\)]) S
LHL
(> type PrnCards = [String]) S
LHL
(> prncmd :: ? -> String -> String) S
LHL
(> prncmd ? var = case common ? var "" of) S
LHL
(>                  Just \(a,_\)  -> showFFloat \(Just 6\) \(a ?\) "") S
LHL
(>                  Nothing -> "Error: no variable " ++ var ++ ".") S
PHL
LHL
(> setcmd :: ? -> \(String,String\) -> ?) S
LHL
(> setcmd ? \(key,val\) = case common ? key val of) S
LHL
(>                      Just \(_,a\)  -> a) S
LHL
(>                      Nothing -> ?) S
LHL
(> data ? = ?) S
LHL
(>   { _jobno               :: Int       -- Current job number \(starts at 1\)) S
LHL
(>   , _runno               :: Int       -- Current run number \(starts at 1\)) S
LHL
(>   , _result              :: String    -- Simulation results) S
LHL
(>   , _output              :: String    -- Output file name) S
LHL
(>   , _sets                :: SetCards  -- List of SET commands) S
LHL
(>   , _prints              :: PrnCards  -- List of PRINT commands) S
LHL
(>   , _states              :: States    -- List of states to advance) S
LHL
(>   , _events              :: Events    -- Event queue) S
LHL
(>   , _recalc              :: Bool      -- Flag to recalculate differential equation) S
LHL
(>   , _done                :: Bool      -- Simulation complete flag) S
LHL
(>   , _time                :: Float     -- Simulation time [sec]) S
LHL
(>   , _time0               :: Float     -- Simulation start time [sec]) S
LHL
(>   , _tstop               :: Float     -- Simulation stop time [sec]) S
LHL
(>   , _dt                  :: Float     -- Simulation time step [sec]) S
LHL
(>   , _dtmax               :: Float     -- Simulation time step [sec]) S
LHL
(>   , _dtmin               :: Float     -- Simulation time step [sec]) S
LHL
(>   , _dtprint             :: Float     -- Print interval [sec]) S
LHL
(>   , _coef_of_restitution :: Float     -- Coefficent of restitution [Real]") S
LHL
(>   , _gravity             :: Float     -- Acceleration due to gravity [m/sec**2]) S
LHL
(>   , _x_ic                :: Float     -- Initial position of ball [m]) S
LHL
(>   , _xd_ic               :: Float     -- Initial velocity of ball [m/sec]) S
LHL
(>   , _x                   :: Float     -- Position of ball [m]) S
LHL
(>   , _xd                  :: Float     -- Velocity of ball [m/sec]) S
LHL
(>   , _xdd                 :: Float     -- Acceleration of ball [m/sec**2]) S
LHL
(>   }) S
EndPage
EndDSCPage
EndSheet

%%Page: 2 125
/Lines 262 def
/PageCount 4 def
1 BeginSheet
BeginDSCPage
/LineNumber 73 def
/PageNumber 2 def
/HeaderLinesLeft[
 [/h0 (digsim.lhs)]
 [/h1 (/mnt/c/Users/FordRL/Documents/2019/03-04/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
72 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
LHL
(> common :: ? -> String -> String -> Maybe \(? -> Float, ?\)) S
LHL
(> common ? var val = lookup var) S
LHL
(>   [ \("tstop"               , \( _tstop                , ? { _tstop               = read val }\) \)) S
LHL
(>   , \("time"                , \( _time                 , ? { _time                = read val }\) \)) S
LHL
(>   , \("time0"               , \( _time0                , ? { _time0               = read val }\) \)) S
LHL
(>   , \("tstop"               , \( _tstop                , ? { _tstop               = read val }\) \)) S
LHL
(>   , \("dt"                  , \( _dt                   , ? { _dt                  = read val }\) \)) S
LHL
(>   , \("dtmax"               , \( _dtmax                , ? { _dtmax               = read val }\) \)) S
LHL
(>   , \("dtmin"               , \( _dtmin                , ? { _dtmin               = read val }\) \)) S
LHL
(>   , \("dtprint"             , \( _dtprint              , ? { _dtprint             = read val }\) \)) S
LHL
(>   , \("coef_of_restitution" , \( _coef_of_restitution  , ? { _coef_of_restitution = read val }\) \)) S
LHL
(>   , \("gravity"             , \( _gravity              , ? { _gravity             = read val }\) \)) S
LHL
(>   , \("x_ic"                , \( _x_ic                 , ? { _x_ic                = read val }\) \)) S
LHL
(>   , \("xd_ic"               , \( _xd_ic                , ? { _xd_ic               = read val }\) \)) S
LHL
(>   , \("x"                   , \( _x                    , ? { _x                   = read val }\) \)) S
LHL
(>   , \("xd"                  , \( _xd                   , ? { _xd                  = read val }\) \)) S
LHL
(>   ]) S
PHL
LHL
(> advance_states :: ? -> ?) S
LHL
(> advance_states ?@\(? { _time   = time) S
LHL
(>                     , _dt     = dt) S
LHL
(>                     , _states = states) S
LHL
(>                     }\)) S
LHL
(>   = euler { _time = time + dt }) S
LHL
(>   where euler = foldl \(\\?' f -> f dt ?'\) ? states) S
PHL
LHL
(> terminate :: ? -> ?) S
LHL
(> terminate ? = ? { _done = True }) S
PHL
LHL
(> schedule :: Events -> Event -> Events) S
LHL
(> schedule events event = sortBy \(comparing _etime\) \(event:events\)) S
PHL
LHL
(> process_events :: ? -> \(Bool, ?\)) S
LHL
(> process_events ?@\(? { _time   = time) S
LHL
(>                     , _dt     = dt) S
LHL
(>                     , _dtmax  = dtmax) S
LHL
(>                     , _dtmin  = dtmin) S
LHL
(>                     , _events = events}\)) S
LHL
(>   = \(redo, ?' { _recalc = False) S
LHL
(>               , _events = events') S
LHL
(>               , _dt     = dt') S
LHL
(>               }\)) S
LHL
(>    where) S
LHL
(>      inframe  = \\e -> \(_etime e\) - time <= dtmin) S
LHL
(>      outframe = \\e -> \(_etime e\) - time >  dtmin) S
LHL
(>      events'  = filter outframe events) S
LHL
(>      ?'       = foldl \(\\?'' e -> \(_efunc e\) ?''\) ? \(filter inframe events\)) S
LHL
(>      redo     = _recalc ?') S
LHL
(>      dt'      = if length events' > 0) S
LHL
(>                 then let etime = _etime \(head events'\) in) S
LHL
(>                        if etime >= dtmax) S
LHL
(>                        then dtmax) S
LHL
(>                        else etime - time) S
LHL
(>                 else dt) S
PHL
LHL
(> print_data :: String -> ? -> ?) S
LHL
(> print_data comment ?@\(? { _prints  = prints) S
LHL
(>                         , _result  = result) S
LHL
(>                         , _dtprint = dtprint) S
LHL
(>                         , _time    = time) S
LHL
(>                         , _events  = events) S
LHL
(>                         }\)) S
LHL
(>   = ? { _result = result) S
LHL
(>                   ++ \(intercalate "\\t" \(map \(prncmd ?\) prints\)\)) S
LHL
(>                   ++ if length comment == 0) S
LHL
(>                      then "\\n") S
LHL
(>                      else "\\t# " ++ comment ++ "\\n") S
LHL
(>       , _events = schedule events $ Event \(time + dtprint\) "log print data" \(print_data "log"\)) S
LHL
(>       }) S
PHL
LHL
(> initialize :: ? -> ?) S
EndPage
EndDSCPage
EndSheet

%%Page: 3 126
/Lines 262 def
/PageCount 4 def
1 BeginSheet
BeginDSCPage
/LineNumber 145 def
/PageNumber 3 def
/HeaderLinesLeft[
 [/h0 (digsim.lhs)]
 [/h1 (/mnt/c/Users/FordRL/Documents/2019/03-04/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
144 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(> initialize ?@\(? { _time0 = time0) S
LHL
(>                 , _x_ic  = x_ic) S
LHL
(>                 , _xd_ic = xd_ic) S
LHL
(>                 }\)) S
LHL
(>   = ? { _time = time0) S
LHL
(>       , _x    = x_ic) S
LHL
(>       , _xd   = xd_ic) S
LHL
(>       , _states = [ \(\\?t ?' @\(? { _x  = x,  _xd  = xd  }\) -> ?' { _x  = x  + xd *?t }\)) S
LHL
(>                   , \(\\?t ?' @\(? { _xd = xd, _xdd = xdd }\) -> ?' { _xd = xd + xdd*?t }\)) S
LHL
(>                   ]) S
LHL
(>       }) S
PHL
LHL
(> setup_driver :: ? -> ?) S
LHL
(> setup_driver ?@\(? { _sets   = sets) S
LHL
(>                   , _tstop  = tstop) S
LHL
(>                   , _events = events) S
LHL
(>                   }\)) S
LHL
(>   = ?'' { _events = schedule \(_events ?''\) \(Event tstop "terminate simulation" terminate\)) S
LHL
(>         , _done   = False) S
LHL
(>         }) S
LHL
(>   where) S
LHL
(>     ?'  = foldl setcmd ? sets) S
LHL
(>     ?'' = ?' { _events = schedule events $ Event 0 "log print data" \(print_data "log"\) }) S
PHL
LHL
(> discrete :: ? -> ?) S
LHL
(> discrete ?@\(? { _coef_of_restitution = coef_of_restitution) S
LHL
(>               , _xd                  = xd) S
LHL
(>               }\)) S
LHL
(>   = print_data "bounce" ? { _xd     = -coef_of_restitution*xd) S
LHL
(>                           , _x      = 0.0) S
LHL
(>                           , _recalc = True) S
LHL
(>                           }) S
PHL
LHL
(> differential_equations :: ? -> ?) S
LHL
(> differential_equations ?@\(? { _gravity = gravity) S
LHL
(>                             , _x       = x) S
LHL
(>                             , _xd      = xd) S
LHL
(>                             , _xdd     = xdd) S
LHL
(>                             , _time    = time) S
LHL
(>                             , _dtmax   = dtmax) S
LHL
(>                             , _dtmin   = dtmin) S
LHL
(>                             , _events  = events) S
LHL
(>                             }\)) S
LHL
(>   = ? { _xdd = -gravity) S
LHL
(>       , _events = if x + xd*dtmax + 0.5*xdd*dtmax*dtmax <= 0.0) S
LHL
(>                   then let dtimpact = if x + xd*dtmin + 0.5*xdd*dtmin*dtmin <= 0.0) S
LHL
(>                                       then 0.0) S
LHL
(>                                       else if dtmin > \(-xd - sqrt\(xd*xd - 2.0*x*xdd\)\)/\(2.0*x\)) S
LHL
(>                                            then \(-xd + sqrt\(xd*xd - 2.0*x*xdd\)\)/\(2.0*x\)) S
LHL
(>                                            else \(-xd - sqrt\(xd*xd - 2.0*x*xdd\)\)/\(2.0*x\)) S
LHL
(>                        in schedule events $ Event \(time + dtimpact\) "bounce" discrete) S
LHL
(>                   else events) S
LHL
(>       }) S
PHL
LHL
(> reset :: ?) S
LHL
(> reset = ? { _jobno               = 0) S
LHL
(>           , _runno               = 0) S
LHL
(>           , _result              = "") S
LHL
(>           , _output              = "") S
LHL
(>           , _sets                = []) S
LHL
(>           , _prints              = []) S
LHL
(>           , _states              = []) S
LHL
(>           , _events              = []) S
LHL
(>           , _recalc              = False) S
LHL
(>           , _done                = False) S
LHL
(>           , _time                = 0.0) S
LHL
(>           , _time0               = 0.0) S
LHL
(>           , _tstop               = 0.0) S
LHL
(>           , _dt                  = 0.0) S
LHL
(>           , _dtmax               = 0.0) S
LHL
(>           , _dtmin               = 0.0) S
LHL
(>           , _dtprint             = 0.0) S
EndPage
EndDSCPage
EndSheet

%%Page: 4 127
/Lines 262 def
/PageCount 4 def
1 BeginSheet
BeginDSCPage
/LineNumber 217 def
/PageNumber 4 def
/HeaderLinesLeft[
 [/h0 (digsim.lhs)]
 [/h1 (/mnt/c/Users/FordRL/Documents/2019/03-04/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
216 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(>           , _coef_of_restitution = 0.0) S
LHL
(>           , _gravity             = 0.0) S
LHL
(>           , _x_ic                = 0.0) S
LHL
(>           , _xd_ic               = 0.0) S
LHL
(>           , _x                   = 0.0) S
LHL
(>           , _xd                  = 0.0) S
LHL
(>           , _xdd                 = 0.0) S
LHL
(>           }) S
PHL
LHL
(> set_defaults :: ? -> ?) S
LHL
(> set_defaults ?) S
LHL
(>   = ? { _dtmax   =  0.010  -- Set model independent data and reset time) S
LHL
(>       , _dt      =  0.010) S
LHL
(>       , _dtmin   =  0.001) S
LHL
(>       , _dtprint =  0.050) S
LHL
(>       , _time0   =  0.000) S
LHL
(>       , _tstop   = 10.000) S
LHL
(>       , _coef_of_restitution =  0.8 -- Set the default data for the simulation) S
LHL
(>       , _gravity             =  9.88) S
LHL
(>       , _x_ic                = 10.0) S
LHL
(>       , _xd_ic               =  0.0) S
LHL
(>       }) S
PHL
LHL
(> configurations :: String -> [?]) S
LHL
(> configurations = flatten . config) S
LHL
(>   where) S
LHL
(>     cards    = filter \(not . null\) . map \(words . map toLower . head . splitOn "#"\) . lines) S
LHL
(>     byruns   = filter \(not . null\) . splitWhen \(["run" ] ==\)) S
LHL
(>     byjobs   = filter \(not . null\) . splitWhen \(["stop"] ==\)) S
LHL
(>     config   = zip [1..] . map \(zip [1..] . byruns\) . byjobs . cards) S
LHL
(>     getprint = concat . map \(\\\(_:key:_\) -> [key]\). filter \(\("print" ==\) . head\)) S
LHL
(>     getset   = map \(\\\(_:key:val:_\) -> \(key,val\)\) . filter \(\("set"   ==\) . head\)) S
LHL
(>     flatten  =) S
LHL
(>       foldl \(\\result \(jobno,runs\) ->) S
LHL
(>                 foldl \(\\a \(runno,cmds\) ->) S
LHL
(>                           reset { _jobno  = jobno) S
LHL
(>                                 , _runno  = runno) S
LHL
(>                                 , _prints = "time" : getprint cmds) S
LHL
(>                                 , _sets   = getset cmds) S
LHL
(>                                 , _result = \(intercalate "\\t" \("# time" : getprint cmds\)\) ++ "\\) S
SL
(n") S
LHL
(>                                 , _output = if and [jobno == 1, runno == 1]) S
LHL
(>                                             then "output.dat") S
LHL
(>                                             else "output-" ++ show jobno ++ "." ++ show runno +) S
SL
(+ ".dat") S
LHL
(>                                 }:a ++ result\) [] runs\) []) S
PHL
PHL
EndPage
EndDSCPage
EndSheet


%%Page: 1 128
/Lines 262 def
/PageCount 4 def
1 BeginSheet
BeginDSCPage
/LineNumber 1 def
/PageNumber 1 def
/HeaderLinesLeft[
 [/h0 (digsim.lhs)]
 [/h1 (/mnt/c/Users/FordRL/Documents/2019/03-04/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
0 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(Digsim Build5 --- Bouncing ball) S
LHL
(===============================) S
PHL
LHL
(This models a bouncing ball.) S
PHL
LHL
(> import Numeric         \(showFFloat\)) S
LHL
(> import Data.List       \(sortBy,intercalate\)) S
LHL
(> import Data.List.Split \(splitOn,splitWhen\)) S
LHL
(> import Data.Ord        \(comparing\)) S
LHL
(> import Data.Char       \(toLower\)) S
PHL
LHL
(> main :: IO \(\)) S
LHL
(> main = do inputs <- readFile ) S
0.545 0.133 0.322 FG
("input.dat") S
0.000 0.000 0.000 FG
LHL
(>           mapM_ output $ digsim inputs) S
LHL
(>   where output ? = writeFile \(_output ?\) \(_result ?\)) S
PHL
LHL
(> digsim :: String -> [?]) S
LHL
(> digsim = map driver . configurations) S
PHL
LHL
(> driver :: ? -> ?) S
LHL
(> driver =  step . calc . initialize . setup_driver . set_defaults) S
LHL
(>   where redo \(b,?\) = if b then differential_equations ? else ?) S
LHL
(>         step = until _done \(calc . advance_states\)) S
LHL
(>         calc = redo . process_events . differential_equations) S
PHL
LHL
(> type State  = Float -> ? -> ?) S
LHL
(> type States = [State]) S
PHL
LHL
(> data Event = Event { _etime :: Float) S
LHL
(>                    , _ename :: String) S
LHL
(>                    , _efunc :: ? -> ?) S
LHL
(>                    }) S
LHL
(> type Events   = [Event]) S
LHL
(> instance Show Event where show event  = show \(_etime event\) ++ ) S
0.545 0.133 0.322 FG
(" ") S
0.000 0.000 0.000 FG
( ++ show \(_ename event\)) S
PHL
LHL
(> type SetCards = [\(String,String\)]) S
LHL
(> type PrnCards = [String]) S
LHL
(> prncmd :: ? -> String -> String) S
LHL
(> prncmd ? var = case common ? var ) S
0.545 0.133 0.322 FG
("") S
0.000 0.000 0.000 FG
( of) S
LHL
(>                  Just \(a,_\)  -> showFFloat \(Just 6\) \(a ?\) ) S
0.545 0.133 0.322 FG
("") S
0.000 0.000 0.000 FG
LHL
(>                  Nothing -> ) S
0.545 0.133 0.322 FG
("Error: no variable ") S
0.000 0.000 0.000 FG
( ++ var ++ ) S
0.545 0.133 0.322 FG
(".") S
0.000 0.000 0.000 FG
PHL
LHL
(> setcmd :: ? -> \(String,String\) -> ?) S
LHL
(> setcmd ? \(key,val\) = case common ? key val of) S
LHL
(>                      Just \(_,a\)  -> a) S
LHL
(>                      Nothing -> ?) S
LHL
(> data ? = ?) S
LHL
(>   { _jobno               :: Int       -- Current job number \(starts at 1\)) S
LHL
(>   , _runno               :: Int       -- Current run number \(starts at 1\)) S
LHL
(>   , _result              :: String    -- Simulation results) S
LHL
(>   , _output              :: String    -- Output file name) S
LHL
(>   , _sets                :: SetCards  -- List of SET commands) S
LHL
(>   , _prints              :: PrnCards  -- List of PRINT commands) S
LHL
(>   , _states              :: States    -- List of states to advance) S
LHL
(>   , _events              :: Events    -- Event queue) S
LHL
(>   , _recalc              :: Bool      -- Flag to recalculate differential equation) S
LHL
(>   , _done                :: Bool      -- Simulation complete flag) S
LHL
(>   , _time                :: Float     -- Simulation time [sec]) S
LHL
(>   , _time0               :: Float     -- Simulation start time [sec]) S
LHL
(>   , _tstop               :: Float     -- Simulation stop time [sec]) S
LHL
(>   , _dt                  :: Float     -- Simulation time step [sec]) S
LHL
(>   , _dtmax               :: Float     -- Simulation time step [sec]) S
LHL
(>   , _dtmin               :: Float     -- Simulation time step [sec]) S
LHL
(>   , _dtprint             :: Float     -- Print interval [sec]) S
LHL
(>   , _coef_of_restitution :: Float     -- Coefficent of restitution [Real]) S
0.545 0.133 0.322 FG
(") S
LHL
(>   , _gravity             :: Float     -- Acceleration due to gravity [m/sec**2]) S
LHL
(>   , _x_ic                :: Float     -- Initial position of ball [m]) S
LHL
(>   , _xd_ic               :: Float     -- Initial velocity of ball [m/sec]) S
LHL
(>   , _x                   :: Float     -- Position of ball [m]) S
LHL
(>   , _xd                  :: Float     -- Velocity of ball [m/sec]) S
LHL
(>   , _xdd                 :: Float     -- Acceleration of ball [m/sec**2]) S
LHL
(>   }) S
EndPage
EndDSCPage
EndSheet

%%Page: 2 129
/Lines 262 def
/PageCount 4 def
1 BeginSheet
BeginDSCPage
/LineNumber 73 def
/PageNumber 2 def
/HeaderLinesLeft[
 [/h0 (digsim.lhs)]
 [/h1 (/mnt/c/Users/FordRL/Documents/2019/03-04/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
72 BeginPage
/f0 F
false BG
0.545 0.133 0.322 FG
LHL
(> common :: ? -> String -> String -> Maybe \(? -> Float, ?\)) S
LHL
(> common ? var val = lookup var) S
LHL
(>   [ \(") S
0.000 0.000 0.000 FG
(tstop) S
0.545 0.133 0.322 FG
("               , \( _tstop                , ? { _tstop               = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(time) S
0.545 0.133 0.322 FG
("                , \( _time                 , ? { _time                = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(time0) S
0.545 0.133 0.322 FG
("               , \( _time0                , ? { _time0               = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(tstop) S
0.545 0.133 0.322 FG
("               , \( _tstop                , ? { _tstop               = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(dt) S
0.545 0.133 0.322 FG
("                  , \( _dt                   , ? { _dt                  = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(dtmax) S
0.545 0.133 0.322 FG
("               , \( _dtmax                , ? { _dtmax               = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(dtmin) S
0.545 0.133 0.322 FG
("               , \( _dtmin                , ? { _dtmin               = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(dtprint) S
0.545 0.133 0.322 FG
("             , \( _dtprint              , ? { _dtprint             = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(coef_of_restitution) S
0.545 0.133 0.322 FG
(" , \( _coef_of_restitution  , ? { _coef_of_restitution = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(gravity) S
0.545 0.133 0.322 FG
("             , \( _gravity              , ? { _gravity             = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(x_ic) S
0.545 0.133 0.322 FG
("                , \( _x_ic                 , ? { _x_ic                = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(xd_ic) S
0.545 0.133 0.322 FG
("               , \( _xd_ic                , ? { _xd_ic               = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(x) S
0.545 0.133 0.322 FG
("                   , \( _x                    , ? { _x                   = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(xd) S
0.545 0.133 0.322 FG
("                  , \( _xd                   , ? { _xd                  = read val }\) \)) S
LHL
(>   ]) S
PHL
LHL
(> advance_states :: ? -> ?) S
LHL
(> advance_states ?@\(? { _time   = time) S
LHL
(>                     , _dt     = dt) S
LHL
(>                     , _states = states) S
LHL
(>                     }\)) S
LHL
(>   = euler { _time = time + dt }) S
LHL
(>   where euler = foldl \(\\?' f -> f dt ?'\) ? states) S
PHL
LHL
(> terminate :: ? -> ?) S
LHL
(> terminate ? = ? { _done = True }) S
PHL
LHL
(> schedule :: Events -> Event -> Events) S
LHL
(> schedule events event = sortBy \(comparing _etime\) \(event:events\)) S
PHL
LHL
(> process_events :: ? -> \(Bool, ?\)) S
LHL
(> process_events ?@\(? { _time   = time) S
LHL
(>                     , _dt     = dt) S
LHL
(>                     , _dtmax  = dtmax) S
LHL
(>                     , _dtmin  = dtmin) S
LHL
(>                     , _events = events}\)) S
LHL
(>   = \(redo, ?' { _recalc = False) S
LHL
(>               , _events = events') S
LHL
(>               , _dt     = dt') S
LHL
(>               }\)) S
LHL
(>    where) S
LHL
(>      inframe  = \\e -> \(_etime e\) - time <= dtmin) S
LHL
(>      outframe = \\e -> \(_etime e\) - time >  dtmin) S
LHL
(>      events'  = filter outframe events) S
LHL
(>      ?'       = foldl \(\\?'' e -> \(_efunc e\) ?''\) ? \(filter inframe events\)) S
LHL
(>      redo     = _recalc ?') S
LHL
(>      dt'      = if length events' > 0) S
LHL
(>                 then let etime = _etime \(head events'\) in) S
LHL
(>                        if etime >= dtmax) S
LHL
(>                        then dtmax) S
LHL
(>                        else etime - time) S
LHL
(>                 else dt) S
PHL
LHL
(> print_data :: String -> ? -> ?) S
LHL
(> print_data comment ?@\(? { _prints  = prints) S
LHL
(>                         , _result  = result) S
LHL
(>                         , _dtprint = dtprint) S
LHL
(>                         , _time    = time) S
LHL
(>                         , _events  = events) S
LHL
(>                         }\)) S
LHL
(>   = ? { _result = result) S
LHL
(>                   ++ \(intercalate ") S
0.000 0.000 0.000 FG
(\\t) S
0.545 0.133 0.322 FG
(" \(map \(prncmd ?\) prints\)\)) S
LHL
(>                   ++ if length comment == 0) S
LHL
(>                      then ") S
0.000 0.000 0.000 FG
(\\n) S
0.545 0.133 0.322 FG
(") S
LHL
(>                      else ") S
0.000 0.000 0.000 FG
(\\t# ) S
0.545 0.133 0.322 FG
(" ++ comment ++ ") S
0.000 0.000 0.000 FG
(\\n) S
0.545 0.133 0.322 FG
(") S
LHL
(>       , _events = schedule events $ Event \(time + dtprint\) ") S
0.000 0.000 0.000 FG
(log print data) S
0.545 0.133 0.322 FG
(" \(print_data ") S
0.000 0.000 0.000 FG
(log) S
0.545 0.133 0.322 FG
("\)) S
LHL
(>       }) S
PHL
LHL
(> initialize :: ? -> ?) S
EndPage
EndDSCPage
EndSheet

%%Page: 3 130
/Lines 262 def
/PageCount 4 def
1 BeginSheet
BeginDSCPage
/LineNumber 145 def
/PageNumber 3 def
/HeaderLinesLeft[
 [/h0 (digsim.lhs)]
 [/h1 (/mnt/c/Users/FordRL/Documents/2019/03-04/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
144 BeginPage
/f0 F
false BG
0.545 0.133 0.322 FG
(> initialize ?@\(? { _time0 = time0) S
LHL
(>                 , _x_ic  = x_ic) S
LHL
(>                 , _xd_ic = xd_ic) S
LHL
(>                 }\)) S
LHL
(>   = ? { _time = time0) S
LHL
(>       , _x    = x_ic) S
LHL
(>       , _xd   = xd_ic) S
LHL
(>       , _states = [ \(\\?t ?' @\(? { _x  = x,  _xd  = xd  }\) -> ?' { _x  = x  + xd *?t }\)) S
LHL
(>                   , \(\\?t ?' @\(? { _xd = xd, _xdd = xdd }\) -> ?' { _xd = xd + xdd*?t }\)) S
LHL
(>                   ]) S
LHL
(>       }) S
PHL
LHL
(> setup_driver :: ? -> ?) S
LHL
(> setup_driver ?@\(? { _sets   = sets) S
LHL
(>                   , _tstop  = tstop) S
LHL
(>                   , _events = events) S
LHL
(>                   }\)) S
LHL
(>   = ?'' { _events = schedule \(_events ?''\) \(Event tstop ") S
0.000 0.000 0.000 FG
(terminate simulation) S
0.545 0.133 0.322 FG
(" terminate\)) S
LHL
(>         , _done   = False) S
LHL
(>         }) S
LHL
(>   where) S
LHL
(>     ?'  = foldl setcmd ? sets) S
LHL
(>     ?'' = ?' { _events = schedule events $ Event 0 ") S
0.000 0.000 0.000 FG
(log print data) S
0.545 0.133 0.322 FG
(" \(print_data ") S
0.000 0.000 0.000 FG
(log) S
0.545 0.133 0.322 FG
("\) }) S
PHL
LHL
(> discrete :: ? -> ?) S
LHL
(> discrete ?@\(? { _coef_of_restitution = coef_of_restitution) S
LHL
(>               , _xd                  = xd) S
LHL
(>               }\)) S
LHL
(>   = print_data ") S
0.000 0.000 0.000 FG
(bounce) S
0.545 0.133 0.322 FG
(" ? { _xd     = -coef_of_restitution*xd) S
LHL
(>                           , _x      = 0.0) S
LHL
(>                           , _recalc = True) S
LHL
(>                           }) S
PHL
LHL
(> differential_equations :: ? -> ?) S
LHL
(> differential_equations ?@\(? { _gravity = gravity) S
LHL
(>                             , _x       = x) S
LHL
(>                             , _xd      = xd) S
LHL
(>                             , _xdd     = xdd) S
LHL
(>                             , _time    = time) S
LHL
(>                             , _dtmax   = dtmax) S
LHL
(>                             , _dtmin   = dtmin) S
LHL
(>                             , _events  = events) S
LHL
(>                             }\)) S
LHL
(>   = ? { _xdd = -gravity) S
LHL
(>       , _events = if x + xd*dtmax + 0.5*xdd*dtmax*dtmax <= 0.0) S
LHL
(>                   then let dtimpact = if x + xd*dtmin + 0.5*xdd*dtmin*dtmin <= 0.0) S
LHL
(>                                       then 0.0) S
LHL
(>                                       else if dtmin > \(-xd - sqrt\(xd*xd - 2.0*x*xdd\)\)/\(2.0*x\)) S
LHL
(>                                            then \(-xd + sqrt\(xd*xd - 2.0*x*xdd\)\)/\(2.0*x\)) S
LHL
(>                                            else \(-xd - sqrt\(xd*xd - 2.0*x*xdd\)\)/\(2.0*x\)) S
LHL
(>                        in schedule events $ Event \(time + dtimpact\) ") S
0.000 0.000 0.000 FG
(bounce) S
0.545 0.133 0.322 FG
(" discrete) S
LHL
(>                   else events) S
LHL
(>       }) S
PHL
LHL
(> reset :: ?) S
LHL
(> reset = ? { _jobno               = 0) S
LHL
(>           , _runno               = 0) S
LHL
(>           , _result              = "") S
LHL
(>           , _output              = "") S
LHL
(>           , _sets                = []) S
LHL
(>           , _prints              = []) S
LHL
(>           , _states              = []) S
LHL
(>           , _events              = []) S
LHL
(>           , _recalc              = False) S
LHL
(>           , _done                = False) S
LHL
(>           , _time                = 0.0) S
LHL
(>           , _time0               = 0.0) S
LHL
(>           , _tstop               = 0.0) S
LHL
(>           , _dt                  = 0.0) S
LHL
(>           , _dtmax               = 0.0) S
LHL
(>           , _dtmin               = 0.0) S
LHL
(>           , _dtprint             = 0.0) S
EndPage
EndDSCPage
EndSheet

%%Page: 4 131
/Lines 262 def
/PageCount 4 def
1 BeginSheet
BeginDSCPage
/LineNumber 217 def
/PageNumber 4 def
/HeaderLinesLeft[
 [/h0 (digsim.lhs)]
 [/h1 (/mnt/c/Users/FordRL/Documents/2019/03-04/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
216 BeginPage
/f0 F
false BG
0.545 0.133 0.322 FG
(>           , _coef_of_restitution = 0.0) S
LHL
(>           , _gravity             = 0.0) S
LHL
(>           , _x_ic                = 0.0) S
LHL
(>           , _xd_ic               = 0.0) S
LHL
(>           , _x                   = 0.0) S
LHL
(>           , _xd                  = 0.0) S
LHL
(>           , _xdd                 = 0.0) S
LHL
(>           }) S
PHL
LHL
(> set_defaults :: ? -> ?) S
LHL
(> set_defaults ?) S
LHL
(>   = ? { _dtmax   =  0.010  -- Set model independent data and reset time) S
LHL
(>       , _dt      =  0.010) S
LHL
(>       , _dtmin   =  0.001) S
LHL
(>       , _dtprint =  0.050) S
LHL
(>       , _time0   =  0.000) S
LHL
(>       , _tstop   = 10.000) S
LHL
(>       , _coef_of_restitution =  0.8 -- Set the default data for the simulation) S
LHL
(>       , _gravity             =  9.88) S
LHL
(>       , _x_ic                = 10.0) S
LHL
(>       , _xd_ic               =  0.0) S
LHL
(>       }) S
PHL
LHL
(> configurations :: String -> [?]) S
LHL
(> configurations = flatten . config) S
LHL
(>   where) S
LHL
(>     cards    = filter \(not . null\) . map \(words . map toLower . head . splitOn ") S
0.000 0.000 0.000 FG
(#) S
0.545 0.133 0.322 FG
("\) . lines) S
LHL
(>     byruns   = filter \(not . null\) . splitWhen \([") S
0.000 0.000 0.000 FG
(run) S
0.545 0.133 0.322 FG
(" ] ==\)) S
LHL
(>     byjobs   = filter \(not . null\) . splitWhen \([") S
0.000 0.000 0.000 FG
(stop) S
0.545 0.133 0.322 FG
("] ==\)) S
LHL
(>     config   = zip [1..] . map \(zip [1..] . byruns\) . byjobs . cards) S
LHL
(>     getprint = concat . map \(\\\(_:key:_\) -> [key]\). filter \(\(") S
0.000 0.000 0.000 FG
(print) S
0.545 0.133 0.322 FG
(" ==\) . head\)) S
LHL
(>     getset   = map \(\\\(_:key:val:_\) -> \(key,val\)\) . filter \(\(") S
0.000 0.000 0.000 FG
(set) S
0.545 0.133 0.322 FG
("   ==\) . head\)) S
LHL
(>     flatten  =) S
LHL
(>       foldl \(\\result \(jobno,runs\) ->) S
LHL
(>                 foldl \(\\a \(runno,cmds\) ->) S
LHL
(>                           reset { _jobno  = jobno) S
LHL
(>                                 , _runno  = runno) S
LHL
(>                                 , _prints = ") S
0.000 0.000 0.000 FG
(time) S
0.545 0.133 0.322 FG
(" : getprint cmds) S
LHL
(>                                 , _sets   = getset cmds) S
LHL
(>                                 , _result = \(intercalate ") S
0.000 0.000 0.000 FG
(\\t) S
0.545 0.133 0.322 FG
(" \(") S
0.000 0.000 0.000 FG
(# time) S
0.545 0.133 0.322 FG
(" : getprint cmds\)\) ++ ") S
0.000 0.000 0.000 FG
(\\) S
SL
(n) S
0.545 0.133 0.322 FG
(") S
LHL
(>                                 , _output = if and [jobno == 1, runno == 1]) S
LHL
(>                                             then ") S
0.000 0.000 0.000 FG
(output.dat) S
0.545 0.133 0.322 FG
(") S
LHL
(>                                             else ") S
0.000 0.000 0.000 FG
(output-) S
0.545 0.133 0.322 FG
(" ++ show jobno ++ ") S
0.000 0.000 0.000 FG
(.) S
0.545 0.133 0.322 FG
(" ++ show runno +) S
SL
(+ ") S
0.000 0.000 0.000 FG
(.dat) S
0.545 0.133 0.322 FG
(") S
LHL
(>                                 }:a ++ result\) [] runs\) []) S
PHL
0.698 0.133 0.133 FG
PHL
EndPage
EndDSCPage
EndSheet


%%Page: 1 132
/Lines 262 def
/PageCount 4 def
1 BeginSheet
BeginDSCPage
/LineNumber 1 def
/PageNumber 1 def
/HeaderLinesLeft[
 [/h0 (digsim.lhs)]
 [/h1 (/mnt/c/Users/FordRL/Documents/2019/03-04/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
0 BeginPage
/f0 F
false BG
0.000 0.000 0.000 FG
(Digsim Build5 --- Bouncing ball) S
LHL
(===============================) S
PHL
LHL
(This models a bouncing ball.) S
PHL
LHL
(> import Numeric         \(showFFloat\)) S
LHL
(> import Data.List       \(sortBy,intercalate\)) S
LHL
(> import Data.List.Split \(splitOn,splitWhen\)) S
LHL
(> import Data.Ord        \(comparing\)) S
LHL
(> import Data.Char       \(toLower\)) S
PHL
LHL
(> main :: IO \(\)) S
LHL
(> main = do inputs <- readFile ) S
0.545 0.133 0.322 FG
("input.dat") S
0.000 0.000 0.000 FG
LHL
(>           mapM_ output $ digsim inputs) S
LHL
(>   where output ? = writeFile \(_output ?\) \(_result ?\)) S
PHL
LHL
(> digsim :: String -> [?]) S
LHL
(> digsim = map driver . configurations) S
PHL
LHL
(> driver :: ? -> ?) S
LHL
(> driver =  step . calc . initialize . setup_driver . set_defaults) S
LHL
(>   where redo \(b,?\) = if b then differential_equations ? else ?) S
LHL
(>         step = until _done \(calc . advance_states\)) S
LHL
(>         calc = redo . process_events . differential_equations) S
PHL
LHL
(> type State  = Float -> ? -> ?) S
LHL
(> type States = [State]) S
PHL
LHL
(> data Event = Event { _etime :: Float) S
LHL
(>                    , _ename :: String) S
LHL
(>                    , _efunc :: ? -> ?) S
LHL
(>                    }) S
LHL
(> type Events   = [Event]) S
LHL
(> instance Show Event where show event  = show \(_etime event\) ++ ) S
0.545 0.133 0.322 FG
(" ") S
0.000 0.000 0.000 FG
( ++ show \(_ename event\)) S
PHL
LHL
(> type SetCards = [\(String,String\)]) S
LHL
(> type PrnCards = [String]) S
LHL
(> prncmd :: ? -> String -> String) S
LHL
(> prncmd ? var = case common ? var ) S
0.545 0.133 0.322 FG
("") S
0.000 0.000 0.000 FG
( of) S
LHL
(>                  Just \(a,_\)  -> showFFloat \(Just 6\) \(a ?\) ) S
0.545 0.133 0.322 FG
("") S
0.000 0.000 0.000 FG
LHL
(>                  Nothing -> ) S
0.545 0.133 0.322 FG
("Error: no variable ") S
0.000 0.000 0.000 FG
( ++ var ++ ) S
0.545 0.133 0.322 FG
(".") S
0.000 0.000 0.000 FG
PHL
LHL
(> setcmd :: ? -> \(String,String\) -> ?) S
LHL
(> setcmd ? \(key,val\) = case common ? key val of) S
LHL
(>                      Just \(_,a\)  -> a) S
LHL
(>                      Nothing -> ?) S
LHL
(> data ? = ?) S
LHL
(>   { _jobno               :: Int       -- Current job number \(starts at 1\)) S
LHL
(>   , _runno               :: Int       -- Current run number \(starts at 1\)) S
LHL
(>   , _result              :: String    -- Simulation results) S
LHL
(>   , _output              :: String    -- Output file name) S
LHL
(>   , _sets                :: SetCards  -- List of SET commands) S
LHL
(>   , _prints              :: PrnCards  -- List of PRINT commands) S
LHL
(>   , _states              :: States    -- List of states to advance) S
LHL
(>   , _events              :: Events    -- Event queue) S
LHL
(>   , _recalc              :: Bool      -- Flag to recalculate differential equation) S
LHL
(>   , _done                :: Bool      -- Simulation complete flag) S
LHL
(>   , _time                :: Float     -- Simulation time [sec]) S
LHL
(>   , _time0               :: Float     -- Simulation start time [sec]) S
LHL
(>   , _tstop               :: Float     -- Simulation stop time [sec]) S
LHL
(>   , _dt                  :: Float     -- Simulation time step [sec]) S
LHL
(>   , _dtmax               :: Float     -- Simulation time step [sec]) S
LHL
(>   , _dtmin               :: Float     -- Simulation time step [sec]) S
LHL
(>   , _dtprint             :: Float     -- Print interval [sec]) S
LHL
(>   , _coef_of_restitution :: Float     -- Coefficent of restitution [Real]) S
0.545 0.133 0.322 FG
(") S
LHL
(>   , _gravity             :: Float     -- Acceleration due to gravity [m/sec**2]) S
LHL
(>   , _x_ic                :: Float     -- Initial position of ball [m]) S
LHL
(>   , _xd_ic               :: Float     -- Initial velocity of ball [m/sec]) S
LHL
(>   , _x                   :: Float     -- Position of ball [m]) S
LHL
(>   , _xd                  :: Float     -- Velocity of ball [m/sec]) S
LHL
(>   , _xdd                 :: Float     -- Acceleration of ball [m/sec**2]) S
LHL
(>   }) S
EndPage
EndDSCPage
EndSheet

%%Page: 2 133
/Lines 262 def
/PageCount 4 def
1 BeginSheet
BeginDSCPage
/LineNumber 73 def
/PageNumber 2 def
/HeaderLinesLeft[
 [/h0 (digsim.lhs)]
 [/h1 (/mnt/c/Users/FordRL/Documents/2019/03-04/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
72 BeginPage
/f0 F
false BG
0.545 0.133 0.322 FG
LHL
(> common :: ? -> String -> String -> Maybe \(? -> Float, ?\)) S
LHL
(> common ? var val = lookup var) S
LHL
(>   [ \(") S
0.000 0.000 0.000 FG
(tstop) S
0.545 0.133 0.322 FG
("               , \( _tstop                , ? { _tstop               = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(time) S
0.545 0.133 0.322 FG
("                , \( _time                 , ? { _time                = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(time0) S
0.545 0.133 0.322 FG
("               , \( _time0                , ? { _time0               = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(tstop) S
0.545 0.133 0.322 FG
("               , \( _tstop                , ? { _tstop               = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(dt) S
0.545 0.133 0.322 FG
("                  , \( _dt                   , ? { _dt                  = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(dtmax) S
0.545 0.133 0.322 FG
("               , \( _dtmax                , ? { _dtmax               = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(dtmin) S
0.545 0.133 0.322 FG
("               , \( _dtmin                , ? { _dtmin               = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(dtprint) S
0.545 0.133 0.322 FG
("             , \( _dtprint              , ? { _dtprint             = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(coef_of_restitution) S
0.545 0.133 0.322 FG
(" , \( _coef_of_restitution  , ? { _coef_of_restitution = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(gravity) S
0.545 0.133 0.322 FG
("             , \( _gravity              , ? { _gravity             = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(x_ic) S
0.545 0.133 0.322 FG
("                , \( _x_ic                 , ? { _x_ic                = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(xd_ic) S
0.545 0.133 0.322 FG
("               , \( _xd_ic                , ? { _xd_ic               = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(x) S
0.545 0.133 0.322 FG
("                   , \( _x                    , ? { _x                   = read val }\) \)) S
LHL
(>   , \(") S
0.000 0.000 0.000 FG
(xd) S
0.545 0.133 0.322 FG
("                  , \( _xd                   , ? { _xd                  = read val }\) \)) S
LHL
(>   ]) S
PHL
LHL
(> advance_states :: ? -> ?) S
LHL
(> advance_states ?@\(? { _time   = time) S
LHL
(>                     , _dt     = dt) S
LHL
(>                     , _states = states) S
LHL
(>                     }\)) S
LHL
(>   = euler { _time = time + dt }) S
LHL
(>   where euler = foldl \(\\?' f -> f dt ?'\) ? states) S
PHL
LHL
(> terminate :: ? -> ?) S
LHL
(> terminate ? = ? { _done = True }) S
PHL
LHL
(> schedule :: Events -> Event -> Events) S
LHL
(> schedule events event = sortBy \(comparing _etime\) \(event:events\)) S
PHL
LHL
(> process_events :: ? -> \(Bool, ?\)) S
LHL
(> process_events ?@\(? { _time   = time) S
LHL
(>                     , _dt     = dt) S
LHL
(>                     , _dtmax  = dtmax) S
LHL
(>                     , _dtmin  = dtmin) S
LHL
(>                     , _events = events}\)) S
LHL
(>   = \(redo, ?' { _recalc = False) S
LHL
(>               , _events = events') S
LHL
(>               , _dt     = dt') S
LHL
(>               }\)) S
LHL
(>    where) S
LHL
(>      inframe  = \\e -> \(_etime e\) - time <= dtmin) S
LHL
(>      outframe = \\e -> \(_etime e\) - time >  dtmin) S
LHL
(>      events'  = filter outframe events) S
LHL
(>      ?'       = foldl \(\\?'' e -> \(_efunc e\) ?''\) ? \(filter inframe events\)) S
LHL
(>      redo     = _recalc ?') S
LHL
(>      dt'      = if length events' > 0) S
LHL
(>                 then let etime = _etime \(head events'\) in) S
LHL
(>                        if etime >= dtmax) S
LHL
(>                        then dtmax) S
LHL
(>                        else etime - time) S
LHL
(>                 else dt) S
PHL
LHL
(> print_data :: String -> ? -> ?) S
LHL
(> print_data comment ?@\(? { _prints  = prints) S
LHL
(>                         , _result  = result) S
LHL
(>                         , _dtprint = dtprint) S
LHL
(>                         , _time    = time) S
LHL
(>                         , _events  = events) S
LHL
(>                         }\)) S
LHL
(>   = ? { _result = result) S
LHL
(>                   ++ \(intercalate ") S
0.000 0.000 0.000 FG
(\\t) S
0.545 0.133 0.322 FG
(" \(map \(prncmd ?\) prints\)\)) S
LHL
(>                   ++ if length comment == 0) S
LHL
(>                      then ") S
0.000 0.000 0.000 FG
(\\n) S
0.545 0.133 0.322 FG
(") S
LHL
(>                      else ") S
0.000 0.000 0.000 FG
(\\t# ) S
0.545 0.133 0.322 FG
(" ++ comment ++ ") S
0.000 0.000 0.000 FG
(\\n) S
0.545 0.133 0.322 FG
(") S
LHL
(>       , _events = schedule events $ Event \(time + dtprint\) ") S
0.000 0.000 0.000 FG
(log print data) S
0.545 0.133 0.322 FG
(" \(print_data ") S
0.000 0.000 0.000 FG
(log) S
0.545 0.133 0.322 FG
("\)) S
LHL
(>       }) S
PHL
LHL
(> initialize :: ? -> ?) S
EndPage
EndDSCPage
EndSheet

%%Page: 3 134
/Lines 262 def
/PageCount 4 def
1 BeginSheet
BeginDSCPage
/LineNumber 145 def
/PageNumber 3 def
/HeaderLinesLeft[
 [/h0 (digsim.lhs)]
 [/h1 (/mnt/c/Users/FordRL/Documents/2019/03-04/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
144 BeginPage
/f0 F
false BG
0.545 0.133 0.322 FG
(> initialize ?@\(? { _time0 = time0) S
LHL
(>                 , _x_ic  = x_ic) S
LHL
(>                 , _xd_ic = xd_ic) S
LHL
(>                 }\)) S
LHL
(>   = ? { _time = time0) S
LHL
(>       , _x    = x_ic) S
LHL
(>       , _xd   = xd_ic) S
LHL
(>       , _states = [ \(\\?t ?' @\(? { _x  = x,  _xd  = xd  }\) -> ?' { _x  = x  + xd *?t }\)) S
LHL
(>                   , \(\\?t ?' @\(? { _xd = xd, _xdd = xdd }\) -> ?' { _xd = xd + xdd*?t }\)) S
LHL
(>                   ]) S
LHL
(>       }) S
PHL
LHL
(> setup_driver :: ? -> ?) S
LHL
(> setup_driver ?@\(? { _sets   = sets) S
LHL
(>                   , _tstop  = tstop) S
LHL
(>                   , _events = events) S
LHL
(>                   }\)) S
LHL
(>   = ?'' { _events = schedule \(_events ?''\) \(Event tstop ") S
0.000 0.000 0.000 FG
(terminate simulation) S
0.545 0.133 0.322 FG
(" terminate\)) S
LHL
(>         , _done   = False) S
LHL
(>         }) S
LHL
(>   where) S
LHL
(>     ?'  = foldl setcmd ? sets) S
LHL
(>     ?'' = ?' { _events = schedule events $ Event 0 ") S
0.000 0.000 0.000 FG
(log print data) S
0.545 0.133 0.322 FG
(" \(print_data ") S
0.000 0.000 0.000 FG
(log) S
0.545 0.133 0.322 FG
("\) }) S
PHL
LHL
(> discrete :: ? -> ?) S
LHL
(> discrete ?@\(? { _coef_of_restitution = coef_of_restitution) S
LHL
(>               , _xd                  = xd) S
LHL
(>               }\)) S
LHL
(>   = print_data ") S
0.000 0.000 0.000 FG
(bounce) S
0.545 0.133 0.322 FG
(" ? { _xd     = -coef_of_restitution*xd) S
LHL
(>                           , _x      = 0.0) S
LHL
(>                           , _recalc = True) S
LHL
(>                           }) S
PHL
LHL
(> differential_equations :: ? -> ?) S
LHL
(> differential_equations ?@\(? { _gravity = gravity) S
LHL
(>                             , _x       = x) S
LHL
(>                             , _xd      = xd) S
LHL
(>                             , _xdd     = xdd) S
LHL
(>                             , _time    = time) S
LHL
(>                             , _dtmax   = dtmax) S
LHL
(>                             , _dtmin   = dtmin) S
LHL
(>                             , _events  = events) S
LHL
(>                             }\)) S
LHL
(>   = ? { _xdd = -gravity) S
LHL
(>       , _events = if x + xd*dtmax + 0.5*xdd*dtmax*dtmax <= 0.0) S
LHL
(>                   then let dtimpact = if x + xd*dtmin + 0.5*xdd*dtmin*dtmin <= 0.0) S
LHL
(>                                       then 0.0) S
LHL
(>                                       else if dtmin > \(-xd - sqrt\(xd*xd - 2.0*x*xdd\)\)/\(2.0*x\)) S
LHL
(>                                            then \(-xd + sqrt\(xd*xd - 2.0*x*xdd\)\)/\(2.0*x\)) S
LHL
(>                                            else \(-xd - sqrt\(xd*xd - 2.0*x*xdd\)\)/\(2.0*x\)) S
LHL
(>                        in schedule events $ Event \(time + dtimpact\) ") S
0.000 0.000 0.000 FG
(bounce) S
0.545 0.133 0.322 FG
(" discrete) S
LHL
(>                   else events) S
LHL
(>       }) S
PHL
LHL
(> reset :: ?) S
LHL
(> reset = ? { _jobno               = 0) S
LHL
(>           , _runno               = 0) S
LHL
(>           , _result              = "") S
LHL
(>           , _output              = "") S
LHL
(>           , _sets                = []) S
LHL
(>           , _prints              = []) S
LHL
(>           , _states              = []) S
LHL
(>           , _events              = []) S
LHL
(>           , _recalc              = False) S
LHL
(>           , _done                = False) S
LHL
(>           , _time                = 0.0) S
LHL
(>           , _time0               = 0.0) S
LHL
(>           , _tstop               = 0.0) S
LHL
(>           , _dt                  = 0.0) S
LHL
(>           , _dtmax               = 0.0) S
LHL
(>           , _dtmin               = 0.0) S
LHL
(>           , _dtprint             = 0.0) S
EndPage
EndDSCPage
EndSheet

%%Page: 4 135
/Lines 262 def
/PageCount 4 def
1 BeginSheet
BeginDSCPage
/LineNumber 217 def
/PageNumber 4 def
/HeaderLinesLeft[
 [/h0 (digsim.lhs)]
 [/h1 (/mnt/c/Users/FordRL/Documents/2019/03-04/)]
]def
/HeaderLinesRight[
 [/h0 /pagenumberstring load]
 [/h1 (03/04/2019)]
]def
2 SetHeaderLines
216 BeginPage
/f0 F
false BG
0.545 0.133 0.322 FG
(>           , _coef_of_restitution = 0.0) S
LHL
(>           , _gravity             = 0.0) S
LHL
(>           , _x_ic                = 0.0) S
LHL
(>           , _xd_ic               = 0.0) S
LHL
(>           , _x                   = 0.0) S
LHL
(>           , _xd                  = 0.0) S
LHL
(>           , _xdd                 = 0.0) S
LHL
(>           }) S
PHL
LHL
(> set_defaults :: ? -> ?) S
LHL
(> set_defaults ?) S
LHL
(>   = ? { _dtmax   =  0.010  -- Set model independent data and reset time) S
LHL
(>       , _dt      =  0.010) S
LHL
(>       , _dtmin   =  0.001) S
LHL
(>       , _dtprint =  0.050) S
LHL
(>       , _time0   =  0.000) S
LHL
(>       , _tstop   = 10.000) S
LHL
(>       , _coef_of_restitution =  0.8 -- Set the default data for the simulation) S
LHL
(>       , _gravity             =  9.88) S
LHL
(>       , _x_ic                = 10.0) S
LHL
(>       , _xd_ic               =  0.0) S
LHL
(>       }) S
PHL
LHL
(> configurations :: String -> [?]) S
LHL
(> configurations = flatten . config) S
LHL
(>   where) S
LHL
(>     cards    = filter \(not . null\) . map \(words . map toLower . head . splitOn ") S
0.000 0.000 0.000 FG
(#) S
0.545 0.133 0.322 FG
("\) . lines) S
LHL
(>     byruns   = filter \(not . null\) . splitWhen \([") S
0.000 0.000 0.000 FG
(run) S
0.545 0.133 0.322 FG
(" ] ==\)) S
LHL
(>     byjobs   = filter \(not . null\) . splitWhen \([") S
0.000 0.000 0.000 FG
(stop) S
0.545 0.133 0.322 FG
("] ==\)) S
LHL
(>     config   = zip [1..] . map \(zip [1..] . byruns\) . byjobs . cards) S
LHL
(>     getprint = concat . map \(\\\(_:key:_\) -> [key]\). filter \(\(") S
0.000 0.000 0.000 FG
(print) S
0.545 0.133 0.322 FG
(" ==\) . head\)) S
LHL
(>     getset   = map \(\\\(_:key:val:_\) -> \(key,val\)\) . filter \(\(") S
0.000 0.000 0.000 FG
(set) S
0.545 0.133 0.322 FG
("   ==\) . head\)) S
LHL
(>     flatten  =) S
LHL
(>       foldl \(\\result \(jobno,runs\) ->) S
LHL
(>                 foldl \(\\a \(runno,cmds\) ->) S
LHL
(>                           reset { _jobno  = jobno) S
LHL
(>                                 , _runno  = runno) S
LHL
(>                                 , _prints = ") S
0.000 0.000 0.000 FG
(time) S
0.545 0.133 0.322 FG
(" : getprint cmds) S
LHL
(>                                 , _sets   = getset cmds) S
LHL
(>                                 , _result = \(intercalate ") S
0.000 0.000 0.000 FG
(\\t) S
0.545 0.133 0.322 FG
(" \(") S
0.000 0.000 0.000 FG
(# time) S
0.545 0.133 0.322 FG
(" : getprint cmds\)\) ++ ") S
0.000 0.000 0.000 FG
(\\) S
SL
(n) S
0.545 0.133 0.322 FG
(") S
LHL
(>                                 , _output = if and [jobno == 1, runno == 1]) S
LHL
(>                                             then ") S
0.000 0.000 0.000 FG
(output.dat) S
0.545 0.133 0.322 FG
(") S
LHL
(>                                             else ") S
0.000 0.000 0.000 FG
(output-) S
0.545 0.133 0.322 FG
(" ++ show jobno ++ ") S
0.000 0.000 0.000 FG
(.) S
0.545 0.133 0.322 FG
(" ++ show runno +) S
SL
(+ ") S
0.000 0.000 0.000 FG
(.dat) S
0.545 0.133 0.322 FG
(") S
LHL
(>                                 }:a ++ result\) [] runs\) []) S
PHL
0.698 0.133 0.133 FG
PHL
EndPage
EndDSCPage
EndSheet

%%Trailer
%%Pages: 135

EndDoc

%%EOF
